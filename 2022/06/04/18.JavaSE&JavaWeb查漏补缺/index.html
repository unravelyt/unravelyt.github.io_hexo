<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【Java】JavaSE &amp; JavaWeb查漏补缺 | Unravely</title><meta name="keywords" content="Java,JavaSE,JavaWeb"><meta name="author" content="一只草履虫"><meta name="copyright" content="一只草履虫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、JavaSE1. 基本数据类型范围Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。    类型名称 关键字（默认值） 包装类 占用内存 取值范围    字节型 byte（0） Byte 1 字节 -128~127   短整型 short（0） Short 2 字节 -32768~32767   整型 int（0） Integer 4 字节">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java】JavaSE &amp; JavaWeb查漏补缺">
<meta property="og:url" content="http://example.com/2022/06/04/18.JavaSE&JavaWeb%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/index.html">
<meta property="og:site_name" content="Unravely">
<meta property="og:description" content="一、JavaSE1. 基本数据类型范围Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。    类型名称 关键字（默认值） 包装类 占用内存 取值范围    字节型 byte（0） Byte 1 字节 -128~127   短整型 short（0） Short 2 字节 -32768~32767   整型 int（0） Integer 4 字节">
<meta property="og:locale">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-06-04T07:41:00.144Z">
<meta property="article:modified_time" content="2022-07-07T15:34:15.655Z">
<meta property="article:author" content="一只草履虫">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JavaSE">
<meta property="article:tag" content="JavaWeb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="https://cdn.staticaly.com/gh/unravelyt/image-hosting/master/base_img/logo_y.webp"><link rel="canonical" href="http://example.com/2022/06/04/18.JavaSE&amp;JavaWeb%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="abf5c74cfad8dfe6b241e6c53d2c8670"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?53242c018d62786ff7244610783daec5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":700},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Java】JavaSE & JavaWeb查漏补缺',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-07 23:34:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom-css/head.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.staticaly.com/gh/unravelyt/image-hosting@master/2022/09/a1.agxptimguo4.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Unravely</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Java】JavaSE &amp; JavaWeb查漏补缺</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-06-04T07:41:00.144Z" title="Created 2022-06-04 15:41:00">2022-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-07-07T15:34:15.655Z" title="Updated 2022-07-07 23:34:15">2022-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2-%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/">2.代码相关</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">35.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>132min</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、JavaSE"><a href="#一、JavaSE" class="headerlink" title="一、JavaSE"></a>一、JavaSE</h1><h2 id="1-基本数据类型范围"><a href="#1-基本数据类型范围" class="headerlink" title="1. 基本数据类型范围"></a>1. 基本数据类型范围</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字（默认值）</th>
<th>包装类</th>
<th>占用内存</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td>byte（0）</td>
<td>Byte</td>
<td>1 字节</td>
<td>-128~127</td>
</tr>
<tr>
<td>短整型</td>
<td>short（0）</td>
<td>Short</td>
<td>2 字节</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>整型</td>
<td>int（0）</td>
<td>Integer</td>
<td>4 字节</td>
<td>-2147483648~2147483647（21亿4千万）</td>
</tr>
<tr>
<td>长整型</td>
<td>long（0L）</td>
<td>Long</td>
<td>8 字节</td>
<td>-9223372036854775808L~9223372036854775807L</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float（0.0f）</td>
<td>Float</td>
<td>4 字节</td>
<td>+&#x2F;-3.4E+38F（6~7 个有效位）</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double（0.0d）</td>
<td>Double</td>
<td>8 字节</td>
<td>+&#x2F;-1.8E+308 (15 个有效位）</td>
</tr>
<tr>
<td>字符型</td>
<td>char（’u0000’）</td>
<td>Character</td>
<td>2 字节</td>
<td>ISO 单一字符集</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean（ false）</td>
<td>Boolean</td>
<td>1 字节</td>
<td>true 或 false</td>
</tr>
</tbody></table>
<h2 id="2-修饰符"><a href="#2-修饰符" class="headerlink" title="2. 修饰符"></a>2. 修饰符</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>protected</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>default</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>private</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<ul>
<li><strong>public</strong>： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不<br>　　　　　仅可以跨类访问，而且允许跨包（package）访问。</li>
<li><strong>protected</strong>: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、<br> 　　　　属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</li>
<li><strong>default</strong>：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访<br> 　　　　问。</li>
<li><strong>private</strong>: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以<br>　　　　　及方法只能被该类的对象访问，其[子类]不能访问，更不能允许跨包访问。</li>
</ul>
<h2 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3. 转义字符"></a>3. 转义字符</h2><p>Java语言支持一些特殊的转义字符序列。</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">字符含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行 (0x0a)</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车 (0x0d)</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符(0x0c)</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格 (0x08)</td>
</tr>
<tr>
<td align="left">\0</td>
<td align="left">空字符 (0x0)</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">空格 (0x20)</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">双引号</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">单引号</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">反斜杠</td>
</tr>
<tr>
<td align="left">\ddd</td>
<td align="left">八进制字符 (ddd)</td>
</tr>
<tr>
<td align="left">\uxxxx</td>
<td align="left">16进制Unicode字符 (xxxx)</td>
</tr>
</tbody></table>
<h2 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4. 代码块"></a>4. 代码块</h2><blockquote>
<ol>
<li><p>就是被一对{}所括起来的代码</p>
</li>
<li><p>根据代码块定义的位置不同分为:局部代码块,构造代码块,静态代码块**</p>
</li>
</ol>
</blockquote>
<ol>
<li><strong>局部代码块：</strong></li>
</ol>
<ul>
<li><p>在方法中出现；限定变量生命周期，及早释放，提高内存利用率</p>
</li>
<li><p>在同一个类中的同一个方法中，如果存在多个局部代码块，执行顺序是自上而下的。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//局部代码块       </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在方法中出现</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;局部代码块&quot;</span>);</span><br><span class="line">        System.out.println(num);        <span class="comment">//输出200</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println(num);  //出了代码块的范围,就不能再使用了!所以会报错!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<ol start="2">
<li><strong>构造代码块 (初始化块)：</strong></li>
</ol>
<ul>
<li>在类中方法外出现；多个构造方法方法中相同的代码存放到一起，<strong>每创建一次对象就会执行一次，优先于构造函数执行</strong>。每次调用构造都执行，并且在构造方法前执行</li>
<li>无论类中有多少个构造代码块，构造代码块之间会先进行自上而下的顺序执行，然后再执行构造方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">        <span class="comment">//构造代码块，可以为该类的所有对象的成员变量赋值。</span></span><br><span class="line">        num = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;       <span class="comment">//进程入口</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>静态代码块：</strong></li>
</ol>
<ul>
<li>在<strong>类中方法外</strong>出现，并加上static修饰；用于给类进行初始化，<strong>随着类加载而加载</strong>，一般用来给类进行初始化，在加载的时候就执行，并且<strong>只执行一次</strong>。</li>
<li>一般用于加载驱动，优先于主方法执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;       <span class="comment">//进程入口</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-继承-amp-实现"><a href="#5-继承-amp-实现" class="headerlink" title="5. 继承&amp;实现"></a>5. 继承&amp;实现</h2><ul>
<li><p>【继承】Java只支持单继承，不支持多继承。(一个儿子只能有一个爹)；</p>
</li>
<li><p>【继承】Java支持多层继承（爹的上面可以有爷爷）；</p>
</li>
<li><p>【实现】Java支持多实现（implement）；</p>
</li>
<li><p>【继承】子类只能继承父类所有非私有的成员（成员方法和成员变量）；</p>
</li>
<li><p>【继承】子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法；</p>
</li>
<li><p>【继承】抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。</p>
</li>
<li><p>【实现】接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。</p>
</li>
<li><p>【继承】子类中所有的构造方法默认都会访问父类中空参数的构造方法，子类会继承父类中的数据，可能还会使用父类的数据。所以子类初始化之前，一定要先完成父类数据的初始化。</p>
</li>
<li><p>【继承】每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//默认继承object类。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Father的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();        <span class="comment">//这是一条隐藏语句，用来访问父类中的空参构造。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son的构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>【继承】父类没有无参构造方法,子类怎么办？super(…)或者this(….)必须出现在构造方法的第一条语句上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super(&quot;李四&quot;,24);//调父类</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>);<span class="comment">//调本类，不能同时写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Son的空参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age);</span><br><span class="line">        System.out.println(<span class="string">&quot;Son的有参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-重写和重载"><a href="#6-重写和重载" class="headerlink" title="6. 重写和重载"></a>6. 重写和重载</h2><ul>
<li>方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的。</li>
<li>方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。</li>
</ul>
<h2 id="7-final关键字"><a href="#7-final关键字" class="headerlink" title="7. final关键字"></a>7. final关键字</h2><ul>
<li>修饰类，类不能被继承</li>
<li>修饰变量，变量就变成了常量（量命名规范_所有字母大写），只能被赋值一次</li>
<li>修饰方法，方法不能被重写</li>
<li>修饰局部变量<ul>
<li>基本类型，是值不能被改变</li>
<li>引用类型，是地址值不能被改变,对象中的属性可以改变</li>
</ul>
</li>
</ul>
<h2 id="8-抽象类"><a href="#8-抽象类" class="headerlink" title="8. 抽象类"></a>8. 抽象类</h2><p><strong>1. 特点</strong></p>
<ul>
<li><p>抽象类和抽象方法必须用abstract关键字修饰</p>
<ul>
<li>abstract class 类名 {}</li>
<li>public abstract void eat();</li>
</ul>
</li>
<li><p>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口</p>
</li>
<li><p>抽象类不能实例化那么，抽象类如何实例化呢?</p>
<ul>
<li>按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。</li>
</ul>
</li>
<li><p>抽象类的子类，要么是抽象类，要么重写抽象类中的所有抽象方法</p>
</li>
<li><p>抽象类的成员特点</p>
<ul>
<li>成员变量：既可以是变量，也可以是常量;abstract不能修饰成员变量。</li>
<li>构造方法：用于子类访问父类数据的初始化。</li>
<li>成员方法：既可以是抽象的，也可以是非抽象的。</li>
</ul>
</li>
<li><p>抽象类的成员方法特性：</p>
<ul>
<li>抽象方法 强制要求子类做的事情。</li>
<li>非抽象方法 子类继承的事情，提高代码复用性。</li>
</ul>
</li>
<li><p>abstract不能和哪些关键字共存</p>
<ul>
<li><p>abstract和static</p>
<ul>
<li>被abstract修饰的方法没有方法体</li>
<li>被static修饰的可以用类名.调用，但是类名.调用抽象方法是没有意义的</li>
</ul>
</li>
<li><p>abstract和final</p>
<ul>
<li>被abstract修饰的方法强制子类重写</li>
<li>被final修饰的不让子类重写，所以他俩是矛盾的</li>
</ul>
</li>
<li><p>abstract和private</p>
<ul>
<li><p>被abstract修饰是为了让子类看到并强制重写</p>
</li>
<li><p>被private修饰不让子类访问，所以他俩是矛盾的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. 抽象类和普通类的区别和一些特性</strong></p>
<ul>
<li>抽象类不可以直接实例化，只可以用来继承</li>
<li>子类继承抽象类后，必须实现父类的所有抽象方法， 如果抽象类的派生子类没有实现其中的所有抽象方法，那么该派生子类仍然是抽象类， 只能用于继承，而不能实例化；</li>
<li>一个类里面定义了抽象方法，那么该类必须定义为抽象类，但是一个抽象类里面可以有抽象方法，也可以没有</li>
<li>构造方法和静态方法不可以修饰为abstract!!!（注意:static和abstract绝对不是互斥的,虽然两者不能同时修饰某个方法,但他们可以同时修饰内部类）</li>
<li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li>
</ul>
<p>​     </p>
<h2 id="9-接口特点"><a href="#9-接口特点" class="headerlink" title="9. 接口特点"></a>9. 接口特点</h2><ul>
<li><p>接口用关键字interface表示：interface 接口名 {}</p>
</li>
<li><p>类实现接口用implements表示：class 类名 implements 接口名 {}</p>
</li>
<li><p>接口不能实例化，按照多态的方式来实例化。</p>
</li>
<li><p>接口的子类</p>
<ul>
<li><p>可以是抽象类。但是意义不大。</p>
</li>
<li><p>可以是具体类。要重写接口中的所有抽象方法。(推荐方案)</p>
</li>
</ul>
</li>
<li><p>接口成员特点</p>
<ul>
<li>成员变量；只能是常量，并且是静态的并公共的。默认修饰符：public static final</li>
<li>构造方法：接口没有构造方法。</li>
<li>成员方法：默认修饰符：public abstract，只能是抽象方法。<strong>在jdk8中，还可以有静态方法和default方法。并且静态方法与default方法可以有方法体</strong></li>
</ul>
</li>
</ul>
<h2 id="10-接口和抽象类的区别"><a href="#10-接口和抽象类的区别" class="headerlink" title="10. 接口和抽象类的区别"></a>10. 接口和抽象类的区别</h2><p><strong>抽象类:</strong></p>
<ul>
<li><p>抽象类不可以实例化，<strong>只能够用来继承</strong>；</p>
</li>
<li><p>包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</p>
</li>
<li><p>抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；</p>
</li>
<li><p>一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p>
</li>
<li><p>抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用；</p>
</li>
<li><p>抽象类中可以包含非抽象的方法；</p>
</li>
<li><p>抽象类的引用可指向子类的实例；</p>
<p><strong>接口：</strong></p>
</li>
<li><p>接口用interface关键修饰。接口中所有的方法为抽象方法 ,<strong>注明：</strong>jdk8之后提供了默认方法和静态方法（且这两种方法可以存在方法体）</p>
</li>
<li><p>接口可以包含变量、方法；变量被隐式指定为public static final，方法被隐式指定为public abstract（JDK1.8之前）；</p>
</li>
<li><p>接口中的变量都为常量</p>
</li>
<li><p>接口不能实例化，只被实现,还能被接口继承</p>
</li>
<li><p>接口的实现类必须全部实现接口中的方法，如果不实现，可以将子类变成一个抽象类</p>
</li>
<li><p>接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p>
</li>
<li><p>一个类可以实现多个接口；</p>
</li>
<li><p>接口的引用指向实现类的实例</p>
</li>
<li><p>JDK1.8中对接口增加了新的特性：</p>
<ul>
<li>（1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；</li>
<li>（2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</li>
</ul>
</li>
</ul>
<p>C:设计理念区别</p>
<ul>
<li>抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。</li>
<li>接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。</li>
</ul>
<p><strong>文字描述</strong></p>
<blockquote>
<p>1.接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。</p>
<p>2.类可以实现很多个接口，但是只能继承一个抽象类。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现， 否则该类仍然需要被声明为抽象类。</p>
<p>2.抽象类可以在不提供接口方法实现的情况下实现接口。Java 接口中声明的变量默认都是final的。抽象类可以包含非final的变量。Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。</p>
<p>3.接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main方法的话是可以被调用的。(抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用)接口可以继承接口。抽象类可以实现(implements)接口<strong>，抽象类可继承具体类，但前提是具体类必须有明确的构造函数</strong>。<strong>有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</strong> </p>
<p>4.接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p>
</blockquote>
<h2 id="11-x3D-x3D-号和equals方法的区别"><a href="#11-x3D-x3D-号和equals方法的区别" class="headerlink" title="11. &#x3D;&#x3D;号和equals方法的区别"></a>11. &#x3D;&#x3D;号和equals方法的区别</h2><ul>
<li>&#x3D;&#x3D;是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,<ul>
<li>基本数据类型比较的是值</li>
<li>引用数据类型比较的是地址值</li>
</ul>
</li>
<li>equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,equals方法和&#x3D;&#x3D;号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性，String重写的equal方法</li>
</ul>
<h2 id="12-Integer类-128到127陷阱"><a href="#12-Integer类-128到127陷阱" class="headerlink" title="12. Integer类-128到127陷阱"></a>12. Integer类-128到127陷阱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">127</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">127</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">1000</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">1000</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> d1= <span class="number">127</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(a1 == a2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(b1 == b2); <span class="comment">//false</span></span><br><span class="line">    System.out.println(c1 == c2); <span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(d1 == d2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(e1 == e2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(f1 == f2); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当数据为基本类型int的时候，运行的结果都是true，而如果是封装类型Integer的时候，数据为127的时候使true，128和1000都为false </p>
</li>
<li><p>首先我们要理解&#x3D;&#x3D;比较的是什么，它比较的是栈中数据是否相同，我们都知道，<strong>基本类型的数据的变量名和值都存在栈中</strong>（作为类的属性的情况除外），因此，所有int类型的数据运行都会为true。</p>
</li>
<li><p>Integer是引用类型，会把它的值存在堆中，栈中存储的是变量名及堆中数据的地址</p>
</li>
<li><p>自动拆箱与自动装箱：</p>
<p>Integer a &#x3D; 1；其实代表的是Integer a &#x3D; new Integer(1)；我们不需要去进行初始化，这个方法会自己初始化在堆中开辟一片区域存储数据。</p>
<p>自动拆箱也类似int b &#x3D; a；代表的是int b &#x3D; Integer.valueOf(a);同样不需要我们主动调用方法。</p>
</li>
<li><p>出现false，<strong>因为每次初始化都会开辟新的区域，虽然两块区域可能储存的值相同，但是它们是堆中两块不同的区域，栈中存储的地址不同，因此比较会出现false。</strong></p>
</li>
<li><p>Integer 的值为-128<del>127 的时候就会认为是true是因为Java对-128</del>127在常量池中进行了缓存（Java规定在-128~127之间的Integer类型的变量，直接指向常量池中的缓存地址，不会new开辟出新的空间。 ）</p>
</li>
</ul>
<h2 id="13-Java正则表达式"><a href="#13-Java正则表达式" class="headerlink" title="13. Java正则表达式"></a>13. Java正则表达式</h2><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， <strong><code>n</code><strong>匹配字符 <strong><code>n</code><strong>。</strong><code>\n</code></strong> 匹配换行符。序列 <strong><code>\\\\</code></strong> 匹配 <strong><code>\\</code></strong> ，</strong><code>\\(</code></strong> 匹配 **<code>(</code>**。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td align="left">{<em>n</em>}</td>
<td align="left"><em>n</em> 是非负整数。正好匹配 <em>n</em> 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td align="left">{<em>n</em>,}</td>
<td align="left"><em>n</em> 是非负整数。至少匹配 <em>n</em> 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td align="left">{<em>n</em>,<em>m</em>}</td>
<td align="left"><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;&#x3D; <em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em> 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">当此字符紧随任何其他限定符（*、+、?、{<em>n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td align="left">(<em>pattern</em>)</td>
<td align="left">匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用 <strong>$0…$9</strong> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td>
</tr>
<tr>
<td align="left">(?:<em>pattern</em>)</td>
<td align="left">匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td>
</tr>
<tr>
<td align="left">(?&#x3D;<em>pattern</em>)</td>
<td align="left">执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td align="left">(?!<em>pattern</em>)</td>
<td align="left">执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td align="left"><em>x</em>|<em>y</em></td>
<td align="left">匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</td>
</tr>
<tr>
<td align="left">[<em>xyz</em>]</td>
<td align="left">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td align="left">[^<em>xyz</em>]</td>
<td align="left">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td align="left">[<em>a-z</em>]</td>
<td align="left">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td align="left">[^<em>a-z</em>]</td>
<td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td>
</tr>
<tr>
<td align="left">\c<em>x</em></td>
<td align="left">匹配 <em>x</em> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">数字字符匹配。等效于 [0-9]。</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">非数字字符匹配。等效于 [^0-9]。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="left">\x<em>n</em></td>
<td align="left">匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td align="left">\num</td>
<td align="left">匹配 <em>num</em>，此处的 <em>num</em> 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">标识一个八进制转义码或反向引用。如果 *n* 前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td>
</tr>
<tr>
<td align="left"><strong><code>\nm</code></strong></td>
<td align="left">标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 *nm* 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 <em>nm</em>，其中 <em>n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td align="left">\nml</td>
<td align="left">当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td>
</tr>
<tr>
<td align="left">\u<em>n</em></td>
<td align="left">匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody></table>
<p><strong>Pattern和Matcher的使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*b&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aaaaab&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> m.matches();</span><br></pre></td></tr></table></figure>

<h2 id="14-Math类-x2F-Random类-x2F-BigInteger类-x2F-BigDecimal类"><a href="#14-Math类-x2F-Random类-x2F-BigInteger类-x2F-BigDecimal类" class="headerlink" title="14. Math类&#x2F;Random类&#x2F;BigInteger类&#x2F;BigDecimal类"></a>14. Math类&#x2F;Random类&#x2F;BigInteger类&#x2F;BigDecimal类</h2><p><strong>（1）Math类方法使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Math.PI);</span><br><span class="line">    System.out.println(Math.abs(-<span class="number">10</span>));    <span class="comment">//取绝对值</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.ceil(<span class="number">12.01</span>));<span class="comment">//获取向上取整，但是结果是一个double值</span></span><br><span class="line">    System.out.println(Math.ceil(<span class="number">12.99</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.floor(<span class="number">12.01</span>));<span class="comment">//获取向下取整，但是结果也是一个double值</span></span><br><span class="line">    System.out.println(Math.floor(<span class="number">12.99</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.max(<span class="number">20</span>,    <span class="number">30</span>));<span class="comment">//取最大值</span></span><br><span class="line">    System.out.println(Math.min(<span class="number">20</span>,    <span class="number">30</span>));<span class="comment">//取最小值</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//2.0的3次方</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.random());<span class="comment">//生成0.0到1.0之间的所有小数，包括0.0，不包括1.0</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.round(<span class="number">12.3f</span>));<span class="comment">//四舍五入</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.sqrt(<span class="number">2</span>));<span class="comment">//开平方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）Random类方法使用</strong></p>
<ul>
<li>Random类的概述<ul>
<li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，</li>
<li>则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。</li>
</ul>
</li>
<li>构造方法<ul>
<li>public Random()</li>
<li>public Random(long seed)</li>
</ul>
</li>
<li>成员方法<ul>
<li>public int nextInt()</li>
<li>public int nextInt(int n) 生产0 到n的随机数，不包括n；</li>
</ul>
</li>
</ul>
<p><strong>（3）BigInteger类方法使用</strong></p>
<ul>
<li>BigInteger的概述<ul>
<li>可以让超过Integer范围内的数据进行运算</li>
</ul>
</li>
<li>构造方法<ul>
<li>public BigInteger(String val)</li>
</ul>
</li>
<li>成员方法<ul>
<li>public BigInteger add(BigInteger val)  &#x2F;&#x2F;加</li>
<li>public BigInteger subtract(BigInteger val) &#x2F;&#x2F;减</li>
<li>public BigInteger multiply(BigInteger val) &#x2F;&#x2F;乘</li>
<li>public BigInteger divide(BigInteger val) &#x2F;&#x2F;除</li>
<li>public BigInteger[] divideAndRemainder(BigInteger val) &#x2F;&#x2F;返回一个包含divideToIntegralValue的结果，随后其余与上根据上下文设置进行舍入计算两个操作数的结果，结果由两个元素组成的BigDecimal数组。</li>
</ul>
</li>
</ul>
<p><strong>（4）BigDecimal类方法使用</strong></p>
<ul>
<li>A:BigDecimal的概述<ul>
<li>由于在运算的时候，float类型和double很容易丢失精度，演示案例。</li>
<li>所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal</li>
<li>不可变的、任意精度的有符号十进制数。</li>
</ul>
</li>
<li>B:构造方法<ul>
<li>public BigDecimal(String val)</li>
</ul>
</li>
<li>C:成员方法<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor)</li>
</ul>
</li>
</ul>
<h2 id="15-日期类的使用"><a href="#15-日期类的使用" class="headerlink" title="15.日期类的使用"></a>15.日期类的使用</h2><p>（1）date类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将时间字符串转换成日期对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2000年08月08日 08:08:08&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;y年M月d日 HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(str);                <span class="comment">//将时间字符串转换成日期对象 Ctrl+1抛出异常</span></span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将日期对象转换为字符串</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="comment">//获取当前时间对象</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;y年M月d日 HH:mm:ss&quot;</span>);   <span class="comment">//创建日期格式化类对象</span></span><br><span class="line">System.out.println(sdf.format(d));  </span><br></pre></td></tr></table></figure>

<h2 id="16-集合体系"><a href="#16-集合体系" class="headerlink" title="16. 集合体系"></a>16. 集合体系</h2><p><img src="https://img-blog.csdnimg.cn/20200313224345849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2MTg0MDc1,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b70273fa0e4b2630fbace443cce584cb.png" alt="集合体系"></p>
<h2 id="17-CopyOnWriteArrayList如何做到线程安全的"><a href="#17-CopyOnWriteArrayList如何做到线程安全的" class="headerlink" title="17. CopyOnWriteArrayList如何做到线程安全的"></a>17. CopyOnWriteArrayList如何做到线程安全的</h2><p><strong>CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。</strong></p>
<p>CopyOnWriteArrayList的整个add操作都是在<strong>锁</strong>的保护下进行的。 </p>
<p>这样做是为了避免在多线程并发add的时候，<strong>复制出多个副本出来</strong>,把数据搞乱了，导致最终的数组数据不是我们期望的。</p>
<p>由于所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况： </p>
<p>1、如果写操作未完成，那么直接读取原数组的数据； </p>
<p>2、如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据； </p>
<p>3、如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。</p>
<p>可见，CopyOnWriteArrayList的<strong>读操作</strong>是可以不用<strong>加锁</strong>的。</p>
<ul>
<li>CopyOnWriteArrayList的使用场景</li>
</ul>
<p>通过上面的分析，CopyOnWriteArrayList 有几个缺点： </p>
<p>1、由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc</p>
<p>2、不能用于<strong>实时读</strong>的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到<strong>最终一致性</strong>,但是还是没法满足实时性要求；</p>
<p>CopyOnWriteArrayList 合适<strong>读多写少</strong>的场景，不过这类慎用 </p>
<p>因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add&#x2F;set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</p>
<p><strong>CopyOnWriteArrayList透露的思想</strong></p>
<p>如上面的分析CopyOnWriteArrayList表达的一些思想： </p>
<p>1、读写分离，读和写分开 </p>
<p>2、最终一致性 </p>
<p>3、使用另外开辟空间的思路，来解决并发冲突</p>
<p><strong>Collections.synchronizedList</strong></p>
<p>CopyOnWriteArrayList和Collections.synchronizedList是实现线程安全的列表的两种方式。</p>
<p>两种实现方式分别针对不同情况有不同的性能表现，其中CopyOnWriteArrayList的写操作性能较差，而多线程的读操作性能较好。</p>
<p>而Collections.synchronizedList的写操作性能比CopyOnWriteArrayList在多线程操作的情况下要好很多，而读操作因为是采用了synchronized关键字的方式，其读操作性能并不如CopyOnWriteArrayList。因此在不同的应用场景下，应该选择不同的多线程安全实现类。</p>
<p><strong>总结：写操作多用Collections.synchronizedList，读操作多用CopyOnWriteArrayList</strong></p>
<h2 id="18-集合的线程安全性"><a href="#18-集合的线程安全性" class="headerlink" title="18. 集合的线程安全性"></a>18. 集合的线程安全性</h2><p><strong>线程安全的集合：</strong></p>
<ul>
<li><p>ConcurrentHashMap</p>
</li>
<li><p>Collections.synchronizedList</p>
</li>
<li><p>CopyOnWriteArrayList</p>
</li>
<li><p>CopyOnWriteArraySet</p>
</li>
</ul>
<p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到。</p>
<p><strong>（1）概念</strong></p>
<ul>
<li><strong>线程安全：</strong>就是当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染的情况。</li>
<li><strong>线程不安全：</strong>就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染的情况。</li>
<li><strong>对于线程不安全的问题</strong>，一般会使用synchronized关键字加锁同步控制。</li>
<li><strong>线程安全 工作原理：</strong> jvm中有一个main memory对象，每一个线程也有自己的working memory，一个线程对于一个变量variable进行操作的时候， 都需要在自己的working memory里创建一个copy,操作完之后再写入main memory。<br>当多个线程操作同一个变量variable，就可能出现不可预知的结果。<br>而用synchronized的关键是建立一个监控monitor，这个monitor可以是要修改的变量，也可以是其他自己认为合适的对象(方法)，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完加载load到working memory 到 use &amp;&amp; 指派assign 到 存储store 再到 main memory的过程。才会释放它得到的锁。这样就实现了所谓的线程安全。</li>
</ul>
<p><strong>（2）线程的安全控制有三个级别</strong></p>
<p> • JVM 级别。大多数现代处理器对并发对 某一硬件级别提供支持，通常以 compare-and-swap （CAS）指令形式。CAS 是一种低级别的、细粒度的技术，它允许多个线程更新一个内存位置，同时能够检测其他线程的冲突并进行恢复。它是许多高性能并发算法的基础。在 JDK 5.0 之前，Java 语言中用于协调线程之间的访问的惟一原语是同步，同步是更重量级和粗粒度的。公开 CAS 可以开发高度可伸缩的并发 Java 类。</p>
<p> • 低级实用程序类 – 锁定和原子类。使用 CAS 作为并发原语，ReentrantLock 类提供与 synchronized 原语相同的锁定和内存语义，然而这样可以更好地控制锁定（如计时的锁定等待、锁定轮询和可中断的锁定等待）和提供更好的可伸缩性（竞争时的高性能）。大多数开发人员将不再直接使用 ReentrantLock 类，而是使用在 ReentrantLock 类上构建的高级类。</p>
<p> • 高级实用程序类。这些类实现并发构建块，每个计算机科学课本中都会讲述这些类 – 信号、互斥、闩锁、屏障、交换程序、线程池和线程安全集合类等。大部分开发人员都可以在应用程序中用这些类，来替换许多同步、 wait() 和 notify() 的使用，从而提高性能、可读性和正确性。</p>
<p><strong>（3）常见的线程安全操作列举几个</strong></p>
<ul>
<li><p>加锁同步synchronizedLock等</p>
</li>
<li><p>wait() notify()线程调度 已实现执行的同步</p>
</li>
<li><p>ThreadLocal局部变量  每一个线程都有一份数据</p>
</li>
<li><p>Semaphore 信号量</p>
</li>
<li><p>volatile 保证一个变量的线程安全</p>
</li>
</ul>
<p><strong>（4）相关集合对象比较</strong></p>
<ul>
<li><strong>Vector、ArrayList、LinkedList：</strong><br><strong>1、Vector：</strong><br>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<br><strong>2、ArrayList：</strong><br>a. 当操作是在一列数据的后面添加数据而不是在前面或者中间，并需要随机地访问其中的元素时，使用ArrayList性能比较好。<br>b. ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br><strong>3、LinkedList：</strong><br>a. 当对一列数据的前面或者中间执行添加或者删除操作时，并且按照顺序访问其中的元素时，要使用LinkedList。<br>b. LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li>
</ul>
<p>　　 Vector和ArrayList在使用上非常相似，都可以用来表示一组数量可变的对象应用的集合，并且可以随机的访问其中的元素。</p>
<ul>
<li><p><strong>HashTable、HashMap、HashSet：</strong><br>HashTable和HashMap采用的存储机制是一样的，不同的是：<br><strong>1、HashMap：</strong><br>a. 采用数组方式存储key-value构成的Entry对象，无容量限制；<br>b. 基于key hash查找Entry对象存放到数组的位置，对于hash冲突采用链表的方式去解决；<br>c. 在插入元素时，可能会扩大数组的容量，在扩大容量时须要重新计算hash，并复制对象到新的数组中；<br>d. 是非线程安全的；<br>e. 遍历使用的是Iterator迭代器；</p>
<p><strong>2、HashTable：</strong><br>a. 是线程安全的；<br>b. 无论是key还是value都不允许有null值的存在；在HashTable中调用Put方法时，如果key为null，直接抛出NullPointerException异常；<br>c. 遍历使用的是Enumeration列举；</p>
<p><strong>3、HashSet：</strong><br>a. 基于HashMap实现，无容量限制；<br>b. 是非线程安全的；<br>c. 不保证数据的有序；</p>
</li>
<li><p><strong>TreeSet、TreeMap：</strong><br>TreeSet和TreeMap都是完全基于Map来实现的，并且都不支持get(index)来获取指定位置的元素，需要遍历来获取。另外，TreeSet还提供了一些排序方面的支持，例如传入Comparator实现、descendingSet以及descendingIterator等。<br><strong>1、TreeSet：</strong><br>a. 基于TreeMap实现的，支持排序；<br>b. 是非线程安全的；</p>
<p><strong>2、TreeMap：</strong><br>a. 典型的基于红黑树的Map实现，因此它要求一定要有key比较的方法，要么传入Comparator比较器实现，要么key对象实现Comparator接口；<br>b. 是非线程安全的；</p>
</li>
<li><p><strong>StringBuffer和StringBulider：</strong><br>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串。</p>
</li>
</ul>
<p>　　 1、在执行速度方面的比较：StringBuilder &gt; StringBuffer ；<br>　　 2、他们都是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度快；<br>　 　3、 StringBuilder：线程非安全的；<br>　　 4、StringBuffer：线程安全的； 
　 </p>
<ul>
<li><strong>对于String、StringBuffer和StringBulider三者使用的总结：</strong><br>　　 1.如果要操作少量的数据用 &#x3D; String<br>2.单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder<br>3.多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</li>
</ul>
<h2 id="19-泛型"><a href="#19-泛型" class="headerlink" title="19. 泛型"></a>19. 泛型</h2><p><strong>1. 泛型的本质</strong></p>
<p>本质是参数化类型：ArrayList<String> strings &#x3D; new ArrayList&lt;&gt;();</p>
<p><strong>（1）保证了类型的安全性</strong></p>
<p>在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。</p>
<p><strong>（2） 消除强制转换</strong></p>
<p>泛型的一个附带好处是，消除源代码中的许多强制类型转换，不确定的类型转换为确定的类型，这使得代码更加可读，并且减少了出错机会。</p>
<p><strong>（3）避免了不必要的装箱、拆箱操作，提高程序的性能</strong></p>
<p>在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。</p>
<p>泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。</p>
<p><strong>（4）提高了代码的重用性。</strong></p>
<p><strong>2. 泛型的使用</strong></p>
<p>泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。</p>
<p><strong>常见泛型参数名称有如下：</strong></p>
<p>E：Element (在集合中使用，因为集合中存放的是元素)<br>T：Type（Java 类）<br>K：Key（键）<br>V：Value（值）<br>N：Number（数值类型）<br>？：表示不确定的java类型</p>
<p>（1）泛型类：把泛型定义在类上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &lt;泛型类型<span class="number">1</span>,...&gt; &#123;  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">泛型参数类型规范：</span><br><span class="line"><span class="number">1.</span> T：任意类型 type</span><br><span class="line"><span class="number">2.</span> E：集合中元素的类型 element</span><br><span class="line"><span class="number">3.</span> K：key-value形式 key</span><br><span class="line"><span class="number">4.</span> V：key-value形式 value</span><br></pre></td></tr></table></figure>



<p>（2）泛型接口：把泛型定义在接口上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericsInteface</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（3）泛型方法：把泛型定义在方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 传入泛型的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *   1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *   2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *   3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genercMethod</span><span class="params">(T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(t.getClass());</span><br><span class="line"></span><br><span class="line">    System.out.println(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 泛型通配符</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1：表示类型参数可以是任何类型 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;?&gt;&#123;&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2：表示类型参数必须是A或者是A的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T <span class="keyword">extends</span> <span class="title class_">A</span>&gt;&#123;&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3: 表示类型参数必须是A或者是A的超类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T supers A&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-不能在循环集合的时候删除元素"><a href="#20-不能在循环集合的时候删除元素" class="headerlink" title="20. 不能在循环集合的时候删除元素"></a>20. 不能在循环集合的时候删除元素</h2><ul>
<li>普通for循环,可以删除,但是索引要–</li>
<li>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</li>
<li>增强for循环不能删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通for循环删除,索引要--</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; list.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">            if(&quot;b&quot;.equals(list.get(i))) &#123;</span></span><br><span class="line"><span class="comment">                list.remove(i--);                    //通过索引删除元素</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="comment">//迭代器删除</span></span><br><span class="line">    <span class="comment">/*Iterator&lt;String&gt; it = list.iterator();</span></span><br><span class="line"><span class="comment">        while(it.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">            if(&quot;b&quot;.equals(it.next())) &#123;</span></span><br><span class="line"><span class="comment">//                list.remove(&quot;b&quot;);        //不能用集合的删除方法，会报并发修改异常</span></span><br><span class="line"><span class="comment">                it.remove();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*for(Iterator&lt;String&gt; it2 = list.iterator(); it2.hasNext();) &#123;</span></span><br><span class="line"><span class="comment">            if(&quot;b&quot;.equals(it2.next())) &#123;</span></span><br><span class="line"><span class="comment">                it2.remove();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增强for循环,不能删除，只能遍历</span></span><br><span class="line">    <span class="keyword">for</span> (String String : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;b&quot;</span>.equals(String)) &#123;</span><br><span class="line">            list.remove(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-TreeSet-保证元素唯一和自然排序的原理"><a href="#21-TreeSet-保证元素唯一和自然排序的原理" class="headerlink" title="21. TreeSet 保证元素唯一和自然排序的原理"></a>21. TreeSet 保证元素唯一和自然排序的原理</h2><ul>
<li><p>二叉树——小的存储在左边（负数），大的存储在右边（正数），相等就不存（返回0）。</p>
</li>
<li><p>compareTo方法，在TreeSet集合中如何存储元素取决于CopareTo方法的返回值</p>
</li>
<li><p>1.返回0，集合中只有一个元素。通过比较不存储。</p>
</li>
<li><p>2.返回-1，存储在根元素左边。集合倒序</p>
</li>
<li><p>3.返回+1，集合怎么存就怎么取</p>
</li>
<li><p>1.特点</p>
<ul>
<li>TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列</li>
</ul>
</li>
<li><p>2.使用方式</p>
<ul>
<li>a.自然顺序(Comparable)<ul>
<li>TreeSet类的add()方法中会把存入的对象提升为Comparable类型</li>
<li>调用对象的compareTo()方法和集合中的对象比较</li>
<li>根据compareTo()方法返回的结果进行存储</li>
</ul>
</li>
<li>b.比较器顺序(Comparator)<ul>
<li>创建TreeSet的时候可以制定 一个Comparator</li>
<li>如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序</li>
<li>add()方法内部会自动调用Comparator接口中compare()方法排序</li>
<li>调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数</li>
</ul>
</li>
<li>c.两种方式的区别<ul>
<li>TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException)</li>
<li>TreeSet如果传入Comparator, 就优先按照Comparator进行排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="21-Comparable-amp-Comparator的区别"><a href="#21-Comparable-amp-Comparator的区别" class="headerlink" title="21. Comparable &amp; Comparator的区别"></a>21. Comparable &amp; Comparator的区别</h2><p><strong>（1）对比</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>Comparable</th>
<th>Comparator</th>
</tr>
</thead>
<tbody><tr>
<td>排序逻辑</td>
<td>排序逻辑必须在待排序对象的类中</td>
<td>排序逻辑在另一个实现</td>
</tr>
<tr>
<td>实现</td>
<td>实现Comparable接口</td>
<td>实现Comparator接口</td>
</tr>
<tr>
<td>排序方法</td>
<td><code>int compareTo(Object o1)</code></td>
<td><code>int compare(Object o1,Object o2)</code></td>
</tr>
<tr>
<td>触发排序</td>
<td>Collections.sort(List)</td>
<td>Collections.sort(List, Comparator)</td>
</tr>
<tr>
<td>所在包</td>
<td>java.lang.Comparable</td>
<td>java.util.Comparator</td>
</tr>
</tbody></table>
<p><strong>（2）Comparable</strong></p>
<p>自然排序Comparable可以认为是一种内部比较器，一般情况下在类定义时实现Comparable接口，重写compareTo方法实现排序，返回值为int类型共有三种情况：</p>
<ul>
<li>当前对象大于传入对象，返回正整数。</li>
<li>当前对象小于传入对象，返回负整数。</li>
<li>当前对象等于传入对象，返回0。</li>
</ul>
<blockquote>
<p>若当前对象x &#x3D; 3，传入对象y &#x3D; 5，返回值为 -1，认为x &lt; y。排列结果由小到大，即为 3,5，实现了升序排列<br>若当前对象x &#x3D; 5，传入对象y &#x3D; 3，返回值为1，认为x &gt; y。排列结果由小到大，即为5,3，实现了降序排列</p>
<p><strong>当返回正数的时候就会调换位置</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;<span class="built_in">this</span>.age = age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student s)</span>&#123;</span><br><span class="line">        <span class="comment">//按照年龄大小排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;<span class="comment">//升序</span></span><br><span class="line">		<span class="comment">//int num = s.age - this.age;//降序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//年龄一样时，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span>num== <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name):num;</span><br><span class="line">        <span class="keyword">return</span> num2;<span class="comment">//当返回正数的时候就会调换位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）Comparator</strong></p>
<p>比较器排序Comparator一般采用内部类的方式实现，需要重写<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=compare&spm=1001.2101.3001.7020">compare</a>方法实现排序。返回值为int类型共有三种情况：</p>
<ul>
<li>o1 &gt; o2，返回正整数。</li>
<li>o1 &lt; o2，返回负整数。</li>
<li>o1 &#x3D; o2，返回0。</li>
</ul>
<blockquote>
<p>若o1中x &#x3D; 3，o2中y &#x3D; 5，返回值为 -1，认为x &lt; y。排列结果由小到大，即为 3,5，实现了升序排列<br>若o1中x &#x3D; 3，o2中y &#x3D; 5，返回值为1，认为x &gt; y。排列结果由小到大，即为5,3，实现了降序排列</p>
<p><strong>当返回正数的时候就会调换位置</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部类实现Comparator接口重写compare方法，实现按年龄升序排列</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">StudentCom</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();<span class="comment">//当返回正数的时候就会调换位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部类实现Comparator接口重写compare方法，实现按年龄降序排列</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">StudentComDesc</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1 <span class="number">14</span>, Student o2 <span class="number">12</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> o2.getAge() - o1.getAge();<span class="comment">//当返回正数的时候就会调换位置</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="22-finally与return的执行顺序"><a href="#22-finally与return的执行顺序" class="headerlink" title="22. finally与return的执行顺序"></a>22. finally与return的执行顺序</h2><ul>
<li>当 try 代码块和 catch 代码块中有 return 语句时，finally 仍然会被执行；</li>
<li>执行 try 代码块或 catch 代码块中的 return 语句之前，都会先执行 finally 语句；</li>
<li>finally代码块中的return语句会覆盖try或catch中的return， finally中最好不要出现return；</li>
<li>finally中没有return语句的情况下，对变量进行修改：return语句中是基本数据类型，则finally中对变量进行操作不会改变其值；return语句中是引用数据类型，finally中则会修改里面的数据；</li>
</ul>
<h2 id="23-IO流"><a href="#23-IO流" class="headerlink" title="23. IO流"></a>23. IO流</h2><p><strong>（1）io流分类</strong></p>
<p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/io%E6%B5%812.3qbz6pgl7g40.webp" alt="IO流体系"></p>
<p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/io%E6%B5%81.1hjqsymudpfk.webp"></p>
<p><strong>（2）io流简单使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;视频.avi&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.avi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(arr)) != -<span class="number">1</span>) &#123;        <span class="comment">//忘记写arr，返回的是码表值</span></span><br><span class="line">        fos.write(arr,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）InputStream.available()获取流大小问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;https://t7.baidu.com/it/u=2168645659,3174029352&amp;fm=193&amp;f=GIF&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(path).openConnection();</span><br><span class="line">    <span class="comment">//此连接的URL引用的资源的内容长度，如果内容长度未知，或者内容长度大于Integer.MAX_VALUE，则为-1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">contentLength</span> <span class="operator">=</span> urlConnection.getContentLength();</span><br><span class="line">    System.out.println(contentLength); </span><br><span class="line"></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">    <span class="comment">//inputStream.available()可以在没有阻塞的情况下从此输入流中读取（或跳过）的字节数的估计值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;in.available()=&quot;</span>+inputStream.available()); <span class="comment">//in.available()=15865</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">    System.out.println(<span class="string">&quot;toByteArray数组大小=&quot;</span>+bytes.length);<span class="comment">//toByteArray数组大小=169243</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先开后关，先开的输入流，再开的输出流，通过读取输入流写入输出流中，那么应该先关输出流，再关输入流</span></span><br><span class="line">    <span class="comment">//先关外层，再关内层</span></span><br><span class="line">    inputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的InputStream.available()是从网络中获取数据，由于存在着网络延迟等因素，所以会造成<code>.available()</code>的大小和实际的大小不一致，应该用urlConnection.getContentLength();获取，或者将其转换为字节流byteArrayInputStream然后在获取.available()；</p>
<p><strong>（4）IO流的关闭</strong></p>
<ul>
<li>使用装饰流时，只需要关闭最后面的装饰流即可，装饰流是指通过装饰模式实现的java流，又称为包装流，装饰流关闭时会调用原生流关闭；</li>
<li>先开后关，先开的输入流，再开的输出流，通过读取输入流写入输出流中，那么应该先关输出流，再关输入流；</li>
<li>内存流可以不用关闭，ByteArrayOutputStream和ByteArrayInputStream其实是伪装成流的字节数组（把它们当成字节数据来看就好了），他们不会锁定任何文件句柄和端口，如果不再被使用，字节数组会被垃圾回收掉，所以不需要关闭；</li>
<li>try (OutputStream out &#x3D; new FileOutputStream(“”)) { <em>&#x2F;&#x2F; …操作流代码</em> } catch (Exception e) { e.printStackTrace(); }</li>
</ul>
<h2 id="24-Java异或"><a href="#24-Java异或" class="headerlink" title="24. Java异或"></a>24. Java异或</h2><blockquote>
<p>异或是一种基于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>的位运算，用符号XOR或者^表示，其运算法则是对运算符两侧数的每一个二进制位同值则取0，异值则取1.<br>简单理解就是不进位加法，如1+1&#x3D;0，0+0&#x3D;0，1+0&#x3D;1.<br>For example: 3^5 &#x3D; 6<br>转成二进制后就是 0011 ^ 0101 二号位和三号位都是异值取1 末尾两个1同值取零，所以3^5 &#x3D; 0110 &#x3D; 6</p>
</blockquote>
<p><strong>应用举例</strong></p>
<p>1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现<br>一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空<br>间，能否设计一个算法实现？<br>解法一、显然已经有人提出了一个比较精彩的解法，将所有数加起来，减去1+2+…+1000的和。<br>这个算法已经足够完美了，相信出题者的标准答案也就是这个算法，唯一的问题是，如果数列过大，则可能会导致溢出。<br>解法二、异或就没有这个问题，并且性能更好。<br>将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。<br>但是这个算法虽然很简单，但证明起来并不是一件容易的事情。这与异或运算的几个特性有关系。<br>首先是异或运算满足交换律、结合律。<br>所以，1^2^…^n^…^n^…^1000，无论这两个n出现在什么位置，都可以转换成为1^2^…^1000^(n^n)的形式。<br>其次，对于任何数x，都有x^x&#x3D;0，x^0&#x3D;x。<br>所以1^2^…^n^…^n^…^1000 &#x3D; 1^2^…^1000^(n^n)&#x3D; 1^2^…^1000^0 &#x3D; 1^2^…^1000（即序列中除了n的所有数的异或）。<br>令，1^2^…^1000（序列中不包含n）的结果为T<br>则1^2^…^1000（序列中包含n）的结果就是T^n。<br>T^(T^n)&#x3D;n。<br>所以，将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。<br>当然有人会说，1+2+…+1000的结果有高斯定律可以快速计算，但实际上1^2^…^1000的结果也是有规律的，算法比高斯定律还该简单的多。</p>
<p>google面试题的变形：一个数组存放若干整数，一个数出现奇数次，其余数均出现偶数次，找出这个出现奇数次的数？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">22</span>, <span class="number">38</span>,<span class="number">38</span>, <span class="number">22</span>,<span class="number">22</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">11</span> &#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">temp ^= a[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法有很多，但是最好的和上面一样，就是把所有数异或，最后结果就是要找的，原理同上！！</p>
<p><strong>其他用途示例</strong></p>
<p>这样可以实现不引人第三个变量实现交换，但是进行的计算相对第三个变量多，所以效率会低一些。<br>关于其他的方法还有：int a&#x3D;5,b&#x3D;10;<br>a&#x3D;a+b; &#x2F;&#x2F;a&#x3D;15,b&#x3D;10<br>b&#x3D;a-b; &#x2F;&#x2F;a&#x3D;15,b&#x3D;5<br>a&#x3D;a-b; &#x2F;&#x2F;a&#x3D;10,b&#x3D;5<br>但是这样做有一个缺陷，假设它运行在vc6环境中，那么int的大小是4 Bytes，所以int变量所存放的最大值是2^31-1即2147483647，如果我们令a的值为2147483000，b的值为1000000000，那么a和b相加就越界了。<br>事实上，从实际的运行统计上看，我们发现要交换的两个变量，是同号的概率很大，而且，他们之间相减，越界的情况也很少，因此我们可以把上面的加减法互换，这样使得程序出错的概率减少：<br>int a&#x3D;5,b&#x3D;10;<br>a -&#x3D; b; &#x2F;&#x2F;a&#x3D;-5,b&#x3D;10<br>b +&#x3D; a; &#x2F;&#x2F;b&#x3D;5,a&#x3D;-5<br>a &#x3D; b - a; &#x2F;&#x2F;a&#x3D;10,b&#x3D;5<br>通过以上运算，a和b中的值就进行了交换。表面上看起来很简单，但是不容易想到，尤其是在习惯引入第三变量的算法之后。<br>它的原理是：把a、b看做数轴上的点，围绕两点间的距离来进行计算。<br>具体过程：第一句“a-&#x3D;b”求出ab两点的距离，并且将其保存在a中；第二句“b+&#x3D;a”求出a到原点的距离（b到原点的距离与ab两点距离之差），并且将其保存在b中；第三句“a+&#x3D;b”求出b到原点的距离（a到原点距离与ab两点距离之和），并且将其保存在a中。完成交换。</p>
<h2 id="25-Properties类简介"><a href="#25-Properties类简介" class="headerlink" title="25. Properties类简介"></a>25. Properties类简介</h2><p>Properties类继承自Hashtable，key-value格式可以当map来使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>． getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>． load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>． setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>． store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>． clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</span><br></pre></td></tr></table></figure>

<h2 id="26-反射"><a href="#26-反射" class="headerlink" title="26. 反射"></a>26. 反射</h2><h3 id="1-获取Class对象的三种方式"><a href="#1-获取Class对象的三种方式" class="headerlink" title="1. 获取Class对象的三种方式"></a>1. 获取Class对象的三种方式</h3><blockquote>
<p><strong>在运行期间，一个类，只有一个Class对象产生。</strong> </p>
<p>三种方式常用第三种，第一种对象都有了还要反射干什么;</p>
<p>第二种需要导入类的包，依赖太强，不导包就抛编译错误;</p>
<p>一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p>
</blockquote>
<p>（1）Object ——&gt; getClass(); </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">//new 产生一个Student对象，一个Class对象。</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> stu1.getClass(); <span class="comment">//获取Class对象</span></span><br><span class="line">System.out.println(stuClass.getName());</span><br></pre></td></tr></table></figure>

<p>（2）任何数据类型（包括基本数据类型）都有一个“静态”的class属性 ；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式获取Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stuClass2</span> <span class="operator">=</span> Student.class;</span><br><span class="line"><span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line">System.out.println(stuClass == stuClass2);</span><br></pre></td></tr></table></figure>

<p>（3） 通过Class类的静态方法：forName（String  className）(常用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stuClass3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line"><span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">System.out.println(stuClass3 == stuClass2);</span><br></pre></td></tr></table></figure>

<h3 id="2-通过反射获取构造方法并使用"><a href="#2-通过反射获取构造方法并使用" class="headerlink" title="2. 通过反射获取构造方法并使用"></a>2. 通过反射获取构造方法并使用</h3><p>学生类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//---------------构造方法-------------------</span></span><br><span class="line">	<span class="comment">//（默认的构造方法）</span></span><br><span class="line">	Student(String str)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;(默认)的构造方法 s = &quot;</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了公有、无参构造方法执行了。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//有一个参数的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">char</span> name)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//有多个参数的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;年龄：&quot;</span>+ age);<span class="comment">//这的执行效率有问题，以后解决。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//受保护的构造方法</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">Student</span><span class="params">(<span class="type">boolean</span> n)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;受保护的构造方法 n = &quot;</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//私有构造方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;私有的构造方法   年龄：&quot;</span>+ age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取构造方法：</strong></p>
<p>（1）批量的方法：</p>
<ul>
<li>public Constructor[] getConstructors()：所有”公有的”构造方法</li>
<li>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</li>
</ul>
<p>（2）获取单个的方法：</p>
<ul>
<li><p>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：</p>
</li>
<li><p>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</p>
</li>
</ul>
<p>（3）调用构造方法：</p>
<ul>
<li><strong>Constructor–&gt;newInstance(Object… initargs)</strong></li>
</ul>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructors</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.加载Class对象</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.获取所有公有构造方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;*****所有公有构造方法*****&quot;</span>);</span><br><span class="line">		Constructor[] conArray = clazz.getConstructors();</span><br><span class="line">		<span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;*****所有的构造方法(包括：私有、受保护、默认、公有)*****&quot;</span>);</span><br><span class="line">		conArray = clazz.getDeclaredConstructors();</span><br><span class="line">		<span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;*****获取公有、无参的构造方法*****&quot;</span>);</span><br><span class="line">		<span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getConstructor(<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span></span><br><span class="line">		<span class="comment">//2&gt;、返回的是描述这个无参构造函数的类对象。</span></span><br><span class="line">	</span><br><span class="line">		System.out.println(<span class="string">&quot;con = &quot;</span> + con);</span><br><span class="line">		<span class="comment">//调用构造方法</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">	<span class="comment">//	System.out.println(&quot;obj = &quot; + obj);</span></span><br><span class="line">	<span class="comment">//	Student stu = (Student)obj;</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;*****获取私有构造方法，并调用*****&quot;</span>);</span><br><span class="line">		con = clazz.getDeclaredConstructor(<span class="type">char</span>.class);</span><br><span class="line">		System.out.println(con);</span><br><span class="line">		<span class="comment">//调用构造方法</span></span><br><span class="line">		con.setAccessible(<span class="literal">true</span>);<span class="comment">//暴力访问(忽略掉访问修饰符)</span></span><br><span class="line">		obj = con.newInstance(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制台输出：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">********所有公有构造方法********</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(java.lang.String,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student()</span><br><span class="line">******所有的构造方法(包括：私有、受保护、默认、公有)******</span><br><span class="line"><span class="keyword">private</span> fanshe.Student(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">protected</span> fanshe.Student(<span class="type">boolean</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(java.lang.String,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student()</span><br><span class="line">fanshe.Student(java.lang.String)</span><br><span class="line">*******获取公有、无参的构造方法******</span><br><span class="line">con = <span class="keyword">public</span> fanshe.Student()</span><br><span class="line">调用了公有、无参构造方法执行了。。。</span><br><span class="line">******获取私有构造方法，并调用******</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line">姓名：男</span><br></pre></td></tr></table></figure>

<h3 id="3-获取成员变量并调用"><a href="#3-获取成员变量并调用" class="headerlink" title="3. 获取成员变量并调用"></a>3. 获取成员变量并调用</h3><p>student类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//**********字段*************//</span></span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">	<span class="keyword">private</span> String phoneNum;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, sex=&quot;</span> + sex</span><br><span class="line">				+ <span class="string">&quot;, phoneNum=&quot;</span> + phoneNum + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取成员变量并调用：</strong></p>
<p>1.批量的</p>
<ul>
<li>Field[] getFields():获取所有的”公有字段”</li>
<li>Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；<br>2.获取单个的：</li>
<li>1).public Field getField(String fieldName):获取某个”公有的”字段；</li>
<li>2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</li>
</ul>
<p><strong>设置字段的值：</strong></p>
<ul>
<li>Field –&gt; public void set(Object obj,Object value):<br>参数说明：</li>
<li>1.obj:要设置的字段所在的对象；</li>
<li>2.value:要为字段设置的值；</li>
</ul>
<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fields</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.field.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取字段</span></span><br><span class="line">        System.out.println(<span class="string">&quot;*****获取所有公有的字段*****&quot;</span>);</span><br><span class="line">        Field[] fieldArray = stuClass.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****获取所有的字段(包括私有、受保护、默认的)*****&quot;</span>);</span><br><span class="line">        fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****获取公有字段**并调用*****&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">//获取一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> stuClass.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">//产生Student对象--》Student stu = new Student();</span></span><br><span class="line">        <span class="comment">//为字段设置值</span></span><br><span class="line">        f.set(obj, <span class="string">&quot;刘德华&quot;</span>);<span class="comment">//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span></span><br><span class="line">        <span class="comment">//验证</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)obj;</span><br><span class="line">        System.out.println(<span class="string">&quot;验证姓名：&quot;</span> + stu.name);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****获取私有字段****并调用*****&quot;</span>);</span><br><span class="line">        f = stuClass.getDeclaredField(<span class="string">&quot;phoneNum&quot;</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);<span class="comment">//暴力反射，解除私有限定</span></span><br><span class="line">        f.set(obj, <span class="string">&quot;18888889999&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;验证电话：&quot;</span> + stu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制台输出：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">************获取所有公有的字段*********</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line">************获取所有的字段(包括私有、受保护、默认的)********</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> fanshe.field.Student.age</span><br><span class="line"><span class="type">char</span> fanshe.field.Student.sex</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">*************获取公有字段**并调用***************</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line">验证姓名：刘德华</span><br><span class="line">**************获取私有字段****并调用*************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">验证电话：Student [name=刘德华, age=<span class="number">0</span>, sex=</span><br></pre></td></tr></table></figure>

<h3 id="4-获取成员方法并调用"><a href="#4-获取成员方法并调用" class="headerlink" title="4. 获取成员方法并调用"></a>4. 获取成员方法并调用</h3><p><strong>student类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="comment">//**************成员方法***************//</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(String s)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：公有的，String参数的show1(): s = &quot;</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：受保护的，无参的show2()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show3</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：默认的，无参的show3()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">show4</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot;</span> + age);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取成员方法并调用：</strong></p>
<p>1.获取批量的：</p>
<ul>
<li>public Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类）</li>
<li>public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</li>
</ul>
<p>2.获取单个的：</p>
<ul>
<li><p>public Method getMethod(String name,Class&lt;?&gt;… parameterTypes):</p>
</li>
<li><p>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)</p>
<p>​			参数：name : 方法名；</p>
<p>​						Class … : 形参的Class类型对象</p>
</li>
</ul>
<p><strong>调用方法：</strong></p>
<ul>
<li><p><strong>Method –&gt; public Object invoke(Object obj,Object… args):</strong></p>
<p>​	参数说明：obj : 要调用方法的对象；</p>
<p>​						args:调用方式时所传递的实参；</p>
</li>
</ul>
<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodClass</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.获取Class对象</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.method.Student&quot;</span>);</span><br><span class="line">		<span class="comment">//2.获取所有公有方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;**********获取所有的”公有“方法************&quot;</span>);</span><br><span class="line">		stuClass.getMethods();</span><br><span class="line">		Method[] methodArray = stuClass.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;*********获取所有的方法，包括私有的*********&quot;</span>);</span><br><span class="line">		methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;*********获取公有的show1()方法*************&quot;</span>);</span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(<span class="string">&quot;show1&quot;</span>, String.class);</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		<span class="comment">//实例化一个Student对象</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> stuClass.getConstructor().newInstance();</span><br><span class="line">		m.invoke(obj, <span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;***********获取私有的show4()方法********&quot;</span>);</span><br><span class="line">		m = stuClass.getDeclaredMethod(<span class="string">&quot;show4&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">		System.out.println(m);</span><br><span class="line">        <span class="comment">//解除私有限定</span></span><br><span class="line">		m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> m.invoke(obj, <span class="number">20</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;返回值：&quot;</span> + result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制台输出：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***************获取所有的”公有“方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">    </span><br><span class="line">***************获取所有的方法，包括私有的*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> fanshe.method.Student.show2()</span><br><span class="line"><span class="keyword">void</span> fanshe.method.Student.show3()</span><br><span class="line">    </span><br><span class="line">***************获取公有的show1()方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">调用了：公有的，String参数的show1(): s = 刘德华</span><br><span class="line">    </span><br><span class="line">***************获取私有的show4()方法******************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="type">int</span>)</span><br><span class="line">调用了，私有的，并且有返回值的，<span class="type">int</span>参数的show4(): age = <span class="number">20</span></span><br><span class="line">返回值：abcd</span><br></pre></td></tr></table></figure>

<h3 id="5-反射main方法"><a href="#5-反射main方法" class="headerlink" title="5. 反射main方法"></a>5. 反射main方法</h3><p>student类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法执行了。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Student类的main方法、不要与当前的main方法搞混了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1、获取Student对象的字节码</span></span><br><span class="line">			<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.main.Student&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//2、获取main方法</span></span><br><span class="line">			 <span class="type">Method</span> <span class="variable">methodMain</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);<span class="comment">//第一个参数：方法名称，第二个参数：方法形参的类型，</span></span><br><span class="line">			<span class="comment">//3、调用main方法</span></span><br><span class="line">			<span class="comment">// methodMain.invoke(null, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);</span></span><br><span class="line">			 <span class="comment">//第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数</span></span><br><span class="line">			 <span class="comment">//这里拆的时候将  new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。</span></span><br><span class="line">			 methodMain.invoke(<span class="literal">null</span>, (Object)<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;);<span class="comment">//方式一</span></span><br><span class="line">			<span class="comment">// methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);//方式二</span></span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-通过反射运行配置文件内容"><a href="#6-通过反射运行配置文件内容" class="headerlink" title="6. 通过反射运行配置文件内容"></a>6. 通过反射运行配置文件内容</h3><p>student类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;is show()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件以txt文件为例子（pro.txt）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = cn.fanshe.<span class="type">Student</span></span><br><span class="line"><span class="variable">methodName</span> <span class="operator">=</span> show</span><br></pre></td></tr></table></figure>


<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</span></span><br><span class="line"><span class="comment"> * 我们只需要将新类发送给客户端，并修改配置文件即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//通过反射获取Class对象</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(getValue(<span class="string">&quot;className&quot;</span>));<span class="comment">//&quot;cn.fanshe.Student&quot;</span></span><br><span class="line">		<span class="comment">//2获取show()方法</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(getValue(<span class="string">&quot;methodName&quot;</span>));<span class="comment">//show</span></span><br><span class="line">		<span class="comment">//3.调用show()方法</span></span><br><span class="line">		m.invoke(stuClass.getConstructor().newInstance());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此方法接收一个key，在配置文件中获取相应的value</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//获取配置文件的对象</span></span><br><span class="line">		<span class="type">FileReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;pro.txt&quot;</span>);<span class="comment">//获取输入流</span></span><br><span class="line">		pro.load(in);<span class="comment">//将流加载到配置文件对象中</span></span><br><span class="line">		in.close();</span><br><span class="line">		<span class="keyword">return</span> pro.getProperty(key);<span class="comment">//返回根据key获取的value值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台输出：</span><br><span class="line">is <span class="title function_">show</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<h3 id="7-通过反射越过泛型检查"><a href="#7-通过反射越过泛型检查" class="headerlink" title="7. 通过反射越过泛型检查"></a>7. 通过反射越过泛型检查</h3><blockquote>
<p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的</p>
</blockquote>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过反射越过泛型检查</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		strList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//strList.add(100);</span></span><br><span class="line">		<span class="comment">//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">listClass</span> <span class="operator">=</span> strList.getClass(); <span class="comment">//得到 strList 对象的字节码 对象</span></span><br><span class="line">		<span class="comment">//获取add()方法</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">		<span class="comment">//调用add()方法</span></span><br><span class="line">		m.invoke(strList, <span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历集合</span></span><br><span class="line">		<span class="keyword">for</span>(Object obj : strList)&#123;</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="27-动态代理"><a href="#27-动态代理" class="headerlink" title="27. 动态代理"></a>27. 动态代理</h2><blockquote>
<p>Java中两种常见的动态代理方式：JDK原生动态代理和CGLIB动态代理</p>
<p>动态代理在Java中有着广泛的应用，比如Spring AOP、Hibernate数据查询、测试框架的后端mock、RPC远程调用、Java注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。</p>
</blockquote>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p><strong>代理模式</strong>：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式</p>
<p>代理模式角色分为 3 种：</p>
<ul>
<li><strong>Subject（抽象主题角色）</strong>：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</li>
<li><strong>RealSubject（真实主题角色</strong>）：真正实现业务逻辑的类；</li>
<li><strong>Proxy（代理主题角色）</strong>：用来代理和封装真实主题；</li>
</ul>
<p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p>
<ul>
<li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li>
<li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li>
</ul>
<h3 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 通过静态代理对 UserServiceImpl 进行功能增强，在调用select和update之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 客户端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代理的缺点:</p>
<ul>
<li><p>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p>
<ul>
<li><p>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></p>
</li>
<li><p>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></p>
</li>
</ul>
</li>
<li><p>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护。</strong></p>
</li>
</ul>
<h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h3><p><strong>1. 概念</strong></p>
<p>使用场景：</p>
<ul>
<li>设计模式中有一个设计原则是开闭原则，是说对修改关闭对扩展开放，我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑(sometimes the code is really like shit)，这时就很难去下手修改代码，那么这时我们就可以通过代理对类进行<strong>增强</strong>。</li>
<li>我们在使用RPC框架的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。</li>
<li>Spring的AOP机制就是采用动态代理的机制来实现切面编程。统计每个 api 的请求耗时，统一的日志输出，校验被调用的 api 是否已经登录和权限鉴定。</li>
</ul>
<p><strong>动态代理就是类可以动态的生成</strong>，这就涉及到Java虚拟机的<strong>类加载机制</strong>了</p>
<p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li>
</ol>
<p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，<strong>获取类的二进制字节流</strong>（class字节码）就有很多途径：</p>
<ul>
<li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li>
<li>从网络中获取，典型的应用是 Applet</li>
<li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li>
<li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li>
<li>从数据库中获取等等</li>
</ul>
<p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。</p>
<p><strong>常见的有2中实现方式：</strong></p>
<ol>
<li>通过实现接口的方式 -&gt; JDK动态代理</li>
<li>通过继承类的方式 -&gt; CGLIB动态代理</li>
</ol>
<p><strong>2. JDK动态代理</strong></p>
<p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 <code>invoke</code> 方法中编写方法调用的逻辑处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//增强</span></span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        <span class="comment">//增强</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法，具体步骤可见代码和注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> proxy.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">	<span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">	<span class="comment">//System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span></span><br><span class="line">	<span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">	<span class="type">UserServiceImpl</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">	<span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">	<span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userServiceImpl.getClass().getClassLoader();</span><br><span class="line">	<span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">	Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">	<span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">	<span class="comment">//这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">	<span class="type">InvocationHandler</span> <span class="variable">logHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	<span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">	<span class="comment">// 调用代理的方法</span></span><br><span class="line">	proxy.select();</span><br><span class="line">	proxy.update();</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">	<span class="comment">// ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure>

<p>InvocationHandler 和 Proxy 的主要方法介绍如下：</p>
<p><strong>java.lang.reflect.InvocationHandler</strong></p>
<ul>
<li><code>Object invoke(Object proxy, Method method, Object[] args)</code>定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</li>
</ul>
<p><strong>java.lang.reflect.Proxy</strong></p>
<ul>
<li><p><code>static InvocationHandler getInvocationHandler(Object proxy)</code>用于获取指定代理对象所关联的调用处理器</p>
</li>
<li><p><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code>返回指定接口的代理类</p>
</li>
<li><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p>
</li>
<li><p><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code>返回 cl 是否为一个代理类</p>
</li>
</ul>
<p><strong>代理类的调用过程</strong></p>
<p>借助下面的工具类，把代理类保存下来再探个究竟（通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles&#x3D;true也可以保存代理类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下</span></span><br><span class="line"><span class="comment">     * params: clazz 需要生成动态代理类的类</span></span><br><span class="line"><span class="comment">     * proxyName: 为动态生成的代理类的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generateClassFile</span><span class="params">(Class clazz, String proxyName)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据类信息和提供的代理类名称，生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class="line">        <span class="type">String</span> <span class="variable">paths</span> <span class="operator">=</span> clazz.getResource(<span class="string">&quot;.&quot;</span>).getPath();</span><br><span class="line">        System.out.println(paths);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//保留到硬盘中</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(paths + proxyName + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在 Client2 测试类的main的最后面加入一行代码</span></span><br><span class="line"><span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">ProxyUtils.generateClassFile(userServiceImpl.getClass(), <span class="string">&quot;UserServiceProxy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>UserServiceProxy 的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m4, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;proxy.UserService&quot;</span>).getMethod(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;proxy.UserService&quot;</span>).getMethod(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从 UserServiceProxy 的代码中我们可以发现：</p>
<ul>
<li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li>
<li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li>
<li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li>
<li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li>
<li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li>
</ul>
<p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p>
<p>JDK动态代理执行方法调用的过程简图如下：<img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/jdkProxy.6iqan4drkj80.jpg"></p>
<p><strong>3. CGLIB动态代理</strong></p>
<p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao 查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao 更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(object, objects);   <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LogInterceptor</span> <span class="variable">logInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogInterceptor</span>();</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);  <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallback(logInterceptor);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao)enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        dao.update();</span><br><span class="line">        dao.select();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure>



<p>还可以进一步对多个 MethodInterceptor 进行过滤筛选</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor2</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log2 start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log2 end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFilter</span> <span class="keyword">implements</span> <span class="title class_">CallbackFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">accept</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;select&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// Callback 列表第1个拦截器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// Callback 列表第2个拦截器，return 2 则为第3个，以此类推</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LogInterceptor</span> <span class="variable">logInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogInterceptor</span>();</span><br><span class="line">        <span class="type">LogInterceptor2</span> <span class="variable">logInterceptor2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogInterceptor2</span>();</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);   <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;logInterceptor, logInterceptor2, NoOp.INSTANCE&#125;);   </span><br><span class="line">        <span class="comment">// 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">DaoFilter</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserDao) enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">log2 start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log2 end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure>

<p><strong>4. CGlib 对接口实现代理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。</span></span><br><span class="line"><span class="comment"> * 该类中完成三样工作：</span></span><br><span class="line"><span class="comment"> * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象</span></span><br><span class="line"><span class="comment"> * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类</span></span><br><span class="line"><span class="comment"> * （3）定义回调接口方法。对目标类的增强这在这里完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 声明目标类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CGLibFactory</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义代理的生成方法,用于创建代理对象</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">myCGLibCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 为代理对象设置父类，即指定目标类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this，</span></span><br><span class="line"><span class="comment">         * 是因为MethodIntecepter接口继承自Callback，是其子接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();<span class="comment">// create用以生成CGLib代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start invoke &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;end invoke &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-JDK动态代理与CGLIB动态代理对比"><a href="#4-JDK动态代理与CGLIB动态代理对比" class="headerlink" title="4. JDK动态代理与CGLIB动态代理对比"></a>4. <strong>JDK动态代理与CGLIB动态代理对比</strong></h3><p>JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p>
<p>cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。</p>
<p><strong>JDK Proxy 的优势：</strong></p>
<ul>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li>
<li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li>
<li>代码实现简单。</li>
</ul>
<p><strong>基于类似 cglib 框架的优势：</strong></p>
<ul>
<li>无需实现接口，达到代理类无侵入</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
<li>高性能</li>
</ul>
<p><strong>描述动态代理的几种实现方式？分别说出相应的优缺点</strong></p>
<p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。<br><strong>静态代理</strong>：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p>
<ul>
<li><strong>优点</strong>：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li>
<li><strong>缺点</strong>：不同的接口要有不同的代理类实现，会很冗余</li>
</ul>
<p><strong>JDK 动态代理</strong>：</p>
<p>为了解决静态代理中，生成大量的代理类造成的冗余；JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象 jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口。</p>
<p><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</p>
<p><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</p>
<p><strong>CGLIB 代理</strong>：</p>
<p>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。 同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。</p>
<p><strong>优点</strong>：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</p>
<p><strong>缺点</strong>：技术实现相对难理解些。</p>
<h3 id="5-其他文章"><a href="#5-其他文章" class="headerlink" title="5. 其他文章"></a>5. 其他文章</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bryan31/p/15266725.html">动态代理大揭秘，带你彻底弄清楚动态代理！ - 铂赛东 - 博客园 (cnblogs.com)</a></p>
<h2 id="28-MyBatis中-和-的区别"><a href="#28-MyBatis中-和-的区别" class="headerlink" title="28. MyBatis中${} 和 #{} 的区别"></a>28. MyBatis中${} 和 #{} 的区别</h2><ul>
<li><p><code>#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符串替换。</p>
</li>
<li><p>MyBatis在处理<code>#&#123;&#125;</code>时，会将SQL中的<code>#&#123;&#125;</code>替换为?号，使用PreparedStatement的set方法来赋值；MyBatis在处理 <code>$&#123;&#125;</code> 时，就是把 <code>$&#123;&#125;</code> 替换成变量的值。</p>
</li>
<li><p>使用 <code>#&#123;&#125;</code> 可以有效的防止SQL注入，提高系统安全性。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，使用#&#123;&#125;语法，MyBatis会产生PreparedStatement语句，并且安全地设置PreparedStatement参数，这个过程中MyBatis会进行必要的安全检查和转义。例如：</span><br><span class="line">    </span><br><span class="line">    执行SQL：select * from emp where name = #&#123;employeeName&#125;</span><br><span class="line">    参数：employeeName=&gt;Smith</span><br><span class="line">    解析后执行的SQL：select * from emp where name = ？</span><br><span class="line"> </span><br><span class="line">    执行SQL：Select * from emp where name = $&#123;employeeName&#125;</span><br><span class="line">    参数：employeeName传入值为：Smith</span><br><span class="line">    解析后执行的SQL：Select * from emp where name =Smith</span><br><span class="line"> </span><br><span class="line">综上所述，$&#123;&#125;方式可能会引发SQL注入的问题，同时也会影响SQL语句的预编译，所以从安全性和性能的角度出发，应尽量使用#&#123;&#125;。当需要直接插入一个不做任何修改的字符串到SQL语句中，例如在ORDER BY后接一个不添加引号的值作为列名，这时候就需要使用$&#123;&#125;,比如表名。</span><br></pre></td></tr></table></figure>



<h2 id="29-Redis相关"><a href="#29-Redis相关" class="headerlink" title="29. Redis相关"></a>29. Redis相关</h2><h3 id="（1）Redis的5种数据结构"><a href="#（1）Redis的5种数据结构" class="headerlink" title="（1）Redis的5种数据结构"></a>（1）Redis的5种数据结构</h3><p>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p>
<ul>
<li>字符串类型 string</li>
<li>哈希类型 hash ： map格式  </li>
<li>列表类型 list ： linkedlist格式。支持重复元素</li>
<li>集合类型 set  ： 不允许重复元素</li>
<li>有序集合类型 sortedset：不允许重复元素，且元素有顺序</li>
</ul>
<h3 id="（2）Redis操作命令"><a href="#（2）Redis操作命令" class="headerlink" title="（2）Redis操作命令"></a>（2）Redis操作命令</h3><p><strong>1. 通用命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. keys * : 查询所有的键</span><br><span class="line"></span><br><span class="line">2. type key ： 获取键对应的value的类型</span><br><span class="line"></span><br><span class="line">3. del key：删除指定的key value</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p><strong>字符串类型 string</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 存储： set key value</span><br><span class="line">	127.0.0.1:6379&gt; set username zhangsan</span><br><span class="line">	OK</span><br><span class="line">2. 获取： get key</span><br><span class="line">	127.0.0.1:6379&gt; get username</span><br><span class="line">	&quot;zhangsan&quot;</span><br><span class="line">3. 删除： del key</span><br><span class="line">	127.0.0.1:6379&gt; del age</span><br><span class="line">	(integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>哈希类型 hash</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 存储： hset key field value</span><br><span class="line">	127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">	(integer) 1</span><br><span class="line">	127.0.0.1:6379&gt; hset myhash password 123</span><br><span class="line">	(integer) 1</span><br><span class="line">2. 获取： </span><br><span class="line">	* hget key field: 获取指定的field对应的值</span><br><span class="line">		127.0.0.1:6379&gt; hget myhash username</span><br><span class="line">		&quot;lisi&quot;</span><br><span class="line">	* hgetall key：获取所有的field和value</span><br><span class="line">		127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">		1) &quot;username&quot;</span><br><span class="line">		2) &quot;lisi&quot;</span><br><span class="line">		3) &quot;password&quot;</span><br><span class="line">		4) &quot;123&quot;</span><br><span class="line">		</span><br><span class="line">3. 删除： hdel key field</span><br><span class="line">	127.0.0.1:6379&gt; hdel myhash username</span><br><span class="line">	(integer) 1</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 添加：</span><br><span class="line">	1. lpush key value: 将元素加入列表左表</span><br><span class="line">		</span><br><span class="line">	2. rpush key value：将元素加入列表右边</span><br><span class="line">		</span><br><span class="line">		127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">		(integer) 1</span><br><span class="line">		127.0.0.1:6379&gt; lpush myList b</span><br><span class="line">		(integer) 2</span><br><span class="line">		127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">		(integer) 3</span><br><span class="line">2. 获取：</span><br><span class="line">	* lrange key start end ：范围获取</span><br><span class="line">		127.0.0.1:6379&gt; lrange myList 0 -1</span><br><span class="line">		1) &quot;b&quot;</span><br><span class="line">		2) &quot;a&quot;</span><br><span class="line">		3) &quot;c&quot;</span><br><span class="line">3. 删除：</span><br><span class="line">	* lpop key： 删除列表最左边的元素，并将元素返回</span><br><span class="line">	* rpop key： 删除列表最右边的元素，并将元素返回</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>集合类型 set ： 不允许重复元素</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 存储：sadd key value</span><br><span class="line">	127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">	(integer) 1</span><br><span class="line">	127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">	(integer) 0</span><br><span class="line">2. 获取：smembers key:获取set集合中所有元素</span><br><span class="line">	127.0.0.1:6379&gt; smembers myset</span><br><span class="line">	1) &quot;a&quot;</span><br><span class="line">3. 删除：srem key value:删除set集合中的某个元素	</span><br><span class="line">	127.0.0.1:6379&gt; srem myset a</span><br><span class="line">	(integer) 1</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 存储：zadd key score value</span><br><span class="line">	127.0.0.1:6379&gt; zadd mysort 60 zhangsan</span><br><span class="line">	(integer) 1</span><br><span class="line">	127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">	(integer) 1</span><br><span class="line">	127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">	(integer) 1</span><br><span class="line">2. 获取：zrange key start end [withscores]</span><br><span class="line">	127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line">	1) &quot;lisi&quot;</span><br><span class="line">	2) &quot;zhangsan&quot;</span><br><span class="line">	3) &quot;wangwu&quot;</span><br><span class="line"></span><br><span class="line">	127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</span><br><span class="line">	1) &quot;zhangsan&quot;</span><br><span class="line">	2) &quot;60&quot;</span><br><span class="line">	3) &quot;wangwu&quot;</span><br><span class="line">	4) &quot;80&quot;</span><br><span class="line">	5) &quot;lisi&quot;</span><br><span class="line">	6) &quot;500&quot;</span><br><span class="line">3. 删除：zrem key value</span><br><span class="line">	127.0.0.1:6379&gt; zrem mysort lisi</span><br><span class="line">	(integer) 1</span><br></pre></td></tr></table></figure>



<h2 id="30-网络编程"><a href="#30-网络编程" class="headerlink" title="30. 网络编程"></a>30. 网络编程</h2><p>在展开介绍TCP&#x2F;IP协议之前，首先介绍一下七层ISO模型。国际标准化组织ISO为了使网络应用更为普及，推出了OSI参考模型，即开放式系统互联（Open<br>System Interconnect）模型，<br>一般都叫OSI参考模型。OSI参考模型是ISO组织在1985年发布的网络互连模型，其含义就是为所有公司使用一个统一的规范来控制网络，这样所有公司遵循相同的通信规范，网络就能互联互通了。</p>
<h3 id="（1）模型框架"><a href="#（1）模型框架" class="headerlink" title="（1）模型框架"></a>（1）模型框架</h3><p>OSI模型定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI模型各层的通信协议，大致举例如下表所示：</p>
<p>表：OSI模型各层的通信协议举例</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、等</td>
</tr>
<tr>
<td>表示层</td>
<td>XDR、ASN.1、SMB、AFP、NCP、等</td>
</tr>
<tr>
<td>会话层</td>
<td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets、等</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等</td>
</tr>
<tr>
<td>网络层</td>
<td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25、等</td>
</tr>
<tr>
<td>数据链路层</td>
<td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP、等</td>
</tr>
<tr>
<td>物理层</td>
<td>例如铜缆、网线、光缆、无线电等</td>
</tr>
</tbody></table>
<p>TCP&#x2F;IP协议是Internet互联网最基本的协议，其在一定程度上参考了七层ISO模型。OSI模型共有七层，从下到上分别是物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在TCP&#x2F;IP协议中，七层被简化为了四个层次。TCP&#x2F;IP模型中的各种协议，依其功能不同，被分别归属到这四层之中，常被视为是简化过后的七层OSI模型。</p>
<img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/tcpip.ouuuvzbisf4.webp" style="zoom: 67%;" />



<ul>
<li>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li>
<li>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li>
<li>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</li>
<li>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li>
</ul>
<p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。</li>
</ul>
</li>
</ul>
<h3 id="（2）TCP"><a href="#（2）TCP" class="headerlink" title="（2）TCP"></a>（2）TCP</h3><p><strong>1. 客户端向服务器发送数据</strong></p>
<p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">       <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">  <span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">  <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">  <span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">  <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">  <span class="comment">// 3.写出数据.</span></span><br><span class="line">  os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">  <span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">  os.close();</span><br><span class="line">  client.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.服务器向客户端回写数据</strong></p>
<p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">       <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">       <span class="comment">// =================回写数据=======================</span></span><br><span class="line">       <span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> server.getOutputStream();</span><br><span class="line">       <span class="comment">// 6. 回写数据</span></span><br><span class="line">        out.write(<span class="string">&quot;我很好,谢谢你&quot;</span>.getBytes());</span><br><span class="line">       <span class="comment">// 7.关闭资源.</span></span><br><span class="line">       out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">  <span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">  <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">  <span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">  <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">  <span class="comment">// 3.写出数据.</span></span><br><span class="line">  os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">       <span class="comment">// ==============解析回写=========================</span></span><br><span class="line">       <span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">       <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">       <span class="comment">// 5. 读取数据数据</span></span><br><span class="line">       <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">       System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line">  <span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">       in.close();</span><br><span class="line">  os.close();</span><br><span class="line">  client.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）UDP"><a href="#（3）UDP" class="headerlink" title="（3）UDP"></a>（3）UDP</h3><p><strong>1. 发送数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="comment">//DatagramSocket()构造数据报套接字并将其绑定到本地主机上的任何可用端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">        <span class="comment">//DatagramPacket(byte[]buf,intlength,InetAddressaddress,intport)</span></span><br><span class="line">        <span class="comment">//构造一个数据包，发送长度为length的数据包到指定主机上的指定端口号。</span></span><br><span class="line">        <span class="type">byte</span>[]bys=<span class="string">&quot;hello,udp,我来了&quot;</span>.getBytes();</span><br><span class="line">		<span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length,InetAddress.getByName(<span class="string">&quot;192.168.1.66&quot;</span>),<span class="number">10086</span>);</span><br><span class="line">        <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">        <span class="comment">//voidsend(DatagramPacketp)从此套接字发送数据报包</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        <span class="comment">//voidclose()关闭此数据报套接字</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 接收数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//创建一个数据包，用于接收数据</span></span><br><span class="line">            <span class="type">byte</span>[]bys=newbyte[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length);</span><br><span class="line">            <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">            ds.receive(dp);</span><br><span class="line">            <span class="comment">//解析数据包，并把数据在控制台显示</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据是：&quot;</span>+newString(dp.getData(),<span class="number">0</span>,dp.getLength()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="31-Servlet相关知识"><a href="#31-Servlet相关知识" class="headerlink" title="31. Servlet相关知识"></a>31. Servlet相关知识</h2><h3 id="1-浏览器请求流程"><a href="#1-浏览器请求流程" class="headerlink" title="1.浏览器请求流程"></a>1.浏览器请求流程</h3><p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/requestResponse.dumyv4zju3c.webp"></p>
<h3 id="2-Tomcat目录介绍"><a href="#2-Tomcat目录介绍" class="headerlink" title="2.Tomcat目录介绍"></a>2.Tomcat目录介绍</h3><ul>
<li>bin：包含了一些jar , bat文件 。 startup.bat</li>
<li>conf：tomcat的配置 server.xml web.xml</li>
<li>lib ：tomcat运行所需的jar文件</li>
<li>logs：运行的日志文件</li>
<li>temp：临时文件</li>
<li>webapps：发布到tomcat服务器上的项目，就存放在这个目录。</li>
<li>work：jsp翻译成class文件存放地</li>
</ul>
<h3 id="3-配置文件方式创建servlet"><a href="#3-配置文件方式创建servlet" class="headerlink" title="3.配置文件方式创建servlet"></a>3.配置文件方式创建servlet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 创建JavaEE项目</span><br><span class="line">	2. 定义一个类，实现Servlet接口</span><br><span class="line">		* public class ServletDemo1 implements Servlet</span><br><span class="line">	3. 实现接口中的抽象方法</span><br><span class="line">	4. 配置Servlet</span><br><span class="line">		 在web.xml中配置：</span><br><span class="line">	    &lt;!--配置Servlet --&gt;</span><br><span class="line">	    &lt;servlet&gt;</span><br><span class="line">	        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">	        &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line">	    &lt;/servlet&gt;</span><br><span class="line">	</span><br><span class="line">	    &lt;servlet-mapping&gt;</span><br><span class="line">	        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">	        &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;</span><br><span class="line">	    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">* 执行原理：</span><br><span class="line">	1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</span><br><span class="line">	2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。</span><br><span class="line">	3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名</span><br><span class="line">	4. tomcat会将字节码文件加载进内存，并且创建其对象</span><br><span class="line">	5. 调用其方法</span><br></pre></td></tr></table></figure>



<h3 id="4-注解方式创建servlet"><a href="#4-注解方式创建servlet" class="headerlink" title="4.注解方式创建servlet"></a>4.注解方式创建servlet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">* Servlet3.0 支持注解配置。可以不需要web.xml了。</span><br><span class="line"></span><br><span class="line">* 步骤：</span><br><span class="line">	1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</span><br><span class="line">	2. 定义一个类，实现Servlet接口</span><br><span class="line">	3. 复写方法</span><br><span class="line">	4. 在类上使用@WebServlet注解，进行配置</span><br><span class="line">		* @WebServlet(&quot;资源路径&quot;)</span><br><span class="line">		一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;)</span><br><span class="line"></span><br><span class="line">    @Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">    @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">    @Documented</span><br><span class="line">    public @interface WebServlet &#123;</span><br><span class="line">        String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;</span><br><span class="line"></span><br><span class="line">        String[] value() default &#123;&#125;;//代表urlPatterns()属性配置</span><br><span class="line"></span><br><span class="line">        String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt;</span><br><span class="line"></span><br><span class="line">        int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;</span><br><span class="line"></span><br><span class="line">        WebInitParam[] initParams() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        boolean asyncSupported() default false;</span><br><span class="line"></span><br><span class="line">        String smallIcon() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String largeIcon() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String description() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String displayName() default &quot;&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-URL和URI的区别"><a href="#5-URL和URI的区别" class="headerlink" title="5.URL和URI的区别"></a>5.URL和URI的区别</h3><ul>
<li>URL:统一资源定位符 ： <a target="_blank" rel="noopener" href="http://localhost/day14/demo1">http://localhost/day14/demo1</a>	中华人民共和国</li>
<li>URI：统一资源标识符 : &#x2F;day14&#x2F;demo1					共和国</li>
</ul>
<h3 id="6-Http请求头"><a href="#6-Http请求头" class="headerlink" title="6. Http请求头"></a>6. Http请求头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*</span><br><span class="line">Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Length: 31</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"></span><br><span class="line">       Accept: 客户端向服务器端表示，我能支持什么类型的数据。 </span><br><span class="line">       Referer ： 真正请求的地址路径，全路径</span><br><span class="line">       Accept-Language: 支持语言格式</span><br><span class="line">       User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 </span><br><span class="line">       Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据</span><br><span class="line">       Accept-Encoding： gzip, deflate ： 压缩算法 。 </span><br><span class="line">       Host ： 主机地址</span><br><span class="line">       Content-Length： 数据长度</span><br><span class="line">       Connection : Keep-Alive 保持连接</span><br><span class="line">       Cache-Control ： 对缓存的操作</span><br></pre></td></tr></table></figure>



<h3 id="7-常见的响应头"><a href="#7-常见的响应头" class="headerlink" title="7.常见的响应头"></a>7.常见的响应头</h3><ol>
<li>Content-Type：text&#x2F;html;charset&#x3D;UTF-8 服务器告诉客户端本次响应体数据格式以及编码格式</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据<ul>
<li>值：<ul>
<li>in-line:默认值,在当前页面内打开</li>
<li>attachment;filename&#x3D;xxx：以附件形式打开响应体。文件下载</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="8-ServletContext对象"><a href="#8-ServletContext对象" class="headerlink" title="8.ServletContext对象"></a>8.ServletContext对象</h3><ul>
<li>ServletContext代表是一个web应用的环境（上下文）对象，（代表整个web应用，可以和程序的容器(服务器)来通信）ServletContext对象 内部封装是该web应用的信息，ServletContext对象一个web应用只有一个<ul>
<li>问题：一个web应用有几个servlet对象？</li>
<li>答: 多个</li>
</ul>
</li>
<li>ServletContext对象的生命周期？<ul>
<li>创建：该web应用被加载（服务器启动或发布web应用（前提，服务器启动状 态））</li>
<li>销毁：web应用被卸载（服务器关闭，移除该web应用）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 获取：</span><br><span class="line">	1. 通过request对象获取</span><br><span class="line">		request.getServletContext();</span><br><span class="line">	2. 通过HttpServlet获取</span><br><span class="line">		this.getServletContext();</span><br><span class="line">2. 功能：</span><br><span class="line">	1. 获取MIME类型：</span><br><span class="line">		* MIME类型:在互联网通信过程中定义的一种文件数据类型</span><br><span class="line">			* 格式： 大类型/小类型   text/html		image/jpeg</span><br><span class="line"></span><br><span class="line">		* 获取：String getMimeType(String file)  </span><br><span class="line">	2. 域对象：共享数据</span><br><span class="line">		1. setAttribute(String name,Object value)</span><br><span class="line">		2. getAttribute(String name)</span><br><span class="line">		3. removeAttribute(String name)</span><br><span class="line"></span><br><span class="line">		* ServletContext对象范围：所有用户所有请求的数据</span><br><span class="line">	3. 获取文件的真实(服务器)路径</span><br><span class="line">		1. 方法：String getRealPath(String path)  </span><br><span class="line">			String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问</span><br><span class="line">	        System.out.println(b);</span><br><span class="line">	</span><br><span class="line">	        String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问</span><br><span class="line">	        System.out.println(c);</span><br><span class="line">	</span><br><span class="line">	        String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问</span><br><span class="line">	        System.out.println(a);</span><br></pre></td></tr></table></figure>



<h2 id="32-Cookie-amp-Session"><a href="#32-Cookie-amp-Session" class="headerlink" title="32. Cookie&amp;Session"></a>32. Cookie&amp;Session</h2><ul>
<li>session与Cookie的区别：<br>  1. session存储数据在服务器端，Cookie在客户端<br>  2. session没有数据大小限制，Cookie有<br>  3. session数据安全，Cookie相对于不安全</li>
</ul>
<ul>
<li>Cookie：数据存储在客户端本地，减少服务器端的存储的压力，安全性不好，客户端 可以清除cookie</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/cookieTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  &#123;</span><br><span class="line">    	<span class="comment">//设置Cookie的value</span></span><br><span class="line">        <span class="comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str_date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//URL编码</span></span><br><span class="line">        str_date = URLEncoder.encode(str_date,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;编码后：&quot;</span>+str_date);</span><br><span class="line"></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;lastTime&quot;</span>,str_date);</span><br><span class="line">        <span class="comment">//设置cookie的存活时间</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);<span class="comment">//一个月</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;JSESSIONID&quot;</span>,session.getId());</span><br><span class="line">	    c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">	    response.addCookie(c);</span><br><span class="line">        </span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Session：将数据存储到服务器端，安全性相对好，增加服务器的压力</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/sessionTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  &#123;</span><br><span class="line">        <span class="comment">//1．获得Session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2．怎样向session中存取数据（session也是一个域对象）</span></span><br><span class="line">        Session也是存储数据的区域对象，所以session对象也具有如下三个方法：</span><br><span class="line">        session.setAttribute(String name,Object obj);</span><br><span class="line">        session.getAttribute(String name);</span><br><span class="line">        session.removeAttribute(String name);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="33-过滤器，拦截器，监听器的区别"><a href="#33-过滤器，拦截器，监听器的区别" class="headerlink" title="33. 过滤器，拦截器，监听器的区别"></a>33. 过滤器，拦截器，监听器的区别</h2><p>把<code>整个项目的流程比作一条河，那么监听器的作用就是能够听到河流里的所有声音，过滤器就是能够过滤出其中的鱼，而拦截器则是拦截其中的部分鱼，并且作标记。所以当需要监听到项目中的一些信息，并且不需要对流程做更改时，用监听器；当需要过滤掉其中的部分信息，只留一部分时，就用过滤器；当需要对其流程进行更改，做相关的记录时用拦截器</code>。<br> <strong>监听器</strong>更好的应用是用于<strong>信息的监听</strong><br> <strong>过滤器</strong>更好的应用是用于做请求的过滤，<strong>拦截无效的请求和信息</strong><br> <strong>拦截器</strong>则是可以根据实际场景需要，<strong>对业务逻辑进行校验和调整</strong>。所以类似用户登录校验，拦截器会是更好的选择。</p>
<p>执行顺序：</p>
<p><strong>监听器 &gt; 过滤器 &gt; 拦截器 &gt; servlet执行 &gt; 拦截器 &gt; 过滤器 &gt; 监听器</strong></p>
<h3 id="1-过滤器Filter"><a href="#1-过滤器Filter" class="headerlink" title="1.过滤器Filter"></a>1.过滤器Filter</h3><blockquote>
<p> 过滤器定义在 javax.servlet包，是Servlet规范的一部分，在JavaWeb项目中都可以使用。<br> 我们常常使用过滤器来<strong>过滤掉一些无效的请求</strong>，避免过多无效请求落到servlet、controller上，导致浪费系统的资源。也常用来对请求的编码进行统一的设置，如配置CharacterEncodingFilter作为字符编码过滤器。同时，<strong>过滤器Filter是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关的请求，只有当你的web应用停止或重新部署的时候才能销毁。</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">自定义过滤器</span><br><span class="line"></span><br><span class="line">执行顺序：如果有两个过滤器：过滤器1和过滤器2</span><br><span class="line">    1. 过滤器1</span><br><span class="line">    2. 过滤器2</span><br><span class="line">    3. 资源执行</span><br><span class="line">    4. 过滤器2</span><br><span class="line">    5. 过滤器1 </span><br><span class="line">1. 定义一个类，实现接口Filter</span><br><span class="line">2. 复写方法</span><br><span class="line">3. 配置拦截路径: `web.xml`或者注解`@WebFilter`</span><br><span class="line"></span><br><span class="line">* 过滤器先后顺序问题：</span><br><span class="line">1. 注解配置：按照类名的字符串比较规则比较，值小的先执行,如： AFilter 和 BFilter，AFilter就先执行了。</span><br><span class="line">2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行</span><br></pre></td></tr></table></figure>

<p><strong>（1）注解方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoming.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/user/*&quot;,filterName = &quot;filter1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">//  在Filter初始化的时候调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter1 has been initialized ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 每个用户请求都会调用到这个方法，校验通过则doFilter放行到下一个过滤器</span></span><br><span class="line"><span class="comment">     *  等到请求通过所有过滤链上的校验后，才能到达servlet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterChain</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doFilter1开始执行，对&quot;</span>+((HttpServletRequest)servletRequest).getRequestURL().toString()+<span class="string">&quot; 进行过滤 &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;检验接口是否被调用，尝试获取contentType如下： &quot;</span> + servletResponse.getContentType());</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;检验接口是否被调用，尝试获取contentType如下： &quot;</span> + servletResponse.getContentType());</span><br><span class="line">        System.out.println(<span class="string">&quot;doFilter1执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter对象被销毁的时候调用，注意，执行该方法后会在调用一次dofilter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter1 has been destroyed...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）web.xml配置方式</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.filter.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-拦截器Interceptor"><a href="#2-拦截器Interceptor" class="headerlink" title="2.拦截器Interceptor"></a>2.拦截器Interceptor</h3><blockquote>
<p>依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoming.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对接收到的请求进行前置处理，如果返回true才将请求放行给controller</span></span><br><span class="line"><span class="comment">     *  如果返回false，执行中断请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle has done...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  执行croller后，渲染视图之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle has done...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      整个请求结束后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion has done...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">CustomInterceptorA</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">CustomInterceptorB</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spring-mvc.xml文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xiaoming.util.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-过滤器和拦截器的区别："><a href="#3-过滤器和拦截器的区别：" class="headerlink" title="3. 过滤器和拦截器的区别："></a>3. 过滤器和拦截器的区别：</h3><p>　　① 拦截器是基于java的反射机制的，而过滤器是基于函数回调。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在我们自定义的过滤器中都会实现一个 doFilter()方法，这个方法有一个FilterChain 参数，而实际上它是一个回调接口。</span><br><span class="line">ApplicationFilterChain是它的实现类， 这个实现类内部也有一个 doFilter() 方法就是回调方法。</span><br><span class="line">ApplicationFilterChain里面能拿到我们自定义的xxxFilter类，在其内部回调方法doFilter()里调用各个自定义xxxFilter过滤器，并执行 doFilter() 方法。</span><br><span class="line">而每个xxxFilter 会先执行自身的 doFilter() 过滤逻辑，最后在执行结束前会执行filterChain.doFilter(servletRequest, servletResponse)，也就是回调ApplicationFilterChain的doFilter() 方法，以此循环执行实现函数回调。</span><br></pre></td></tr></table></figure>

<p>　　② 拦截器(<code>Interceptor</code>) 它是一个<code>Spring</code>组件，并由<code>Spring</code>容器管理，并不依赖<code>Tomcat</code>等容器，是可以单独使用的；过滤器依赖与servlet容器，所以导致它只能在<code>web</code>程序中使用。</p>
<p>　　③ 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。<br>　　④ 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。<br>　　⑤ 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.拦截器加载的时间点在springcontext之前, 过滤器在springcontext之后；</span><br><span class="line">2.实际开发过程中，会出现多个过滤器或拦截器同时存在的情况，可以使用@Order(Ordered.HIGHEST_PRECEDENCE)控制顺序</span><br><span class="line">过滤器用@Order注解控制执行顺序，通过@Order控制过滤器的级别，值越小级别越高越先执行。</span><br><span class="line">拦截器默认的执行顺序，就是它的注册顺序，也可以通过Order手动设置控制，值越小越先执行。</span><br><span class="line">3.控制执行顺序不同</span><br><span class="line">    1    Interceptor1 前置</span><br><span class="line">    2    Interceptor2 前置</span><br><span class="line">    3    Interceptor 前置</span><br><span class="line">    4    我是controller</span><br><span class="line">    5    Interceptor 处理中</span><br><span class="line">    6    Interceptor2 处理中</span><br><span class="line">    7    Interceptor1 处理中</span><br><span class="line">    8    Interceptor 后置</span><br><span class="line">    9    Interceptor2 处理后</span><br><span class="line">   10    Interceptor1 处理后</span><br></pre></td></tr></table></figure>

<p>　　⑥ <strong>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</strong></p>
<ol>
<li>过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。</li>
</ol>
<p><strong>总结：过滤器包裹住servlet，servlet包裹住拦截器。</strong></p>
<p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/fiter2.5zw9t497kko0.png"></p>
<ol start="2">
<li>过滤器的触发时机是容器后，servlet之前，所以过滤器的<code>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>的入参是ServletRequest ，而不是httpservletrequest。因为过滤器是在httpservlet之前。</li>
<li>过滤器是JavaEE标准，采用函数回调的方式进行。是在请求进入容器之后，还未进入Servlet之前进行预处理，并且在请求结束返回给前端这之间进行后期处理。</li>
</ol>
<h3 id="4-监听器Listener"><a href="#4-监听器Listener" class="headerlink" title="4.监听器Listener"></a>4.监听器Listener</h3><blockquote>
<p> web监听器是一种Servlet中的特殊的类，它们能帮助开发者监听web中的特定事件，实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：感知到包括request(请求域)，session(会话域)和applicaiton(应用程序)的初始化和属性的变化。</p>
</blockquote>
<p>监听器大概分为以下几种</p>
<ul>
<li>ServletContextListener：对Servlet上下文的创建和销毁进行监听</li>
<li>ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和修改</li>
<li>HttpSessionListener：对Session的创建和销毁进行监听</li>
<li>HttpSessionAttributeListener：对Session对象中属性的添加、删除和修改进行监听</li>
<li>HttpSessionBindingListener：监听Http会话中对象的绑定信息</li>
<li>HttpSessionActivationListener：监听器监听Http会话的情况</li>
<li>ServletRequestListener：对请求对象的初始化和销毁进行监听</li>
<li>ServletRequestAttributeListener：对请求对象属性的添加、删除和修改进行监听</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1. 定义一个类，实现ServletContextListener接口</span><br><span class="line">2. 复写方法</span><br><span class="line">3. 配置</span><br><span class="line">	(1) web.xml</span><br><span class="line">		&lt;listener&gt;</span><br><span class="line">	&lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">		&lt;/listener&gt;</span><br><span class="line">		* 指定初始化参数&lt;context-param&gt;</span><br><span class="line">	(2) 注解：@WebListener</span><br></pre></td></tr></table></figure>



<h2 id="34-注解"><a href="#34-注解" class="headerlink" title="34.注解"></a>34.注解</h2><h3 id="1-JDK中预定义的一些注解"><a href="#1-JDK中预定义的一些注解" class="headerlink" title="1. JDK中预定义的一些注解"></a>1. JDK中预定义的一些注解</h3><p>JDK预设了以下注解，作用于代码：</p>
<ul>
<li>@Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）</li>
<li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
</ul>
<h3 id="2-自定义注解"><a href="#2-自定义注解" class="headerlink" title="2. 自定义注解"></a>2. 自定义注解</h3><p><strong>元注解：用于描述注解的注解</strong></p>
<ul>
<li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented - 标记这些注解是否包含在用户文档中。</li>
<li>@Target - 标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>
<li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<p><strong>格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">	属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</li>
</ul>
<p>​		public interface MyAnno extends java.lang.annotation.Annotation {}</p>
<ul>
<li>属性：接口中的抽象方法<br>要求：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 属性的返回值类型有下列取值</span><br><span class="line">	基本数据类型、String、 枚举、注解、以上类型的数组</span><br><span class="line">2. 定义了属性，在使用时需要给属性赋值</span><br><span class="line">	* 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</span><br><span class="line">	* 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</span><br><span class="line">	* 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略</span><br></pre></td></tr></table></figure>

<h3 id="3-反射获取注解"><a href="#3-反射获取注解" class="headerlink" title="3. 反射获取注解"></a>3. 反射获取注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : clazz.getMethod(<span class="string">&quot;test&quot;</span>).getAnnotations()) &#123;</span><br><span class="line">        System.out.println(annotation.annotationType());   <span class="comment">//获取类型</span></span><br><span class="line">        System.out.println(annotation <span class="keyword">instanceof</span> Test);   <span class="comment">//直接判断是否为Test</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> (Test) annotation;</span><br><span class="line">        System.out.println(test.value());   <span class="comment">//获取我们在注解中写入的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="35-函数式接口"><a href="#35-函数式接口" class="headerlink" title="35. 函数式接口"></a>35. 函数式接口</h2><blockquote>
<p> 含义：函数式接口在Java中是指：有且仅有一个抽象方法的接口</p>
<p> 函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p>
</blockquote>
<p><strong>1. 格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名称 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值 类型方法名称 (可选参数信息);<span class="comment">//其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. @FunctionalInterface</strong></p>
<p>注解与@Override注解的作用类似，Java8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。该注解可用于一个接口的定义上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样</p>
<h3 id="1-Supplier接口"><a href="#1-Supplier接口" class="headerlink" title="1.  Supplier接口"></a>1.  Supplier接口</h3><p>Supplier接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产 什么类型的数据供我们使用。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T get()</td>
<td>按照某种实现逻辑(由Lambda表达式实现)返回一个数据</td>
</tr>
</tbody></table>
<p>需求：打印出姓名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Supplier</span> Demo &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString(()-&gt;<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        </span><br><span class="line">        Integeri=getInteger(()-&gt;<span class="number">30</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法，返回一个整数数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">getInteger</span><span class="params">(Supplier&lt;Integer&gt; sup)</span>&#123;</span><br><span class="line">        returnsup.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，返回一个字符串数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span>&#123;</span><br><span class="line">        returnsup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-Consumer接口"><a href="#2-Consumer接口" class="headerlink" title="2. Consumer接口"></a>2. Consumer接口</h3><p>Consumer接口也被称为消费型接口，它消费的数据的数据类型由泛型指定</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void accept(T t)</td>
<td>对给定的参数执行此操作</td>
</tr>
<tr>
<td>default Consumer andThen(Consumer after)</td>
<td>返回一个组合的Consumer，依次执行此操作，然后执行 after操作，</td>
</tr>
</tbody></table>
<p>需求：将两个Consumer接口按照顺序组合到一起使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//操作一</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(s));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//操作二</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString())</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//传入两个操作使用andThen完成</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(s), s -&gt;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，用不同的方式消费同一个字符串数据两次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con1,</span></span><br><span class="line"><span class="params">    Consumer&lt;String&gt; con2)</span> &#123;</span><br><span class="line">        <span class="comment">// con1.accept(name);</span></span><br><span class="line">        <span class="comment">// con2.accept(name);</span></span><br><span class="line">        con1.andThen(con2).accept(name);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//定义一个方法，消费一个字符串数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con)</span> &#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Predicate接口"><a href="#3-Predicate接口" class="headerlink" title="3. Predicate接口"></a>3. Predicate接口</h3><p>Predicate接口通常用于判断参数是否满足指定的条件</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean test(T t)</td>
<td>对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回 一个布尔值</td>
</tr>
<tr>
<td>default Predicate negate()</td>
<td>返回一个逻辑的否定，对应逻辑非</td>
</tr>
<tr>
<td>default Predicate and(Predicate other)</td>
<td>返回一个组合判断，对应短路与</td>
</tr>
<tr>
<td>default Predicate or(Predicate other)</td>
<td>返回一个组合判断，对应短路或</td>
</tr>
</tbody></table>
<p>需求：返回数组，同时满足如下要求：姓名长度大于2；年龄大于33</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;柳岩,34&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;貂蝉,31&quot;</span>, <span class="string">&quot;王祖贤, 33&quot;</span>&#125;;</span><br><span class="line">    List&lt;String&gt; array = myFilter(</span><br><span class="line">        strArray, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() &gt; <span class="number">2</span>,</span><br><span class="line">        s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">33</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (String str : array) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">myFilter</span><span class="params">(String[] strArray,</span></span><br><span class="line"><span class="params">                                     Predicate&lt;String&gt; pre1,</span></span><br><span class="line"><span class="params">                                     Predicate&lt;String&gt; pre2)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个集合</span></span><br><span class="line">    List&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (String str : strArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre1.and(pre2).test(str)) &#123;</span><br><span class="line">            <span class="comment">//姓名长度大于2；年龄大于33</span></span><br><span class="line">            array.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Function接口"><a href="#4-Function接口" class="headerlink" title="4. Function接口"></a>4. Function接口</h3><p>Function接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>R apply(T t)</td>
<td>将此函数应用于给定的参数</td>
</tr>
<tr>
<td>default Function andThen(Function after)</td>
<td>返回一个组合函数，首先将该函数应用于输入，然后将after函 数应用于结果</td>
</tr>
</tbody></table>
<p>需求：1.将字符串截取得到数字年龄部分; 2.将上一步的年龄字符串转换成为int类型的数据; 3.将上一步的int数据加70，得到一个int结果，在控制台输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;林青霞,30&quot;</span>;</span><br><span class="line"></span><br><span class="line">    convert(s, ss -&gt; ss.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>], Integer::parseInt, i -&gt; i + <span class="number">70</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String str, </span></span><br><span class="line"><span class="params">                            Function&lt;String, String&gt; fun1,</span></span><br><span class="line"><span class="params">                            Function&lt;String, Integer&gt; fun2, </span></span><br><span class="line"><span class="params">                            Function&lt;Integer, Integer&gt; fun3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fun1.andThen(fun2).andThen(fun3).apply(str);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="36-Lamda表达式"><a href="#36-Lamda表达式" class="headerlink" title="36. Lamda表达式"></a>36. Lamda表达式</h2><h3 id="1-获取Stream"><a href="#1-获取Stream" class="headerlink" title="1. 获取Stream"></a>1. 获取Stream</h3><p>（1）Collection</p>
<ul>
<li>java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。</li>
</ul>
<p>（2）Map</p>
<ul>
<li>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 需要分key、value或entry等情况</li>
</ul>
<p>（3）数组</p>
<p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：<code>Stream.of(array)</code></p>
<h3 id="2-Stream流中间操作方法"><a href="#2-Stream流中间操作方法" class="headerlink" title="2. Stream流中间操作方法"></a>2. Stream流中间操作方法</h3><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： </p>
<ul>
<li><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </li>
<li><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Stream filter(Predicate predicate)</td>
<td>用于对流中的数据进行过滤</td>
</tr>
<tr>
<td>Stream limit(long maxSize)</td>
<td>返回此流中的元素组成的流，截取前指定参数个数的数据</td>
</tr>
<tr>
<td>Stream skip(long n)</td>
<td>跳过指定参数个数的数据，返回由该流的剩余元素组成的 流</td>
</tr>
<tr>
<td>static Stream concat(Stream a, Stream b)</td>
<td>合并a和b两个流为一个流</td>
</tr>
<tr>
<td>Stream distinct()</td>
<td>返回由该流的不同元素（根据Object.equals(Object) ）组 成的流</td>
</tr>
<tr>
<td>Stream sorted()</td>
<td>返回由此流的元素组成的流，根据自然顺序排序</td>
</tr>
<tr>
<td>Stream sorted(Comparator comparator)</td>
<td>返回由该流的元素组成的流，根据提供的Comparator进行 排序</td>
</tr>
<tr>
<td>Stream map(Function mapper)</td>
<td>返回由给定函数应用于此流的元素的结果组成的流</td>
</tr>
<tr>
<td>IntStream mapToInt(ToIntFunction mapper)</td>
<td>返回一个IntStream其中包含将给定函数应用于此流的元素 的结果</td>
</tr>
</tbody></table>
<p><strong>1. filter</strong></p>
<p>可以通过 filter 方法将一个流转换成另一个子集流；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</span></span><br><span class="line"><span class="comment">//如果结果为true，那么Stream流的 filter方法将会留用元素；</span></span><br><span class="line"><span class="comment">//如果结果为false，那么filter方法将会舍弃元素</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. map</strong></p>
<p>将流中的元素映射到另一个流中，可以使用 map 方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">    Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. limit</strong></p>
<p>limit 方法可以对流进行截取，只取用前n个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">    System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. skip</strong></p>
<p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">    System.out.println(result.count()); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. concat</strong></p>
<p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. sorted</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;linqingxia&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;zhangmanyu&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;wangzuxian&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;liuyan&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;zhangmin&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;zhangwuji&quot;</span>);</span><br><span class="line">    <span class="comment">//需求1：按照字母顺序把数据在控制台输出</span></span><br><span class="line">    <span class="comment">// list.stream().sorted().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//需求2：按照字符串长度把数据在控制台输出</span></span><br><span class="line">    list.stream().sorted((s1,s2) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s1.length()-s2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num==<span class="number">0</span>?s1.compareTo(s2):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. map&amp;mapToInt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;50&quot;</span>);</span><br><span class="line">    <span class="comment">//需求：将集合中的字符串数据转换为整数之后在控制台输出</span></span><br><span class="line">    <span class="comment">// list.stream().map(s -&gt; Integer.parseInt(s)).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">// list.stream().map(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">// list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//int sum() 返回此流中元素的总和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().mapToInt(Integer::parseInt).sum();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Stream流终结操作方法"><a href="#3-Stream流终结操作方法" class="headerlink" title="3. Stream流终结操作方法"></a>3. Stream流终结操作方法</h3><p><strong>1. forEach:</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    stream.forEach(name‐&gt; System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. count</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法返回一个long值代表元素个数（不再像旧集合那样是int值）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="4-Stream流的收集操作"><a href="#4-Stream流的收集操作" class="headerlink" title="4. Stream流的收集操作"></a>4. Stream流的收集操作</h3><p>对数据使用Stream流的方式操作完毕后，可以把流中的数据收集到集合中。</p>
<p><strong>常用方法：</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>R collect(Collector collector)</td>
<td>把结果收集到集合中</td>
</tr>
</tbody></table>
<p><strong>工具类Collectors提供了具体的收集方式</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Collector toList()</td>
<td>把元素收集到List集合中</td>
</tr>
<tr>
<td>public static Collector toSet()</td>
<td>把元素收集到Set集合中</td>
</tr>
<tr>
<td>public static Collector toMap(Function keyMapper,Function valueMapper)</td>
<td>把元素收集到Map集合 中</td>
</tr>
</tbody></table>
<h3 id="5-方法引用"><a href="#5-方法引用" class="headerlink" title="5. 方法引用"></a>5. 方法引用</h3><blockquote>
<p>如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，就没必要再写重复逻辑了</p>
<p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟</p>
</blockquote>
<h4 id="1-冗余的Lambda场景"><a href="#1-冗余的Lambda场景" class="headerlink" title="1. 冗余的Lambda场景"></a>1. 冗余的Lambda场景</h4><p><strong>（1）例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串<br>打印到什么地方去。而 main 方法通过Lambda表达式指定了函数式接口 Printable 的具体操作方案为：<strong>拿到</strong><br><strong>String（类型可推导，所以可省略）数据后，在控制台中输出它。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01PrintSimple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span> &#123;</span><br><span class="line">    	data.print(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	printString(s ‐&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out 对象中的 println(String) 方法。</p>
<p><strong>（2）改进：</strong></p>
<p>其中的双冒号 :: 写法，这被称为“方法引用”，而双冒号是一种新的语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02PrintRef</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span> &#123;</span><br><span class="line">    	data.print(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	printString(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）语义分析</strong></p>
<p>上例中， <code>System.out </code>对象中有一个重载的<code>println(String)</code>方法恰好就是我们所需要的。那么对于 <code>printString</code> 方法的函数式接口参数，对比下面两种写法，完全等效： </p>
<ul>
<li>Lambda表达式写法： s -&gt; System.out.println(s); </li>
<li>方法引用写法： System.out::println</li>
</ul>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。</p>
<p>第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代Lambda。</p>
<p>两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<p> <strong>注：</strong>Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p>
<h4 id="2-通过对象名引用成员方法"><a href="#2-通过对象名引用成员方法" class="headerlink" title="2. 通过对象名引用成员方法"></a>2. 通过对象名引用成员方法</h4><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRefObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUpperCase</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    	System.out.println(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式接口仍然定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当需要使用这个<code> printUpperCase</code> 成员方法来替代<code>Printable</code>接口的Lambda的时候，已经具有了 <code>MethodRefObject </code>类的对象实例，则可以通过对象名引用成员方法，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable lambda)</span> &#123;</span><br><span class="line">	lambda.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MethodRefObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodRefObject</span>();</span><br><span class="line">    printString(obj::printUpperCase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-通过类名称引用静态方法"><a href="#4-通过类名称引用静态方法" class="headerlink" title="4. 通过类名称引用静态方法"></a>4. 通过类名称引用静态方法</h4><p>由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写 法。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calcable</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种写法是使用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> num, Calcable lambda)</span> &#123;</span><br><span class="line">	System.out.println(lambda.calc(num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	method(‐<span class="number">10</span>, n ‐&gt; Math.abs(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用方法引用的更好写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> num, Calcable lambda)</span> &#123;</span><br><span class="line">	System.out.println(lambda.calc(num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	method(‐<span class="number">10</span>, Math::abs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-通过super引用成员方法"><a href="#5-通过super引用成员方法" class="headerlink" title="5. 通过super引用成员方法"></a>5. 通过super引用成员方法</h4><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Greetable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是父类 Human 的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是子类 Man 的内容，其中使用了Lambda的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;大家好,我是Man!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义方法method,参数传递Greetable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Greetable g)</span>&#123;</span><br><span class="line">    	g.greet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,使用Lambda表达式</span></span><br><span class="line">        method(()‐&gt;&#123;</span><br><span class="line">            <span class="comment">//创建Human对象,调用sayHello方法</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Human</span>().sayHello();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//简化Lambda</span></span><br><span class="line">        method(()‐&gt;<span class="keyword">new</span> <span class="title class_">Human</span>().sayHello());</span><br><span class="line">        <span class="comment">//使用super关键字代替父类对象</span></span><br><span class="line">        method(()‐&gt;<span class="built_in">super</span>.sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 Woman ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;大家好,我是Man!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义方法method,参数传递Greetable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Greetable g)</span>&#123;</span><br><span class="line">    	g.greet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    	method(<span class="built_in">super</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-通过this引用成员方法"><a href="#6-通过this引用成员方法" class="headerlink" title="6.  通过this引用成员方法"></a>6.  通过this引用成员方法</h4><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方 法引用。首先是简单的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Richable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个丈夫 Husband 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">    	lambda.buy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">    	marry(() ‐&gt; System.out.println(<span class="string">&quot;买套房子&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开心方法 <code>beHappy</code> 调用了结婚方法<code> marry</code> ，后者的参数为函数式接口 <code>Richable</code> ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 <code>Husband</code> 丈夫类进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;买套房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">    	lambda.buy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">    	marry(() ‐&gt; <span class="built_in">this</span>.buyHouse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;买套房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">    	lambda.buy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">    	marry(<span class="built_in">this</span>::buyHouse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-类的构造器引用"><a href="#7-类的构造器引用" class="headerlink" title="7. 类的构造器引用"></a>7. 类的构造器引用</h4><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <code>类名称::new</code> 的格式表示。首先是一个简单 的 Person 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是用来创建 Person 对象的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonBuilder</span> &#123;</span><br><span class="line">	Person <span class="title function_">buildPerson</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是用来创建 Person 对象的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder builder)</span> &#123;</span><br><span class="line">	System.out.println(builder.buildPerson(name).getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	printName(<span class="string">&quot;赵丽颖&quot;</span>, name ‐&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是通过构造器引用，有更好的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder builder)</span> &#123;</span><br><span class="line">	System.out.println(builder.buildPerson(name).getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	printName(<span class="string">&quot;赵丽颖&quot;</span>, Person::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-数组的构造器引用"><a href="#8-数组的构造器引用" class="headerlink" title="8. 数组的构造器引用"></a>8. 数组的构造器引用</h4><p>数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArrayBuilder</span> &#123;</span><br><span class="line">	<span class="type">int</span>[] buildArray(<span class="type">int</span> length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用该接口的时候，可以通过Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] initArray(<span class="type">int</span> length, ArrayBuilder builder) &#123;</span><br><span class="line">	<span class="keyword">return</span> builder.buildArray(length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span>[] array = initArray(<span class="number">10</span>, length ‐&gt; <span class="keyword">new</span> <span class="title class_">int</span>[length]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是更好的写法是使用数组的构造器引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] initArray(<span class="type">int</span> length, ArrayBuilder builder) &#123;</span><br><span class="line">	<span class="keyword">return</span> builder.buildArray(length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span>[] array = initArray(<span class="number">10</span>, <span class="type">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="37-内存泄漏"><a href="#37-内存泄漏" class="headerlink" title="37.内存泄漏"></a>37.内存泄漏</h2><h3 id="1-含义："><a href="#1-含义：" class="headerlink" title="1. 含义："></a>1. 含义：</h3><blockquote>
<p>内存泄漏：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。</p>
</blockquote>
<p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：</p>
<ol>
<li><strong>首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；</strong></li>
<li><strong>其次，这些对象是无用的，即程序以后不会再使用这些对象。</strong></li>
</ol>
<p>如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<p>而且对于linux kernel，只要不断电就不会释放内存，所以如果内存泄漏积累到一定程度了，就只能重启</p>
<h3 id="2-回收机制"><a href="#2-回收机制" class="headerlink" title="2. 回收机制"></a>2. 回收机制</h3><p>在Java语言中，判断一个内存空间是否符合垃圾收集的标准有两个：</p>
<ul>
<li><p><strong>一个是给对象赋予了空值null，再没有调用过；</strong></p>
</li>
<li><p><strong>另一个是给对象赋予了新值，这样重新分配了内存空间。</strong></p>
</li>
</ul>
<h3 id="3-原因"><a href="#3-原因" class="headerlink" title="3. 原因"></a>3. 原因</h3><blockquote>
<p>根本原因：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是<strong>因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景</strong>。</p>
</blockquote>
<p>具体主要有如下几大类：</p>
<h4 id="（1）静态集合类引起内存泄漏"><a href="#（1）静态集合类引起内存泄漏" class="headerlink" title="（1）静态集合类引起内存泄漏"></a>（1）静态集合类引起内存泄漏</h4><p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Static <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o&#x3D;null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p>
<h4 id="（2）监听器"><a href="#（2）监听器" class="headerlink" title="（2）监听器"></a>（2）监听器</h4><p>在 java编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如**addXXXListener()**等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p>
<h4 id="（3）各种连接"><a href="#（3）各种连接" class="headerlink" title="（3）各种连接"></a>（3）各种连接</h4><p>​		比如数据库连接<strong>dataSourse.getConnection()<strong>，网络连接</strong>socket</strong>和 <strong>io</strong>连接，除非其显式的调用了其<strong>close()</strong> 方法将其连接关闭，否则是不会自动被<strong>GC</strong> 回收的。<br>​		对于<strong>Resultset</strong> 和<strong>Statement</strong> 对象可以不进行显式回收，但<strong>Connection</strong> 一定要显式回收，因为<strong>Connection</strong> 在任何时候都无法自动回收，而<strong>Connection</strong>一旦回收，<strong>Resultset</strong> 和<strong>Statement</strong> 对象就会立即为<strong>NULL</strong>。</p>
<p>​		但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭<strong>Resultset Statement</strong> 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的<strong>Statement</strong> 对象无法释放，从而引起内存泄漏。这种情况下一般都会在<strong>try</strong> 里面去的连接，在<strong>finally</strong>里面释放连接。</p>
<h4 id="（4）内部类和外部模块的引用"><a href="#（4）内部类和外部模块的引用" class="headerlink" title="（4）内部类和外部模块的引用"></a>（4）内部类和外部模块的引用</h4><p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：<code>public void registerMsg(Object b);</code>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。</p>
<h4 id="（5）单例模式"><a href="#（5）单例模式" class="headerlink" title="（5）单例模式"></a>（5）单例模式</h4><p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在 <strong>JVM</strong> 的整个生命周期中存在（<strong>以静态变量的方式</strong>），如果单例对象持有外部的引用，那么这个对象将不能被 <strong>JVM</strong> 正常回收，导致内存泄漏，如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        B.getInstance().setA(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B类采用单例模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">B</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Java-内存分配策略"><a href="#4-Java-内存分配策略" class="headerlink" title="4. Java 内存分配策略"></a>4. Java 内存分配策略</h3><p>Java 程序运行时的内存分配策略有三种,分别是<strong>静态分配,栈式分配</strong>,和<strong>堆式分配</strong>，对应的，三种存储策略使用的内存空间主要分别是<strong>静态存储区（也称方法区）、栈区和堆区</strong>。</p>
<p><strong>静态存储区（方法区）</strong>：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</p>
<p><strong>栈区</strong> ：当方法被执行时，方法体内的局部变量（其中包括<strong>基础数据类型、对象的引用</strong>）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p><strong>堆区</strong> ： 又称<strong>动态内存分配</strong>，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 <strong>Java 垃圾回收器</strong>来负责回收。</p>
<ul>
<li>局部变量 的基本数据类型和引用存储于<strong>栈</strong>中，引用的对象实体存储于<strong>堆</strong>中。—— 因为它们属于方法中的变量，生命周期随方法而结束。</li>
<li>成员变量 <strong>全部存储于</strong>堆中（<em>包括基本数据类型，引用和引用的对象实体</em>）—— 因为它们属于类，类对象终究是要被new出来使用的。</li>
</ul>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a><a class="post-meta__tags" href="/tags/JavaWeb/">JavaWeb</a></div><div class="post_share"></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/06/04/17.easyExcel%E4%BD%BF%E7%94%A8/" title="【Java】EasyExcel使用"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-04</div><div class="title">【Java】EasyExcel使用</div></div></a></div><div><a href="/2022/03/08/2.Thread&ThreadPool/" title="【Java】Thread &amp;&amp; ThreadPool"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-08</div><div class="title">【Java】Thread &amp;&amp; ThreadPool</div></div></a></div><div><a href="/2022/06/05/20.localDateTime/" title="【Java】LocalDateTime相关使用"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-05</div><div class="title">【Java】LocalDateTime相关使用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81JavaSE"><span class="toc-text">一、JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%8C%83%E5%9B%B4"><span class="toc-text">1. 基本数据类型范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2. 修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">3. 转义字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">4. 代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%A7%E6%89%BF-amp-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. 继承&amp;实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-text">6. 重写和重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7. final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">8. 抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%8E%A5%E5%8F%A3%E7%89%B9%E7%82%B9"><span class="toc-text">9. 接口特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10. 接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-x3D-x3D-%E5%8F%B7%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11. &#x3D;&#x3D;号和equals方法的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Integer%E7%B1%BB-128%E5%88%B0127%E9%99%B7%E9%98%B1"><span class="toc-text">12. Integer类-128到127陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">13. Java正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Math%E7%B1%BB-x2F-Random%E7%B1%BB-x2F-BigInteger%E7%B1%BB-x2F-BigDecimal%E7%B1%BB"><span class="toc-text">14. Math类&#x2F;Random类&#x2F;BigInteger类&#x2F;BigDecimal类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">15.日期类的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="toc-text">16. 集合体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-CopyOnWriteArrayList%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-text">17. CopyOnWriteArrayList如何做到线程安全的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">18. 集合的线程安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%B3%9B%E5%9E%8B"><span class="toc-text">19. 泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%BE%AA%E7%8E%AF%E9%9B%86%E5%90%88%E7%9A%84%E6%97%B6%E5%80%99%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">20. 不能在循环集合的时候删除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-TreeSet-%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E5%94%AF%E4%B8%80%E5%92%8C%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">21. TreeSet 保证元素唯一和自然排序的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Comparable-amp-Comparator%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">21. Comparable &amp; Comparator的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-finally%E4%B8%8Ereturn%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">22. finally与return的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-IO%E6%B5%81"><span class="toc-text">23. IO流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Java%E5%BC%82%E6%88%96"><span class="toc-text">24. Java异或</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Properties%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-text">25. Properties类简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%8F%8D%E5%B0%84"><span class="toc-text">26. 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 获取Class对象的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 通过反射获取构造方法并使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B9%B6%E8%B0%83%E7%94%A8"><span class="toc-text">3. 获取成员变量并调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E8%B0%83%E7%94%A8"><span class="toc-text">4. 获取成员方法并调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8D%E5%B0%84main%E6%96%B9%E6%B3%95"><span class="toc-text">5. 反射main方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">6. 通过反射运行配置文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B6%8A%E8%BF%87%E6%B3%9B%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-text">7. 通过反射越过泛型检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">27. 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2. 静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">3. 动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8ECGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-text">4. JDK动态代理与CGLIB动态代理对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0"><span class="toc-text">5. 其他文章</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-MyBatis%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">28. MyBatis中${} 和 #{} 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-Redis%E7%9B%B8%E5%85%B3"><span class="toc-text">29. Redis相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">（1）Redis的5种数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Redis%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">（2）Redis操作命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">30. 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A8%A1%E5%9E%8B%E6%A1%86%E6%9E%B6"><span class="toc-text">（1）模型框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89TCP"><span class="toc-text">（2）TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89UDP"><span class="toc-text">（3）UDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-Servlet%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">31. Servlet相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-text">1.浏览器请求流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Tomcat%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.Tomcat目录介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BAservlet"><span class="toc-text">3.配置文件方式创建servlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BAservlet"><span class="toc-text">4.注解方式创建servlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-URL%E5%92%8CURI%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5.URL和URI的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Http%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">6. Http请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">7.常见的响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ServletContext%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.ServletContext对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-Cookie-amp-Session"><span class="toc-text">32. Cookie&amp;Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">33. 过滤器，拦截器，监听器的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%87%E6%BB%A4%E5%99%A8Filter"><span class="toc-text">1.过滤器Filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor"><span class="toc-text">2.拦截器Interceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">3. 过滤器和拦截器的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%9B%91%E5%90%AC%E5%99%A8Listener"><span class="toc-text">4.监听器Listener</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E6%B3%A8%E8%A7%A3"><span class="toc-text">34.注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JDK%E4%B8%AD%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3"><span class="toc-text">1. JDK中预定义的一些注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">2. 自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3"><span class="toc-text">3. 反射获取注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">35. 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Supplier%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.  Supplier接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Consumer%E6%8E%A5%E5%8F%A3"><span class="toc-text">2. Consumer接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Predicate%E6%8E%A5%E5%8F%A3"><span class="toc-text">3. Predicate接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Function%E6%8E%A5%E5%8F%A3"><span class="toc-text">4. Function接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">36. Lamda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96Stream"><span class="toc-text">1. 获取Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Stream%E6%B5%81%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-text">2. Stream流中间操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Stream%E6%B5%81%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-text">3. Stream流终结操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Stream%E6%B5%81%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-text">4. Stream流的收集操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">5. 方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%97%E4%BD%99%E7%9A%84Lambda%E5%9C%BA%E6%99%AF"><span class="toc-text">1. 冗余的Lambda场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">2. 通过对象名引用成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E7%A7%B0%E5%BC%95%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">4. 通过类名称引用静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%9A%E8%BF%87super%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">5. 通过super引用成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%80%9A%E8%BF%87this%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">6.  通过this引用成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">7. 类的构造器引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">8. 数组的构造器引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">37.内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%AB%E4%B9%89%EF%BC%9A"><span class="toc-text">1. 含义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">2. 回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8E%9F%E5%9B%A0"><span class="toc-text">3. 原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E9%9B%86%E5%90%88%E7%B1%BB%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">（1）静态集合类引起内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">（2）监听器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5"><span class="toc-text">（3）各种连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">（4）内部类和外部模块的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">（5）单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">4. Java 内存分配策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#end"><span class="toc-text">end</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 一只草履虫</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://fastly.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'bBtQVBbzW7eDs5d0zHYEbyYi-gzGzoHsz',
      appKey: '8JbhJ2dhlVdotOn2sS6AXotb',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="255,255,255" opacity="1" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="Java,C,C艹,C#,Python,GO,PHP,Ruby,SQL,Curl,JavaScript,HTML,XML,R,Lua,Scala,Erlang,Perl,Swift,Objective-C,Visual Basic,Lisp" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>