<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解决GitHub访问慢</title>
      <link href="/2022/10/01/52.%E8%A7%A3%E5%86%B3GitHub%E8%AE%BF%E9%97%AE%E6%85%A2/"/>
      <url>/2022/10/01/52.%E8%A7%A3%E5%86%B3GitHub%E8%AE%BF%E9%97%AE%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<p>GitHub访问慢或者无法访问一般是由以下问题引起的：</p><ol><li>本地网络访问慢，科学上网速度很快</li><li>本地网络无法访问（响应时间过长导致无法访问）</li><li>由于github的加速分发CDN域名assets-cdn.github.com遭到DNS污染，无法访问</li></ol><h2 id="1-修改本地hosts映射"><a href="#1-修改本地hosts映射" class="headerlink" title="1. 修改本地hosts映射"></a>1. 修改本地hosts映射</h2><blockquote><p>域名解析直接指向GitHub的IP地址，以此来绕过DNS解析</p></blockquote><h3 id="1-1-查看最新GitHub-的最新ip地址"><a href="#1-1-查看最新GitHub-的最新ip地址" class="headerlink" title="1.1 查看最新GitHub 的最新ip地址"></a>1.1 查看最新GitHub 的最新ip地址</h3><p>在 <a href="https://link.juejin.cn/?target=www.ipaddress.com">ip地址查询</a> 网站中查询GitHub相关的网站对应的最新IP地址</p><ul><li>github.com</li><li>github.global.ssl.fastly.net</li><li>assets-cdn.github.com</li><li>codeload.github.com</li></ul><p>在当前网站中查询指定网站ip地址还可以使用另外方法:</p><p>①直接将网站作为参数进行请求，省略点击查询的步骤：</p><ul><li><a href="https://link.juejin.cn/?target=https://websites.ipaddress.com/github.global.ssl.fastly.net">websites.ipaddress.com&#x2F;github.glob…</a></li><li><a href="https://link.juejin.cn/?target=https://websites.ipaddress.com/github.com">websites.ipaddress.com&#x2F;github.com</a></li><li><a href="https://link.juejin.cn/?target=https://websites.ipaddress.com/assets-cdn.github.com">websites.ipaddress.com&#x2F;assets-cdn.…</a></li><li><a href="https://link.juejin.cn/?target=https://websites.ipaddress.com/codeload.github.com">websites.ipaddress.com&#x2F;codeload.gi…</a></li></ul><p>②将ip查询网站拼接在之后进行查询</p><ul><li><a href="https://link.juejin.cn/?target=http://github.global.ssl.fastly.net.ipaddress.com/">github.global.ssl.fastly.net.ipaddress.com&#x2F;</a></li><li><a href="https://link.juejin.cn/?target=https://github.com.ipaddress.com/">github.com.ipaddress.com&#x2F;</a></li><li><a href="https://link.juejin.cn/?target=https://assets-cdn.github.com.ipaddress.com/">assets-cdn.github.com.ipaddress.com&#x2F;</a></li><li><a href="https://link.juejin.cn/?target=https://codeload.github.com.ipaddress.com/">codeload.github.com.ipaddress.com&#x2F;</a></li></ul><h3 id="1-2-本地hosts文件映射ip地址"><a href="#1-2-本地hosts文件映射ip地址" class="headerlink" title="1.2 本地hosts文件映射ip地址"></a>1.2 本地hosts文件映射ip地址</h3><p>找到对应的IP地址后，将IP地址与网站地址进行对应，并将对应关系写入本地hosts文件中。</p><p>在windows系统中的<code>c:/Windows/System32/drivers/etc</code> 下找到hosts文件，编辑打开，将四个网站的IP地址和网站地址对应写入进入，作为DNS的映射。</p><p>hosts文件直接编辑修改时可能没有权限，可以通过以下方法完成修改：</p><ol><li>修改当前文件权限，右键hosts文件 -&gt; 属性 -&gt; 安全 -&gt; 编辑 -&gt; Users -&gt; Users的权限后加入写权限</li><li>将当前文件复制到别的盘中，修改文件后复制回来覆盖原来文件</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#github</span> <span class="selector-tag">dns</span>映射 格式如：  <span class="selector-attr">[ip]</span>: <span class="selector-attr">[domainName]</span></span><br><span class="line"><span class="number">199.232</span><span class="selector-class">.69</span><span class="selector-class">.194</span> <span class="selector-tag">github</span><span class="selector-class">.global</span><span class="selector-class">.ssl</span><span class="selector-class">.Fastly</span><span class="selector-class">.net</span></span><br><span class="line"><span class="number">140.82</span><span class="selector-class">.114</span><span class="selector-class">.4</span> <span class="selector-tag">GitHub</span><span class="selector-class">.com</span></span><br><span class="line"><span class="number">185.199</span><span class="selector-class">.108</span><span class="selector-class">.153</span> <span class="selector-tag">assets-cdn</span><span class="selector-class">.Github</span><span class="selector-class">.com</span></span><br><span class="line"><span class="number">140.82</span><span class="selector-class">.114</span><span class="selector-class">.9</span> <span class="selector-tag">codeload</span><span class="selector-class">.Github</span><span class="selector-class">.com</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="1-3-刷新DNS缓存来访问新的映射"><a href="#1-3-刷新DNS缓存来访问新的映射" class="headerlink" title="1.3 刷新DNS缓存来访问新的映射"></a>1.3 刷新DNS缓存来访问新的映射</h3><p>hosts文件内容更新成功后，还需要刷新windows系统的DNS才可以生效。</p><p>使用 win+R ，打开cmd命令行，输入 <code>ipconfig/flushdns</code> 刷新DNS缓存即可。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/223e9cf00ea947c88e0e34342ff3b6aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image-20211016150711634"></p><p>刷新完成后，再次打开github网站时速度会明显提升，需要注意的是以上github网站的ip经常发生变化，如果访问再次变慢可以重新更新映射信息。</p><h2 id="2-一键更新"><a href="#2-一键更新" class="headerlink" title="2. 一键更新"></a>2. 一键更新</h2><p>手动更新本地hosts文件的方式比较繁琐，我们可以编写程序来代替手动操作，实现需要时hosts文件内容的一键更新。</p><p>推荐一个github开源项目：<a href="https://link.juejin.cn/?target=https://github.com/isevenluo/github-hosts">更新hosts</a> ，<a href="https://link.juejin.cn/?target=https://gitee.com/isevenluo/github-hosts">国内git地址</a>，作者会每日提供最新的相关ip地址映射信息，我们可以直接复制使用或者使用其中的程序进行一键更新操作。</p><p>作为一个coder，我们也可以自己去实现一个脚本程序。</p><h2 id="3-Chrome插件"><a href="#3-Chrome插件" class="headerlink" title="3. Chrome插件"></a>3. Chrome插件</h2><p>chrome插件如github加速等，可以实现在访问和下载项目是使用镜像加速，提升访问速度。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dabc8271b5a44624aa647e0e7e648b73~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image-20211016153443393"></p><p>如果无法访问chrome下载插件，推荐一个好用的chrome插件下载网站：<a href="https://link.juejin.cn/?target=https://www.extfans.com/">Extfans</a> ，下载后使用开发者模式安装插件即可使用。</p><h2 id="4-镜像网站"><a href="#4-镜像网站" class="headerlink" title="4. 镜像网站"></a>4. 镜像网站</h2><p>github访问速度慢，我们还可以使用镜像网站来代替github</p><ul><li><a href="https://link.juejin.cn/?target=https://github.com.cnpmjs.org">github.com.cnpmjs.org</a></li><li><a href="https://link.juejin.cn/?target=https://hub.fastgit.org">hub.fastgit.org</a></li></ul><p>以上两个网站作为镜像网站，基本包含了github上已有的项目信息，并且可以查看和下载相关项目，速度还不错，可以作为备用网站使用。</p><p>作者：东方甲乙木土<br>链接：<a href="https://juejin.cn/post/7019683061977579557">https://juejin.cn/post/7019683061977579557</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令记录</title>
      <link href="/2022/09/19/42.linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/09/19/42.linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>要整数时间</p><p>1、查看时间段日志：sed -n ‘&#x2F;起始时间&#x2F;,&#x2F;结束时间&#x2F;p’ 日志文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/2021-05-21 10:08/,/2021-05-21 10:09/p&#x27;</span> nohup.out</span><br></pre></td></tr></table></figure><p>2、指定时间点的日志，并导出到单独文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/2021-05-21 10:08/,/2021-05-21 10:09/p&#x27;</span> nohup.out &gt; nohup0521.out</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务使用及失效场景</title>
      <link href="/2022/09/19/37.spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
      <url>/2022/09/19/37.spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：</p><p><a href="https://blog.csdn.net/mccand1234/article/details/124571619">https://blog.csdn.net/mccand1234/article/details/124571619</a></p><p><a href="https://blog.csdn.net/zzhongcy/article/details/102893309">https://blog.csdn.net/zzhongcy/article/details/102893309</a></p></blockquote><h1 id="一、事务定义"><a href="#一、事务定义" class="headerlink" title="一、事务定义"></a>一、事务定义</h1><p>事务，就是一组操作数据库的动作集合。事务是现代数据库理论中的核心概念之一。如果一组处理步骤或者全部发生或者一步也不执行，我们称该组处理步骤为一个事务。当所有的步骤像一个操作一样被完整地执行，我们称该事务被提交。由于其中的一部分或多步执行失败，导致没有步骤被提交，则事务必须回滚到最初的系统状态。</p><h2 id="1-事务特点ACID"><a href="#1-事务特点ACID" class="headerlink" title="1.事务特点ACID"></a>1.事务特点ACID</h2><p>1.原子性(Atomicity)：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做要么全不做</p><p>2.一致性(Consistency)：数据不会因为事务的执行而遭到破坏</p><p>3.隔离性(Isolation)：一个事物的执行，不受其他事务的干扰，即并发执行的事物之间互不干扰</p><p>4.持久性(Durability)：一个事物一旦提交，它对数据库的改变就是永久的。</p><h2 id="2-spring事务"><a href="#2-spring事务" class="headerlink" title="2.spring事务"></a>2.spring事务</h2><p> Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为<strong>编码式</strong>和<strong>声明式</strong>的两种方式。</p><p>   （1）编程式事务指的是通过编码方式实现事务；</p><p>   （2）声明式事务基于 AOP,将具体业务逻辑与事务处理解耦。</p><p>​    声明式事务管理使业务代码逻辑不受污染, 因此在实际使用中声明式事务用的比较多。</p><p>   声明式事务有两种方式：</p><p>​    （1）一种是在配置文件（xml）中做相关的事务规则声明，</p><p>​    （2）另一种是基于@Transactional 注解的方式。</p><h2 id="3-开启事务"><a href="#3-开启事务" class="headerlink" title="3.开启事务"></a>3.开启事务</h2><ul><li>方式1：在 xml 配置中的事务配置信息</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>方式2：使用**@EnableTransactionManagement** 注解也可以启用事务管理功能</li></ul><p>springboot通过DataSourceTransactionManagerAutoConfiguration类，已经默默的开启了事务</p><h2 id="4-事务的传播行为"><a href="#4-事务的传播行为" class="headerlink" title="4.事务的传播行为"></a>4.事务的传播行为</h2><table><thead><tr><th><strong>Propagation属性</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>REQUIRED</td><td>默认值 在有transaction状态下执行；如当前没有transaction，则创建新的transaction；</td></tr><tr><td>SUPPORTS</td><td>如当前有transaction，则在transaction状态下执行；如果当前没有transaction，在无transaction状态下执行；</td></tr><tr><td>MANDATORY</td><td>必须在有transaction状态下执行，如果当前没有transaction，则抛出异常IllegalTransactionStateException；</td></tr><tr><td>REQUIRES_NEW</td><td>创建新的transaction并执行；如果当前已有transaction，则将当前transaction挂起；</td></tr><tr><td>NOT_SUPPORTED</td><td>在无transaction状态下执行；如果当前已有transaction，则将当前transaction挂起；</td></tr><tr><td>NEVER</td><td>在无transaction状态下执行；如果当前已有transaction，则抛出异常IllegalTransactionStateException；</td></tr><tr><td>NESTED</td><td>如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务</td></tr></tbody></table><h2 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5.事务的隔离级别"></a>5.事务的隔离级别</h2><table><thead><tr><th align="left">隔离级别</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">DEFAULT</td><td align="left">这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别. 另外四个与JDBC的隔离级别相对应；</td></tr><tr><td align="left">READ_UNCOMMITTED</td><td align="left">最低的隔离级别。事实上我们不应该称其为隔离级别，因为在事务完成前，其他事务可以看到该事务所修改的数据。而在其他事务提交前，该事务也可以看到其他事务所做的修改。可能导致脏，幻，不可重复读</td></tr><tr><td align="left">READ_COMMITTED</td><td align="left">大多数数据库的默认级别。在事务完成前，其他事务无法看到该事务所修改的数据。遗憾的是，在该事务提交后，你就可以查看其他事务插入或更新的数据。这意味着在事务的不同点上，如果其他事务修改了数据，你就会看到不同的数据。可防止脏读，但幻读和不可重复读仍可以发生。</td></tr><tr><td align="left">REPEATABLE_READ</td><td align="left">比ISOLATION_READ_COMMITTED更严格，该隔离级别确保如果在事务中查询了某个数据集，你至少还能再次查询到相同的数据集，即使其他事务修改了所查询的数据。然而如果其他事务插入了新数据，你就可以查询到该新插入的数据。可防止脏读，不可重复读，但幻读仍可能发生。</td></tr><tr><td align="left">SERIALIZABLE</td><td align="left">完全服从ACID的隔离级别，<strong>确保不发生脏读、不可重复读和幻影读</strong>。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。代价最大、可靠性最高的隔离级别，所有的事务都是按顺序一个接一个地执行。避免所有不安全读取。</td></tr></tbody></table><h2 id="6-事务并发会产生什么问题"><a href="#6-事务并发会产生什么问题" class="headerlink" title="6.事务并发会产生什么问题"></a>6.事务并发会产生什么问题</h2><table><thead><tr><th align="left">术语</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">脏读</td><td align="left"><strong>A事务读取到了B事务还未提交的数据，如果B未提交的事务回滚了，那么A事务读取的数据就是无效的，这就是数据脏读</strong></td></tr><tr><td align="left">不可重复读</td><td align="left"><strong>在同一个事务中，多次读取同一数据返回的结果不一致，这是由于读取事务在进行操作的过程中，如果出现更新事务，它必须等待更新事务执行成功提交完成后才能继续读取数据，这就导致读取事务在前后读取的数据不一致的状况出现</strong></td></tr><tr><td align="left">幻读</td><td align="left"><strong>A事务读取了几行记录后，B事务插入了新数据，并且提交了插入操作，在后续操作中A事务就会多出几行原本不存在的数据，就像A事务出现幻觉，这就是幻读</strong></td></tr></tbody></table><h3 id="1）第一类丢失更新："><a href="#1）第一类丢失更新：" class="headerlink" title="1）第一类丢失更新："></a>1）第一类丢失更新：</h3><p>在<strong>没有事务隔离</strong>的情况下，两个事务都同时更新一行数据，但是第二个事务却中途失败退出， 导致对数据的两个修改都失效了。</p><p>例如：</p><p>张三的工资为5000，事务A中获取工资为5000，事务B获取工资为5000，汇入100，并提交数据库，工资变为5100，</p><p>随后</p><p>事务A发生异常，回滚了，恢复张三的工资为5000，这样就导致事务B的更新丢失了。</p><h3 id="2）脏读："><a href="#2）脏读：" class="headerlink" title="2）脏读："></a>2）脏读：</h3><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。<br>例如：<br>　　张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。<br>　　与此同时，<br>　　事务B正在读取张三的工资，读取到张三的工资为8000。<br>　　随后，<br>　　事务A发生异常，而回滚了事务。张三的工资又回滚为5000。<br>　　最后，<br>　　事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。</p><h3 id="3）不可重复读："><a href="#3）不可重复读：" class="headerlink" title="3）不可重复读："></a>3）不可重复读：</h3><p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。<br>例如：<br>　　在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。<br>　　与此同时，<br>　　事务B把张三的工资改为8000，并提交了事务。<br>　　随后，<br>　　在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p><h3 id="4）第二类丢失更新："><a href="#4）第二类丢失更新：" class="headerlink" title="4）第二类丢失更新："></a>4）第二类丢失更新：</h3><p>不可重复读的特例。<br>有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。</p><p>例如：</p><p>在事务A中，读取到张三的存款为5000，操作没有完成，事务还没提交。<br>　　与此同时，<br>　　事务B，存储1000，把张三的存款改为6000，并提交了事务。<br>　　随后，<br>　　在事务A中，存储500，把张三的存款改为5500，并提交了事务，这样事务A的更新覆盖了事务B的更新。</p><h3 id="5）幻读："><a href="#5）幻读：" class="headerlink" title="5）幻读："></a>5）幻读：</h3><p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。<br>例如：<br>　　目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。<br>　　此时，<br>　　事务B插入一条工资也为5000的记录。<br>　　这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p><p><strong>提醒：</strong><br>  不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了<br>  幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样</p><h1 id="二-、事务不生效【七种】"><a href="#二-、事务不生效【七种】" class="headerlink" title="二 、事务不生效【七种】"></a>二 、事务不生效【七种】</h1><h2 id="1-访问权限问题-只有public方法会生效"><a href="#1-访问权限问题-只有public方法会生效" class="headerlink" title="1.访问权限问题 (只有public方法会生效)"></a>1.访问权限问题 (只有public方法会生效)</h2><table><thead><tr><th>修饰范围</th><th>当前类</th><th>当前包</th><th>子类</th><th>其他类</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>default</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><p>1.private：Java中<strong>private</strong>修饰词修饰的变量，该变量<strong>仅能在当前类内</strong>访问，其他地方（如：当前包、子类、其他类）均无法访问。</p><p>2.default：默认情况下的变量（也就是没有public、private和protected修饰的变量），<strong>既能在当前类内访问，又能在当前包（package）访问。</strong></p><p>3.protected：Java中用protected修饰的变量，<strong>可在当前类访问，也可在当前包和子类（继承父类的子类）中访问。</strong></p><p>4.public：Java中使用public修饰的变量，<strong>当前类、当前包、子类和其他类均可访问。</strong></p><p>众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p><p>但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    @Transactional</span><br><span class="line">    private void add(UserModel userModel) &#123;</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须得是public的。</p><p>说白了，在AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，<strong>如果目标方法不是public</strong>，则TransactionAttribute返回null，即不支持事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t allow no-public methods as required.可以看到， 这里不支持public类型的方法</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The method may be on an interface, but we need attributes from the target class.</span></span><br><span class="line">    <span class="comment">// If the target class is null, the method will be unchanged.</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">specificMethod</span> <span class="operator">=</span> AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First try is the method in the target class.</span></span><br><span class="line">    <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> findTransactionAttribute(specificMethod);</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Second try is the transaction attribute on the target class.</span></span><br><span class="line">    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">      <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">      <span class="comment">// Fallback is to look at the original method.</span></span><br><span class="line">      txAttr = findTransactionAttribute(method);</span><br><span class="line">      <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Last fallback is the class of the original method.</span></span><br><span class="line">      txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是public，而是private、default或protected的话，spring则不会提供事务功能。</p><h2 id="2-方法用final或者static修饰，不会生效"><a href="#2-方法用final或者static修饰，不会生效" class="headerlink" title="2.方法用final或者static修饰，不会生效"></a>2.方法用final或者static修饰，不会生效</h2><p>有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span>&#123;</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到add方法被定义成了final的，这样会导致事务失效。</p><p>如果你看过spring事务的源码，可能会知道<strong>spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能</strong>。<strong>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法</strong>，而添加事务功能。</p><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p><h2 id="3-同一个类中的方法直接内部调用，会导致事务失效"><a href="#3-同一个类中的方法直接内部调用，会导致事务失效" class="headerlink" title="3.同一个类中的方法直接内部调用，会导致事务失效"></a>3.同一个类中的方法直接内部调用，会导致事务失效</h2><p>由于@Transactional 的实现原理是AOP，AOP的实现原理是动态代理，换句话说，自调用时不存在代理对象的调用，这时不会产生我们注解@Transactional 配置的参数，自然无效了。</p><ul><li>对于JDK动态代理</li></ul><p> 因为JDK动态代理采用的是接口实现的方式，通过反射调用目标类的方法，此时如果调用本类的方法，this指的是目标类，并不是代理类所以不会走代理。不走代理，事务自然会失效。</p><ul><li>对于cglib动态代理</li></ul><p> 上文中分析jdk动态代理和cglib动态代理中发现，本类调用本类的方法，如果是cglib代理也会走代理，为什么spring <a href="https://so.csdn.net/so/search?q=aop&spm=1001.2101.3001.7020">aop</a>中这里不会走代理，事务继续无效呢？</p><p> 原因是cglib的代理中我们使用的proxy.invokeSuper(obj,args)方法，他就会走代理，而我们的spring AOP中他是采用责任链的方式调用，相当于先将匹配到的Advisor执行完后，直接执行目标类方法，实际走的是类似与MethodBeforeAdviceInterceptor他的invoke方法，没有走invokeSuper方法就没有走cglib动态代理机制。直接执行的目标方法，没有通过代理。</p><p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//主方法没有事务注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子方法有事务注解</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。<a href="https://blog.csdn.net/yyoc97/article/details/81911744">根本原因</a> <a href="https://blog.csdn.net/mccand1234/article/details/124578233">根本原因2</a></p><p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 情况一：都有事务注解，异常在子方法出现，事务生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> add(book);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">add</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span>  bookDao.addBook(book);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 情况二：都有事务注解，异常在主方法出现，事务生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> add(book);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">add</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span>  bookDao.addBook(book);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 情况三：只有主方法有事务注解，异常在子方法出现，事务生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> add(book);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">add</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span>  bookDao.addBook(book);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 情况四：只有主方法有事务注解，异常在主方法出现，事务生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> add(book);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">add</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span>  bookDao.addBook(book);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 情况五：只有子方法有事务注解，异常在子方法出现，事务不生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> add(book);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">add</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span>  bookDao.addBook(book);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p><h3 id="3-1-新加一个Service方法"><a href="#3-1-新加一个Service方法" class="headerlink" title="3.1 新加一个Service方法"></a>3.1 新加一个Service方法</h3><p>这个方法非常简单，只需要新加一个Service方法，把**@Transactional**注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   prvate ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         serviceB.doSave(user);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-在该Service类中注入自己"><a href="#3-2-在该Service类中注入自己" class="headerlink" title="3.2 在该Service类中注入自己"></a>3.2 在该Service类中注入自己</h3><p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   prvate ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         serviceA.doSave(user);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p><p>答案：不会。</p><p>其实spring ioc内部的<a href="https://blog.csdn.net/mccand1234/article/details/116403266">三级缓存</a>保证了它，不会出现循环依赖问题。</p><h3 id="3-3-通过AopContent类"><a href="#3-3-通过AopContent类" class="headerlink" title="3.3 通过AopContent类"></a>3.3 通过AopContent类</h3><p>在该Service类中使用AopContext.currentProxy()获取代理对象</p><p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         ((ServiceA)AopContext.currentProxy()).doSave(user);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类本身未被spring管理"><a href="#4-类本身未被spring管理" class="headerlink" title="4.类本身未被spring管理"></a>4.类本身未被spring管理</h2><p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p><p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。当然创建bean实例的方法还有很多，不一一说了。有兴趣的小伙伴可以参考这篇文章：@Autowired的这些骚操作，你都知道吗？</p><p>如下所示, 开发了一个Service类，但忘了加@Service注解，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子，我们可以看到UserService类没有加@Service注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。</p><h2 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.<a href="https://blog.csdn.net/Evankaka/article/details/44153709">多线程</a>调用</h2><p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOtherThing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存role表数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p><p><strong>这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</strong></p><p>如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p><h3 id="5-1-多线程控制事务"><a href="#5-1-多线程控制事务" class="headerlink" title="5.1 多线程控制事务"></a>5.1 多线程控制事务</h3><h2 id="6-存储引擎-表不支持事务"><a href="#6-存储引擎-表不支持事务" class="headerlink" title="6.(存储引擎)表不支持事务"></a>6.(存储引擎)表不支持事务</h2><p>周所周知，在mysql5之前，默认的数据库引擎是myisam。</p><p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p><p>有些老项目中，可能还在用它。</p><p>在创建表的时候，只需要把ENGINE参数设置成MyISAM即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `category` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `one_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `two_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `three_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `four_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>myisam好用，但有个很致命的问题是：<strong>不支持事务</strong>。</p><p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p><p>此外，myisam还不支持行锁和外键。</p><p>所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。</p><p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p><h2 id="7-未开启事务"><a href="#7-未开启事务" class="headerlink" title="7.未开启事务"></a>7.未开启事务</h2><p>有时候，事务没有生效的根本原因是没有开启事务。</p><p>你看到这句话可能会觉得好笑。</p><p>开启事务不是一个项目中，最最最基本的功能吗？</p><p>为什么还会没有开启事务？</p><p>没错，如果项目已经搭建好了，事务功能肯定是有的。</p><p>但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？</p><p>当然原因有很多，但没有开启事务，这个原因极其容易被忽略。</p><p>如果你使用的是springboot项目，那么你很幸运。<strong>因为springboot通过DataSourceTransactionManagerAutoConfiguration类，已经默默的帮你开启了事务。</strong></p><p>你所要做的事情很简单，只需要配置spring.datasource相关参数即可。</p><p>但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p><p>具体配置如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;advice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 用切点把事务切进去 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.susan.*.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;advice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>默默的说一句，<strong>如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</strong></p><h1 id="三、事务不回滚【五种】"><a href="#三、事务不回滚【五种】" class="headerlink" title="三、事务不回滚【五种】"></a>三、事务不回滚【五种】</h1><h2 id="1-错误的传播特性"><a href="#1-错误的传播特性" class="headerlink" title="1.错误的传播特性"></a>1.错误的传播特性</h2><p>其实，我们在使用@Transactional注解时，是可以指定propagation参数的。</p><p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p><table><thead><tr><th><strong>Propagation属性</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>REQUIRED</td><td>默认值 在有transaction状态下执行；如当前没有transaction，则创建新的transaction；</td></tr><tr><td>SUPPORTS</td><td>如当前有transaction，则在transaction状态下执行；如果当前没有transaction，在无transaction状态下执行；</td></tr><tr><td>MANDATORY</td><td>必须在有transaction状态下执行，如果当前没有transaction，则抛出异常IllegalTransactionStateException；</td></tr><tr><td>REQUIRES_NEW</td><td>创建新的transaction并执行；如果当前已有transaction，则将当前transaction挂起；</td></tr><tr><td>NOT_SUPPORTED</td><td>在无transaction状态下执行；如果当前已有transaction，则将当前transaction挂起；</td></tr><tr><td>NEVER</td><td>在无transaction状态下执行；如果当前已有transaction，则抛出异常IllegalTransactionStateException；</td></tr><tr><td>NESTED</td><td>如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务</td></tr></tbody></table><p>如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。</p><p>目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p><h2 id="2-自己吞了异常"><a href="#2-自己吞了异常" class="headerlink" title="2.自己吞了异常"></a>2.自己吞了异常</h2><p>事务不会回滚，最常见的问题是：开发者在代码中手动try…catch了异常。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saveData(userModel);</span><br><span class="line">            updateData(userModel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下spring事务当然不会回滚，因为开发者<strong>自己捕获了异常</strong>，又没有手动抛出，换句话说就是把异常吞掉了。</p><p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p><h2 id="3-手动抛了别的异常"><a href="#3-手动抛了别的异常" class="headerlink" title="3.手动抛了别的异常"></a>3.手动抛了别的异常</h2><p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">saveData(userModel);</span><br><span class="line">updateData(userModel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。</p><p><strong>因为spring事务，默认情况下只会回滚RuntimeException（运行时异常）和Error（错误），对于普通的Exception<a href="https://blog.csdn.net/mccand1234/article/details/51579425">非运行时异常</a>，它不会回滚。比如常见的IOExeption和SQLException。</strong></p><h2 id="4-自定义了回滚异常"><a href="#4-自定义了回滚异常" class="headerlink" title="4.自定义了回滚异常"></a>4.自定义了回滚异常</h2><p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置rollbackFor参数，来完成这个功能。</p><p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       saveData(userModel);</span><br><span class="line">       updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。</p><p>即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。</p><p>因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。</p><h2 id="5-嵌套事务回滚多了"><a href="#5-嵌套事务回滚多了" class="headerlink" title="5.嵌套事务回滚多了"></a>5.嵌套事务回滚多了</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        roleService.doOtherThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOtherThing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存role表数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。但事实是，insertUser也回滚了。</p><p>因为doOtherThing方法出现了异常，<strong>没有手动捕获</strong>，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p><p>怎么样才能只回滚保存点呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RoleService roleService;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        try &#123;</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将内部嵌套事务放在try&#x2F;catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p><h1 id="四、大事务与编程式事务"><a href="#四、大事务与编程式事务" class="headerlink" title="四、大事务与编程式事务"></a>四、大事务与编程式事务</h1><h2 id="1-大事务问题"><a href="#1-大事务问题" class="headerlink" title="1. 大事务问题"></a>1. 大事务问题</h2><p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。<br>关于大事务可参考：<a href="https://blog.csdn.net/mccand1234/article/details/124560532">大事务问题</a></p><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><p>通常情况下，我们会在方法上@Transactional注解，填加事务功能，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       query1();</span><br><span class="line">       query2();</span><br><span class="line">       query3();</span><br><span class="line">       roleService.save(userModel);</span><br><span class="line">       update(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       query4();</span><br><span class="line">       query5();</span><br><span class="line">       query6();</span><br><span class="line">       saveData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但@Transactional注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。</p><p>上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roleService.save(userModel);</span><br><span class="line">update(userModel);</span><br></pre></td></tr></table></figure><p>在RoleService类中，只有这一行需要事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveData(userModel);</span><br></pre></td></tr></table></figure><p>现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。</p><p>如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><ul><li>少用@Transactional注解，多用编程式事务</li><li>将查询(select)方法放到事务外</li><li>新加上一个service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中</li><li>在该Service类中注入自己</li><li>在该Service类中使用AopContext.currentProxy()获取代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        ((ServiceA)AopContext.currentProxy()).doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>事务中避免一次性处理太多数据，可以采用分批处理</li><li>非事务处理，在使用事务之前，应该思考一下，是不是所有的数据库操作都需要在事务中执行</li><li>异步处理</li></ul><h2 id="2-声明式事务"><a href="#2-声明式事务" class="headerlink" title="2. 声明式事务"></a>2. 声明式事务</h2><p> 默认情况下，数据库处于自动提交模式。每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。</p><p>​    对于正常的事务管理，是一组相关的操作处于一个事务之中，因此必须关闭数据库的自动提交模式。不过，这个我们不用担心，spring会将底层连接的自动提交特性设置为false。也就是在使用spring进行事物管理的时候，spring会将是否自动提交设置为false，等价于JDBC中的 connection.setAutoCommit(false);，在执行完之后在进行提交，connection.commit(); 。</p><p><strong>@Transactional</strong> 可以作用在<strong>接口、类、类方法</strong>。</p><ul><li><strong>作用于类</strong>：当把@Transactional 注解放在类上时，表示所有该类的public方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。</li><li><strong>作用于接口</strong>：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</li></ul><table><thead><tr><th align="left">参 数 名 称</th><th align="left">功 能 描 述</th></tr></thead><tbody><tr><td align="left">readOnly</td><td align="left">该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：@Transactional(readOnly&#x3D;true)</td></tr><tr><td align="left"><strong>rollbackFor</strong></td><td align="left"><strong>rollbackFor   该属性用于设置需要进行回滚的异常类数组</strong>，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：指定单一异常类：@Transactional(rollbackFor&#x3D;RuntimeException.class)指定多个异常类：@Transactional(rollbackFor&#x3D;{RuntimeException.class, Exception.class})</td></tr><tr><td align="left">rollbackForClassName</td><td align="left">该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：指定单一异常类名称@Transactional(rollbackForClassName&#x3D;”RuntimeException”)指定多个异常类名称：@Transactional(rollbackForClassName&#x3D;{“RuntimeException”,”Exception”})</td></tr><tr><td align="left"><strong>noRollbackFor</strong></td><td align="left">该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如：指定单一异常类：@Transactional(noRollbackFor&#x3D;RuntimeException.class)指定多个异常类：@Transactional(noRollbackFor&#x3D;{RuntimeException.class, Exception.class})</td></tr><tr><td align="left">noRollbackForClassName</td><td align="left">该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如：指定单一异常类名称：@Transactional(noRollbackForClassName&#x3D;”RuntimeException”)指定多个异常类名称：@Transactional(noRollbackForClassName&#x3D;{“RuntimeException”,”Exception”})</td></tr><tr><td align="left"><strong>propagation</strong></td><td align="left">该属性用于设置事务的传播行为。例如：@Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED,readOnly&#x3D;true)</td></tr><tr><td align="left"><strong>isolation</strong></td><td align="left">该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置</td></tr><tr><td align="left">timeout</td><td align="left">该属性用于设置事务的超时秒数，默认值为-1表示永不超时事物超时设置: @Transactional(timeout&#x3D;30) &#x2F;&#x2F;默认是30秒</td></tr></tbody></table><h2 id="3-编程式事务"><a href="#3-编程式事务" class="headerlink" title="3. 编程式事务"></a>3. 编程式事务</h2><h3 id="3-1-TransactionTemplate"><a href="#3-1-TransactionTemplate" class="headerlink" title="3.1 TransactionTemplate"></a>3.1 TransactionTemplate</h3><p>上面的这些内容都是基于@Transactional注解的，主要讲的是它的事务问题，我们把这种事务叫做：声明式事务。</p><p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：编程式事务。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">    queryData1();</span><br><span class="line">    queryData2();</span><br><span class="line">    transactionTemplate.execute(transactionStatus -&gt; &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p><p>相较于@Transactional注解声明式事务，更建议大家使用，基于TransactionTemplate的编程式事务。主要原因如下：</p><ul><li>避免由于spring <a href="https://so.csdn.net/so/search?q=aop&spm=1001.2101.3001.7020">aop</a>问题，导致事务失效的问题。</li><li>能够更小粒度的控制事务的范围，更直观。</li><li>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</li></ul><h3 id="3-2-手动回滚（进行try-x2F-catch，回滚并抛出）"><a href="#3-2-手动回滚（进行try-x2F-catch，回滚并抛出）" class="headerlink" title="3.2 手动回滚（进行try&#x2F;catch，回滚并抛出）"></a>3.2 手动回滚（进行try&#x2F;catch，回滚并抛出）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor=MyException.class,noRollbackFor=RuntimeException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        dao.update(user);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line">        <span class="comment">//------//其他操作</span></span><br><span class="line">        <span class="comment">//捕获异常后进行回滚</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-回滚部分异常"><a href="#3-3-回滚部分异常" class="headerlink" title="3.3 回滚部分异常"></a>3.3 回滚部分异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Object savePoint = TransactionAspectSupport.currentTransactionStatus().createSavepoint(); 设置回滚点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用TransactionAspectSupport.currentTransactionStatus().rollbackToSavepoint(savePoint);回滚到savePoint。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">submitOrder</span> <span class="params">()</span>&#123;  </span><br><span class="line">    success();  </span><br><span class="line">    <span class="comment">//只回滚以下异常，</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">savePoint</span> <span class="operator">=</span> TransactionAspectSupport.currentTransactionStatus().createSavepoint();</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        exception(); </span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        e.printStackTrace();     </span><br><span class="line"><span class="comment">//手工回滚异常</span></span><br><span class="line">TransactionAspectSupport.currentTransactionStatus().rollbackToSavepoint(savePoint);</span><br><span class="line">        <span class="keyword">return</span> ApiReturnUtil.error();</span><br><span class="line">     &#125;  </span><br><span class="line">    <span class="keyword">return</span> ApiReturnUtil.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-使用DataSourceTransactionManager"><a href="#3-4-使用DataSourceTransactionManager" class="headerlink" title="3.4 使用DataSourceTransactionManager"></a>3.4 使用DataSourceTransactionManager</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlatformTransactionManager 事务管理器</span><br><span class="line">TransactionDefinition 事务的一些基础信息，如超时时间、隔离级别、传播属性等</span><br><span class="line">TransactionStatus 事务的一些状态信息，如是否一个新的事务、是否已被标记为回滚</span><br></pre></td></tr></table></figure><ol><li><strong>PlatformTransactionManager</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    <span class="comment">//根据事务定义TransactionDefinition，获取事务</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>事务定义接口TransactionDefinition</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务的定义包括: 事务的隔离级别，事务的传播属性，超时时间设置，是否只读事务的隔离级别是数据库本身的事务功能，事务的播属性则是spring为我们提供的功能</span></span><br><span class="line"><span class="comment">//该接口的实现DefaultTransactionDefinition,默认的事务定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultTransactionDefinition</span> <span class="keyword">implements</span> <span class="title class_">TransactionDefinition</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">propagationBehavior</span> <span class="operator">=</span> PROPAGATION_REQUIRED;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">isolationLevel</span> <span class="operator">=</span> ISOLATION_DEFAULT;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> TIMEOUT_DEFAULT;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">readOnly</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>1.事务的传播属性为PROPAGATION_REQUIRED，即当前没有事务的时候，创建一个，如果有则使用当前事务</li><li>2.事务的隔离级别采用底层数据库默认的隔离级别</li><li>3.超时时间采用底层数据库默认的超时时间</li><li>4.是否只读为false</li></ul><ol start="3"><li><strong>事务接口定义 TransactionStatus</strong></li></ol><p>TransactionStatus它继承了SavepointManager接口，SavepointManager是对事务中上述保存点功能的封装，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SavepointManager</span> &#123;</span><br><span class="line">    Object <span class="title function_">createSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollbackToSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">releaseSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionStatus本身更多存储的是事务的一些状态信息 是否是一个新的事物 是否有保存点 是否已被标记为回滚</p><p>整个流程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动开启事务</span></span><br><span class="line"><span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">status = transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务提交</span></span><br><span class="line">transactionManager.commit(status);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务回滚</span></span><br><span class="line"><span class="keyword">if</span> (StringMoreUtils.checkValNotNull(status)) &#123;</span><br><span class="line">    transactionManager.rollback(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springboot 开启事务以及手动提交事务，可以在服务类上加上两个注解</p><ol><li>手动开启事务<br>TransactionStatus transactionStatus &#x3D; dataSourceTransactionManager.getTransaction(transactionDefinition);</li><li>手动提交事务<br>dataSourceTransactionManager.commit(transactionStatus);</li><li>手动回滚事务, 最好是放在catch 里面,防止程序异常而事务一直卡在哪里未提交<br>dataSourceTransactionManager.rollback(transactionStatus);</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionDefinition transactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager platformTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateEmpanelItemTran</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">transaction</span> <span class="operator">=</span> platformTransactionManager.getTransaction(transactionDefinition);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1();</span><br><span class="line">        t2();</span><br><span class="line">        platformTransactionManager.commit(transaction);</span><br><span class="line">        System.out.println(<span class="string">&quot;提交成功。。。&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;进入了异常。。。&quot;</span>);</span><br><span class="line">        platformTransactionManager.rollback(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、异常"><a href="#五、异常" class="headerlink" title="五、异常"></a>五、异常</h1><p><strong>默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。</strong></p><p>异常的继承结构：</p><ul><li>Throwable为基类，Error和Exception继承Throwable。</li><li>Error和RuntimeException及其子类成为未检查异常（unchecked）</li><li>其它异常成为已检查异常（checked）。</li></ul><p><img src="https://images2015.cnblogs.com/blog/805308/201704/805308-20170407134736253-1566741718.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> Transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8的stream常用方法记录</title>
      <link href="/2022/09/19/35.Stream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/09/19/35.Stream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>都说用的多自然就记住了，但是还是有用的少的方法，但是很巧妙，需要的时候还得去查，用一个记一个吧。<br>别人的博文：<a href="https://www.exception.site/java8/java8-stream-tutorial">https://www.exception.site/java8/java8-stream-tutorial</a></p></blockquote><h2 id="1-从对象集合中根据id找唯一的元素"><a href="#1-从对象集合中根据id找唯一的元素" class="headerlink" title="1. 从对象集合中根据id找唯一的元素"></a>1. 从对象集合中根据id找唯一的元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;SampleEntity&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">SampleEntity</span> <span class="variable">sampleEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SampleEntity</span>();</span><br><span class="line">        sampleEntity.setId(i);</span><br><span class="line">        sampleEntity.setName(<span class="string">&quot;name&quot;</span>+i);</span><br><span class="line">        list.add(sampleEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查出id为3的元素</span></span><br><span class="line">    <span class="type">SampleEntity</span> <span class="variable">one</span> <span class="operator">=</span> list.stream().filter(</span><br><span class="line">        s -&gt; s.getId() == <span class="number">3</span></span><br><span class="line">    ).findFirst().orElseThrow(RuntimeException::<span class="keyword">new</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;findFirst().get()=&quot;</span>+sampleEntity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据id删除某个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> list.removeIf(s -&gt; s.getId().equals(<span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;removeIf=&quot;</span>+b);</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解@SuppressWarnings作用</title>
      <link href="/2022/09/19/34.%E6%B3%A8%E8%A7%A3@SuppressWarnings%E4%BD%9C%E7%94%A8/"/>
      <url>/2022/09/19/34.%E6%B3%A8%E8%A7%A3@SuppressWarnings%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在写代码的时候，不论是导入的包，还是声明的对象，有时候会出现黄线，感觉就很难受！@SuppressWarnings注解主要用在取消一些编译器产生的警告对代码左侧行列的遮挡，只是为了解决强迫症的注解，无任何逻辑作用。</p><table><thead><tr><th align="left"><strong>关键字</strong></th><th align="left"><strong>用途</strong></th></tr></thead><tbody><tr><td align="left">all</td><td align="left">to suppress all warnings （抑制所有警告）</td></tr><tr><td align="left">boxing</td><td align="left">to suppress warnings relative to boxing&#x2F;unboxing operations （抑制装箱、拆箱操作时候的警告）</td></tr><tr><td align="left">cast</td><td align="left">to suppress warnings relative to cast operations （抑制映射相关的警告）</td></tr><tr><td align="left">dep-ann</td><td align="left">to suppress warnings relative to deprecated annotation （抑制启用注释的警告）</td></tr><tr><td align="left">deprecation</td><td align="left">to suppress warnings relative to deprecation （抑制过期方法警告）</td></tr><tr><td align="left">fallthrough</td><td align="left">to suppress warnings relative to missing breaks in switch statements （抑制确在switch中缺失breaks的警告）</td></tr><tr><td align="left">finally</td><td align="left">to suppress warnings relative to finally block that don’t return （抑制finally模块没有返回的警告）</td></tr><tr><td align="left">hiding</td><td align="left">to suppress warnings relative to locals that hide variable（抑制相对于隐藏变量的局部变量的警告）</td></tr><tr><td align="left">incomplete-switch</td><td align="left">to suppress warnings relative to missing entries in a switch statement (enum case)（忽略没有完整的switch语句）</td></tr><tr><td align="left">nls</td><td align="left">to suppress warnings relative to non-nls string literals（ 忽略非nls格式的字符）</td></tr><tr><td align="left">null</td><td align="left">to suppress warnings relative to null analysis（ 忽略对null的操作）</td></tr><tr><td align="left">rawtypes</td><td align="left">to suppress warnings relative to un-specific types when using generics on class params（ 使用generics时忽略没有指定相应的类型）</td></tr><tr><td align="left">restriction</td><td align="left">to suppress warnings relative to usage of discouraged or forbidden references（ 抑制禁止使用劝阻或禁止引用的警告）</td></tr><tr><td align="left">serial</td><td align="left">to suppress warnings relative to missing serialVersionUID field for a serializable class（ 忽略在serializable类中没有声明serialVersionUID变量）</td></tr><tr><td align="left">static-access</td><td align="left">to suppress warnings relative to incorrect static access（ 抑制不正确的静态访问方式警告）</td></tr><tr><td align="left">synthetic-access</td><td align="left">to suppress warnings relative to unoptimized access from inner classes（ 抑制子类没有按最优方法访问内部类的警告）</td></tr><tr><td align="left">unchecked</td><td align="left">to suppress warnings relative to unchecked operations（ 抑制没有进行类型检查操作的警告）</td></tr><tr><td align="left">unqualified-field-access</td><td align="left">to suppress warnings relative to field access unqualified（ 抑制没有权限访问的域的警告）</td></tr><tr><td align="left">unused</td><td align="left">to suppress warnings relative to unused code（ 抑制没被使用过的代码的警告）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM相关</title>
      <link href="/2022/09/13/40.JVM%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/09/13/40.JVM%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="常量池、字符串常量池和运行时常量池的区别"><a href="#常量池、字符串常量池和运行时常量池的区别" class="headerlink" title="常量池、字符串常量池和运行时常量池的区别"></a>常量池、字符串常量池和运行时常量池的区别</h2><blockquote><p><a href="https://blog.csdn.net/TQ20160412/article/details/123815809">https://blog.csdn.net/TQ20160412/article/details/123815809</a></p></blockquote><h3 id="1-常量池"><a href="#1-常量池" class="headerlink" title="1. 常量池"></a>1. 常量池</h3><p>常量池（Constant Pool），也叫 class 常量池（Class Constant Pool）。</p><p>java文件被编译成 class 文件后，class 文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池（Constant Pool），用于存放编译器生成的各种字面量（ Literal ）和 符号引用（Symbolic References）。<strong>每个class文件都有一个class常量池。</strong></p><ul><li><strong>字面量（ Literal ）</strong>：就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。<ul><li>字面量包括：（1）文本字符串； （2）八种基本类型的值；（3）被声明为final的常量等</li></ul></li><li><strong>符号引用（Symbolic References）</strong>：是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<ul><li>符号引用一般包括下面三类常量：（1）类和接口的全限定名；（2）字段的名称和描述符；（3）方法的名称和描述符；</li></ul></li></ul><h3 id="2-字符串常量池"><a href="#2-字符串常量池" class="headerlink" title="2. 字符串常量池"></a>2. 字符串常量池</h3><p>字符串常量池（String Pool），即 String Literal Pool ， 又叫全局字符串池。</p><p>在类加载完成，经过验证，准备阶段之后，在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到 String Pool 中。<strong>String Pool 中存的是引用值</strong>，而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放。</p><p>在 HotSpot VM 里实现的 String Pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。</p><p>举例说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;def&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str2.intern(); </span><br><span class="line">    <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>; </span><br><span class="line">    System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">    System.out.println(str2 == str4);<span class="comment">//false </span></span><br><span class="line">    System.out.println(str4 == str5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">程序的内存分配过程：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、首先，在堆中会有一个 abc 实例对象，全局 StringTable 中存放着 abc 的一个引用值。</span><br><span class="line"><span class="number">2</span>、然后，运行第二句的时候会生成两个实例，一个是 def 的实例对象，并且 StringTable 中存储一个 def 的引用值，还有一个是 <span class="keyword">new</span> 出来的一个 def 的实例对象 。</span><br><span class="line"><span class="number">3</span>、与上面那个是不同的实例，当在解析 str3 的时候查找 StringTable，里面有 abc 的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同 。</span><br><span class="line"><span class="number">4</span>、str4 是在运行的时候调用 intern() 函数，返回 StringTable 中 def 的引用值，如果没有就将 str2 的引用值添加进去，在这里，StringTable 中已经有了 def 的引用值了，所以返回上面在 <span class="keyword">new</span> <span class="title class_">str2</span> 的时候添加到 StringTable 中的 def 引用值。</span><br><span class="line"><span class="number">5</span>、最后 str5 在解析的时候就也是指向存在于 StringTable 中的 def 的引用值。</span><br></pre></td></tr></table></figure><h3 id="3-运行时常量池"><a href="#3-运行时常量池" class="headerlink" title="3.运行时常量池"></a>3.运行时常量池</h3><p>jvm 在执行某个类的时候，必须经过加载、连接（验证、准备、解析）、初始化。而当类加载到内存中后，jvm 就会将 class 常量池 中的内容存放到运行时常量池中，由此可知，<strong>运行时常量池也是每个类都有一个。</strong></p><p>class 常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析之后，也就是把符号引用替换为直接引用，解析的过程会去查询字符串常量池 ，也就是 StringTable，以保证运行时常量池所引用的字符串 与 字符串常量池中所引用的是一致的。</p><h3 id="4-class常量池、字符串常量池、运行时常量池的流转"><a href="#4-class常量池、字符串常量池、运行时常量池的流转" class="headerlink" title="4.class常量池、字符串常量池、运行时常量池的流转"></a>4.class常量池、字符串常量池、运行时常量池的流转</h3><p><strong>方法区</strong>里存储着 <strong>class 文件的信息</strong>和<strong>运行时常量池</strong>，class 文件的信息 包括<strong>类信息</strong> 和 <strong>class文件常量池</strong> 。</p><ol><li>首先，经过编译之后，在该类的 <strong>class 常量池</strong> 中存放一些符号引用；</li><li>然后类加载之后，将 <strong>class 常量池</strong> 中存放的符号引用转存到 <strong>运行时常量池</strong> 中；</li><li>然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中 str1 所指向的 ”abc” 实例对象），然后将这个对象的引用存到全局 <strong>String Pool</strong> 中，也就是 StringTable 中；</li><li>最后在解析阶段，要把<strong>运行时常量池</strong>中的符号引用替换成直接引用，那么就直接查询StringTable，保证 StringTable 里的引用值与<strong>运行时常量池</strong>中的引用值一致，大概整个过程就是这样了。</li></ol><h3 id="5-class文件常量池和运行时常量池的关系和区别"><a href="#5-class文件常量池和运行时常量池的关系和区别" class="headerlink" title="5.class文件常量池和运行时常量池的关系和区别"></a>5.class文件常量池和运行时常量池的关系和区别</h3><p>**class 文件常量池 **存储的是当 class 文件被 jvm 加载进来后存放在方法区的一些字面量和符号引用，字面量包括字符串、基本类型的常量。</p><p><strong>运行时常量池</strong> 是当 class 文件被加载完成后，jvm 会将 class 文件常量池里的内容转移到运行时常量池里，在 class 文件常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。</p><p>待更新…</p>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal使用和了解</title>
      <link href="/2022/09/11/36.ThreadLocal/"/>
      <url>/2022/09/11/36.ThreadLocal/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://blog.csdn.net/weixin_39791386/article/details/109977273">https://blog.csdn.net/weixin_39791386/article/details/109977273</a></p></blockquote><h1 id="1-多线程下的SimpleDateFormat"><a href="#1-多线程下的SimpleDateFormat" class="headerlink" title="1. 多线程下的SimpleDateFormat"></a>1. 多线程下的SimpleDateFormat</h1><h2 id="1-1-案例"><a href="#1-1-案例" class="headerlink" title="1.1 案例"></a>1.1 案例</h2><p>多线程下不建议使用SimpleDateFormat，因为SimpleDateFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//先获取当前时间的格式化字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在通过格式化字符串再操作一次</span></span><br><span class="line">                <span class="type">Date</span> <span class="variable">parseDate</span> <span class="operator">=</span> simpleDateFormat.parse(str1);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> simpleDateFormat.format(parseDate);</span><br><span class="line">                <span class="comment">//对比前后格式化字符串是否一致</span></span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;threadId = %s , 前 = %s , 后 = %s&quot;</span>, Thread.currentThread().getId(), str1, str2));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同个一个线程中，多次操作同一个时间new Date()，比较前后操作的结果是否一样。一样，则代表是现场安全的</p><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: For input string: <span class="string">&quot;1101.E11012E&quot;</span></span><br><span class="line">at java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">2054</span>)</span><br><span class="line">at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>)</span><br><span class="line">at java.base/java.lang.Double.parseDouble(Double.java:<span class="number">543</span>)</span><br><span class="line">at java.base/java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>)</span><br><span class="line">at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2126</span>)</span><br><span class="line">at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">2240</span>)</span><br><span class="line">at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1541</span>)</span><br><span class="line">at java.base/java.text.DateFormat.parse(DateFormat.java:<span class="number">393</span>)</span><br><span class="line">at com.unravely.common.SimpleDateTest.lambda$main$<span class="number">0</span>(SimpleDateTest.java:<span class="number">25</span>)</span><br><span class="line">at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:<span class="number">1736</span>)</span><br><span class="line">at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:<span class="number">1728</span>)</span><br><span class="line">at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:<span class="number">290</span>)</span><br><span class="line">at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:<span class="number">1020</span>)</span><br><span class="line">at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:<span class="number">1656</span>)</span><br><span class="line">at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:<span class="number">1594</span>)</span><br><span class="line">at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:<span class="number">183</span>)</span><br><span class="line">threadId = <span class="number">19</span> , 前 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span> , 后 = <span class="number">2022</span>-08-<span class="number">31</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">00</span></span><br><span class="line">threadId = <span class="number">16</span> , 前 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span> , 后 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span></span><br><span class="line">threadId = <span class="number">17</span> , 前 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span> , 后 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span></span><br><span class="line">threadId = <span class="number">15</span> , 前 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span> , 后 = <span class="number">2034</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span></span><br><span class="line">threadId = <span class="number">14</span> , 前 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span> , 后 = <span class="number">2022</span>-08-<span class="number">31</span> <span class="number">00</span>:<span class="number">41</span>:<span class="number">00</span></span><br><span class="line">threadId = <span class="number">18</span> , 前 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span> , 后 = <span class="number">2022</span>-09-<span class="number">11</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> StringBuffer <span class="title function_">format</span><span class="params">(Date date, StringBuffer toAppendTo,</span></span><br><span class="line"><span class="params">                            FieldDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// Convert input date to time field list</span></span><br><span class="line">    calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">useDateFormatSymbols</span> <span class="operator">=</span> useDateFormatSymbols();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; compiledPattern.length; ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> compiledPattern[i] &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> compiledPattern[i++] &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">255</span>) &#123;</span><br><span class="line">            count = compiledPattern[i++] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">            count |= compiledPattern[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> TAG_QUOTE_ASCII_CHAR:</span><br><span class="line">            toAppendTo.append((<span class="type">char</span>)count);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TAG_QUOTE_CHARS:</span><br><span class="line">            toAppendTo.append(compiledPattern, i, count);</span><br><span class="line">            i += count;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toAppendTo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，多个线程之间共享变量calendar，并修改calendar。</p><p>因此在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calendar.setTime(date)方法，导致time被别的线程修改，因此线程是不安全的。<br>此外，parse方法也是线程不安全的，parse方法实际调用的是CalenderBuilder的establish来进行解析，其方法中主要步骤不是原子操作。 想要避免，要不就<strong>加锁</strong>、要不就在方法内<strong>new SimpleDateFormat</strong>，或者使用<strong>ThreadLocal</strong>。推荐使用 <strong>Jdk 8 的DateTimeFormatter</strong> 的解决方式。</p><h2 id="1-2-解决方案"><a href="#1-2-解决方案" class="headerlink" title="1.2 解决方案"></a>1.2 解决方案</h2><ol><li>每个线程里直接new一个</li><li>使用synchronized，不推荐效率低</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//把SimpleDateFormat锁住</span></span><br><span class="line">            <span class="keyword">synchronized</span> (simpleDateFormat) &#123;</span><br><span class="line">                <span class="comment">//先获取当前时间的格式化字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//在通过格式化字符串再操作一次</span></span><br><span class="line">                    <span class="type">Date</span> <span class="variable">parseDate</span> <span class="operator">=</span> simpleDateFormat.parse(str1);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> simpleDateFormat.format(parseDate);</span><br><span class="line">                    <span class="comment">//对比前后格式化字符串是否一致</span></span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;threadId = %s , 前 = %s , 后 = %s&quot;</span>, Thread.currentThread().getId(), str1, str2));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用TreadLocal</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ThreadLocal&lt;SimpleDateFormat&gt; sdf = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//先获取当前时间的格式化字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> sdf.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在通过格式化字符串再操作一次</span></span><br><span class="line">                <span class="type">Date</span> <span class="variable">parseDate</span> <span class="operator">=</span> sdf.get().parse(str1);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> sdf.get().format(parseDate);</span><br><span class="line">                <span class="comment">//对比前后格式化字符串是否一致</span></span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;threadId = %s , 前 = %s , 后 = %s&quot;</span>, Thread.currentThread().getId(), str1, str2));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Spring中ThreadLocal的应用"><a href="#2-Spring中ThreadLocal的应用" class="headerlink" title="2. Spring中ThreadLocal的应用"></a>2. Spring中ThreadLocal的应用</h1><p>Spring中的bean不是单例模式吗？为什么那么多客户端访问同一个接口不会出现线程安全问题？<br>其实：</p><ol><li>spring单例模式指的是在内存中只实例化一个类的对象。确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</li><li>当多个用户同时请求一个接口服务的时候，容器会给每一个请求分配一个线程，这时候多个线程会并发执行该请求所对应的业务逻辑。如果该逻辑涉及到对该单例状态（成员变量）的改变，就会有线程安全的问题。</li><li>Spring使用ThreadLocal来解决线程安全问题，每个线程去执行业务代码的时候，都会去内存申请临时变量，这样就不会涉及变量并发访问冲突的问题。</li><li>一般的 Web 应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程。</li></ol><p><strong>那JVM是如何实现线程的独立内存空间？</strong></p><ul><li>每当启用一个线程时，JVM就为他分配一个Java栈，栈是以帧为单位保存当前线程的运行状态。某个线程正在执行的方法称为当前方法，当前方法使用的栈帧称为当前帧，当前方法所属的类称为当前类，当前类的常量池称为当前常量池。当线程执行一个方法时，它会跟踪当前常量池。</li><li>每当线程调用一个Java方法时，JVM就会在该线程对应的栈中压入一个帧，这个帧自然就成了当前帧。当执行这个方法时，它使用这个帧来存储参数、局部变量、中间运算结果等等。</li><li>Java栈上的所有数据都是私有的。任何线程都不能访问另一个线程的栈数据。所以我们不用考虑多线程情况下栈数据访问同步的情况。</li></ul><h1 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h1><h2 id="3-1-ThreadLocal是干什么的"><a href="#3-1-ThreadLocal是干什么的" class="headerlink" title="3.1 ThreadLocal是干什么的"></a>3.1 ThreadLocal是干什么的</h2><p>多线程访问<strong>同一个共享变量</strong>的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。**<code>ThreadLocal</code>是除了加锁这种同步方式之外的另一种保证多线程访问变量时的线程安全的方法<strong>；如果每个线程对变量的访问都是基于</strong>线程自己的变量**这样就不会存在线程不安全问题。</p><p>在Java的多线程编程中，为保证多个线程对共享变量的安全访问，通常会使用<code>synchronized</code>来保证同一时刻只有一个线程对共享变量进行操作。这种情况下其实还可以将变量放到<code>ThreadLocal</code>类型的对象中，使变量在每个线程中都有<strong>独立拷贝</strong>，<strong>在一个线程中对变量的任何操作都不会影响到其它线程的变量</strong>。在很多情况下，<code>ThreadLocal</code>比直接使用<code>synchronized</code>同步机制解决线程安全问题更简单，更方便，同时还能保证程序的性能。</p><h2 id="3-2-ThreadLocal的实现原理"><a href="#3-2-ThreadLocal的实现原理" class="headerlink" title="3.2 ThreadLocal的实现原理"></a>3.2 ThreadLocal的实现原理</h2><p>Java中的<code>ThreadLocal</code>是用哈希表实现的，每个线程里都有一个<code>ThreadLocalMap</code>属性，里面就以<code>Map</code>的形式存储了多个<code>ThreadLocal</code>对象。<strong>当在线程中调用<code>ThreadLocal</code>操作方法时，都会通过当前<code>Thread</code>线程对象拿到线程里的<code>ThreadLocalMap</code>，再通过<code>ThreadLocal</code>对象从<code>ThreadLocalMap</code>中锁定数据实体（<code>ThreadLocalMap.Entry</code>）</strong>。</p><h2 id="3-3-ThreadLocal中的基本方法"><a href="#3-3-ThreadLocal中的基本方法" class="headerlink" title="3.3 ThreadLocal中的基本方法"></a>3.3 ThreadLocal中的基本方法</h2><p><code>ThreadLocal</code>暴露了5个基本的操作和构造方法，主要的功能有：构造方法、设值方法、取值方法和资源回收；上面我们已经简单阐述了<code>ThreadLocal</code>的实现原理，这里我们再通过解析其中的代码来详细说说它是怎么做到线程隔离的。</p><h3 id="1-ThreadLocal构造方法"><a href="#1-ThreadLocal构造方法" class="headerlink" title="(1) ThreadLocal构造方法"></a>(1) ThreadLocal构造方法</h3><p><code>ThreadLocal</code>是一个泛型类，只提供了一个构造方法，通过泛型可以指定要存储的值的类型；这个构造方法通常可以单独使用，也可以配合<code>protected T initialValue()</code>方法 从而在实例化对象时提供一个初始值，因为这是一个<code>protected</code>方法，所以我们需要在实例化<code>ThreadLocal</code>对象时覆盖该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>; <span class="comment">// 这里设置期望的初始值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然这样未免太过繁琐了，代码也比较冗余！官方自然也考虑到了这一点，所以提供了一个静态的设置初始值的方法<code>withInitial</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有<code>Supplier</code>供给接口，这意味着我们可以使用如下方式设置初始值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadLocal</span>&lt;<span class="type">Long</span>&gt; threadLocal1 <span class="operator">=</span> <span class="type">ThreadLocal</span>.withInitial(() -&gt; 1L);</span><br></pre></td></tr></table></figure><p>这样的形式明显要优雅很多，但<code>SuppliedThreadLocal</code>又是个什么东西？其实它只是<code>ThreadLocal</code>类中一个简单的静态内部类罢了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 这里通过覆盖ThreadLocal的initialValue方法设置初始值</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> supplier.get(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-设值方法set"><a href="#2-设值方法set" class="headerlink" title="(2) 设值方法set"></a>(2) 设值方法set</h3><p>要保存的数据通过<code>set</code>方法设置，多次调用<code>set</code>方法并不会保存多个数据，而是发生覆盖，一个<code>ThreadLocal</code>正常只能保存一个数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t); <span class="comment">// 拿到当前线程中的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value); <span class="comment">// 线程中存在ThreadLocalMap，设值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value); <span class="comment">// 线程中不存在ThreadLocalMap，创建后再设值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-取值方法get"><a href="#3-取值方法get" class="headerlink" title="(3) 取值方法get"></a>(3) 取值方法get</h3><p>在没有使用<code>set</code>方法设值之前，调用<code>get</code>方法获取的将是<code>initialValue</code>方法设置的值（没有覆盖该方法返回就是<code>null</code>），否则返回的就是<code>set</code>方法设置的值。我们通过代码来解析其中的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t); <span class="comment">// 拿到当前线程保存的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>); <span class="comment">// 这里传入的this就是当前的ThreadLocal对象，拿到ThreadLocal对应的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value; <span class="comment">// 拿到ThreadLocal的值</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue(); <span class="comment">// 调用setInitialValue方法返回初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的<code>getMap(t)</code>方法返回当前线程的<code>ThreadLocalMap</code>类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.threadLocals; <span class="comment">// 返回线程中的ThreadLocalMap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>map.getEntry(this)</code>这里通过传入当前的<code>ThreadLocal</code>对象（线程<code>Thread</code>中有一个<code>ThreadLocalMap</code>类型属性，存储了多个<code>ThreadLocal</code>）拿到了<code>ThreadLocalMap.Entry</code>，它是<code>ThreadLocal</code>的静态内部类<code>ThreadLocalMap</code>的静态内部类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，其实<code>ThreadLocal</code>就是通过这个类以弱引用的方式与<code>value</code>绑定在了一起，通过<code>ThreadLocal</code>对象就能获取到对应<code>ThreadLocal</code>中存储的值。</p><p>在我们还没有使用<code>set</code>方法为<code>ThreadLocal</code>设置值的情况下，<code>get</code>方法会返回<code>setInitialValue</code>方法的值，可以看看这个方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue(); <span class="comment">// 这里获取初始值，如果我们有重写了initialValue方法的话就会返回设置的初始值</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value); <span class="comment">// 存在当前Thread对应的ThreadLocalMap，直接设值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value); <span class="comment">// 不存在当前Thread对应的ThreadLocalMap，为当前线程创建一个ThreadLocalMap并设值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面最主要的是<code>createMap</code>这个方法，它的作用是给传递的线程创建一个对应的<code>ThreadLocalMap</code>并把值存进去，可以看到新创建的<code>ThreadLocalMap</code>被赋值给了线程中的<code>threadLocals</code>变量，这也说明对应的数据都是存储在各个线程中的，所以每个线程对数据的操作自然不会影响其它线程的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line"><span class="comment">// this就是操作的ThreadLocal对象，firstValue就是要保存的值</span></span><br><span class="line">t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-资源回收remove"><a href="#4-资源回收remove" class="headerlink" title="(4) 资源回收remove"></a>(4) 资源回收remove</h3><p>当我们不再需要保存的数据时，应该通过<code>remove</code>方法将当前线程中保存的值移除掉使对象得到<code>GC</code>（调用<code>remove</code>方法将把<code>ThreadLocal</code>对象从当前线程的<code>ThreadLocalMap</code>移除）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread()); <span class="comment">// 拿到当前线程中的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="built_in">this</span>); <span class="comment">// 从ThreadLocalMap移除key为当前ThreadLocal对象的记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>remove</code>方法会清空使用<code>set</code>方法设置的值，此时如果再次调用了<code>get</code>方法，由于<code>ThreadLocal</code>对应的记录已经不存在，所以将会执行<code>return setInitialValue();</code>这段代码，这里将会调用<code>initialValue</code>方法从而返回初始值。</p><h2 id="3-4-ThreadLocal的使用"><a href="#3-4-ThreadLocal的使用" class="headerlink" title="3.4 ThreadLocal的使用"></a>3.4 ThreadLocal的使用</h2><p>最后我们再结合一个小栗子来解释<code>ThreadLocal</code>在多线程下的表现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 复写initialValue方法为ThreadLocal设置一个初始值，并获取调用了threadLocal的线程id</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前的线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// main方法就对应一个线程了，我们在主线程中对threadLocal的值进行修改</span></span><br><span class="line">        System.out.println(<span class="string">&quot;～～～～～～～～～～～～主线程～～～～～～～～～～～～～&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;在主线程中获取threadLocal的值：&quot;</span> + threadLocal.get());</span><br><span class="line">        threadLocal.set(<span class="number">100</span>); <span class="comment">// 改变threadLocal的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在主线程中再次获取threadLocal的值：&quot;</span> + threadLocal.get());</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;～～～～～～～～～～～～新线程～～～～～～～～～～～～～&quot;</span>);</span><br><span class="line">        <span class="comment">// 新创一个线程，并获取threadLocal的值</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;在新的线程中获取threadLocal的值：&quot;</span> + threadLocal.get())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们有一个静态的<code>threadLocal</code>变量，通过在<code>new</code>的时候覆盖<code>initialValue</code>方法（延迟加载，不会立即调用）为它设置了一个初始值10，并顺便在方法中输出使用<code>threadLocal</code>变量的线程的id，接着在获取了<code>threadLocal</code>的初始值后重新设置了一个数值100；在改变了<code>threadLocal</code>值的那个线程中确实看到了改变后的结果，然而在新线程中却有了“意料之外”的结果：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0a56750ec81eada101c9409cf1d5d911.png" alt="0a56750ec81eada101c9409cf1d5d911.png"></p><p>之所以会有这样的结果其实因为<code>ThreadLocal</code>是线程隔离的，我们看到的是在操作同一个变量，但是Java会为每一个线程都创建一个<code>threadLocal</code>的副本变量，每个线程操作的其实都是属于它的那个副本变量，而不是公共的那个<code>threadLocal</code>；每个线程对<code>threadLocal</code>的任何操作都不会影响到其它线程的<code>threadLocal</code>！</p><p>上面我们通过覆盖<code>initialValue</code>方法为<code>threadLocal</code>设置了一个默认值，如果不设置初始值，那么获取到的值就是<code>null</code>，这是<code>ThreadLocal</code>的初始化方法决定的；</p><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><p>其实<code>ThreadLocal</code>并没有那么的神秘莫测，但它在多线程编程中的地位却是毋庸置疑的，用好了<code>ThreadLocal</code>能够帮助你写出优雅简洁的多线程代码。在使用<code>synchronized</code>同步代码的时候，如果没法保证同步代码的（细）粒度，则会使得程序的性能下降，而使用<code>ThreadLocal</code>时完全不用考虑性能问题，因为没有了多线程的竞争，也就不用额外的同步判断等开销。总而言之，当<strong>遇到多线程操作同一个共享变量需要保证线程安全</strong>的时候，你应该首先考虑使用<code>ThreadLocal</code>而不是<code>synchronized</code>！</p>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁分类</title>
      <link href="/2022/09/01/48.java%E9%94%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/09/01/48.java%E9%94%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://cloud.tencent.com/developer/article/1953236">https://cloud.tencent.com/developer/article/1953236</a></p></blockquote><p>Java中锁分为以下几种：</p><ul><li>乐观锁、悲观锁</li><li>自旋锁、适应性自旋锁</li><li>锁升级(无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁) </li><li>公平锁、非公平锁</li><li>可重入锁</li><li>独享锁、共享锁</li><li>互斥锁、读写锁</li></ul><h1 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁 &amp; 悲观锁"></a>乐观锁 &amp; 悲观锁</h1><p>两种锁只是一种概念。</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h2 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h2><p><strong>概念</strong>：乐观锁认为一个线程去拿数据的时候不会有其他线程对数据进行更改，所以不会上锁。<strong>实现</strong>：CAS机制、版本号机制。以Atomic开头的包装类，例如<strong>AtomicBoolean</strong>，<strong>AtomicInteger</strong>，<strong>AtomicLong</strong>。</p><h2 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h2><p><strong>概念</strong>：悲观锁认为一个线程去拿数据时一定会有其他线程对数据进行更改。所以一个线程在拿数据的时候都会顺便加锁，这样别的线程此时想拿这个数据就会阻塞。</p><p><strong>实现</strong>：加锁。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>Synchronized关键字会让没有得到锁资源的线程进入<strong>BLOCKED</strong>状态，而后在争夺到锁资源后恢复为<strong>RUNNABLE</strong>状态，这个过程中涉及到操作系统<strong>用户模式</strong>和<strong>内核模式</strong>的转换，代价比较高。</p><p>尽管Java1.6为Synchronized做了优化，增加了从<strong>偏向锁</strong>到<strong>轻量级锁</strong>再到<strong>重量级锁</strong>的过度，但是在最终转变为重量级锁之后，性能仍然较低。</p><h1 id="行锁与表锁"><a href="#行锁与表锁" class="headerlink" title="行锁与表锁"></a>行锁与表锁</h1><p>当执行 <code>select ... for update</code>时，将会把数据锁住，因此，我们需要注意一下锁的级别。MySQL InnoDB 默认为行级锁。当查询语句指定了主键时，MySQL会执行「行级锁」，否则MySQL会执行「表锁」。</p><p>常见情况如下：</p><ul><li>若明确指明主键，且结果集有数据，行锁；</li><li>若明确指明主键，结果集无数据，则无锁；</li><li>若无主键，且非主键字段无索引，则表锁；</li><li>若使用主键但主键不明确，则使用表锁；</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_user <span class="keyword">where</span> id&lt;&gt;<span class="number">1</span> <span class="keyword">for</span> update; </span><br></pre></td></tr></table></figure><p><strong>小结：</strong> innoDB的行锁是通过给索引上的索引项加锁实现的，因此，只有通过索引检索数据，才会采用行锁，否则使用的是表锁。</p><h1 id="线程嵌套造成死锁"><a href="#线程嵌套造成死锁" class="headerlink" title="线程嵌套造成死锁"></a>线程嵌套造成死锁</h1><p><strong>一个死锁问题的分析</strong></p><p>现象：当同时送入线程池的任务大于配置core-size时，会引起程序死锁。<br>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建i个nestedCall任务,送入线程池</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">taskExecutor</span> <span class="operator">=</span> taskExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            taskExecutor.submit(() -&gt; outerCall(taskExecutor, finalI));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;task push over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 先睡2s，再将一个任务送入线程池，再等待其完成</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outerCall</span><span class="params">(Executor taskExecutor, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;outer &quot;</span> + i);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">nestedCall(latch, i);</span><br><span class="line">            &#125;);</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//这个里层的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nestedCall</span><span class="params">(CountDownLatch latch, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;nested &quot;</span> + i);</span><br><span class="line">                latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolTaskExecutor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">6</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">12</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">30</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(rejectedExecutionHandler());</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">30</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RejectedExecutionHandler <span class="title function_">rejectedExecutionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (r, executor) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executor.getQueue().put(r);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果运行main方法会产生什么结果呢，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task push over</span><br><span class="line">outer 0</span><br><span class="line">outer 1</span><br><span class="line">outer 2</span><br></pre></td></tr></table></figure><p>不会再有新的输出了，程序已经死锁。<br>为什么呢？<br>我们来看线程池里边发生的事情（数字的顺序可能是乱的，这里只是其中一种情况）：</p><ol><li>执行outerCall i&#x3D;0</li><li>执行outerCall i&#x3D;1</li><li>执行outerCall i&#x3D;2</li><li>送入等待队列 nestedCall i&#x3D;0</li><li>送入等待队列 nestedCall i&#x3D;1</li><li>送入等待队列 nestedCall i&#x3D;2</li></ol><p>outerCall的执行占据了所有的活动线程（3个），等待nestedCall完成。然而nestedCall在当前线程池的等待队列中如果outerCall不退出，他永远也得不到执行的机会，死锁了。</p><p><strong>结论</strong></p><p>在使用java线程池的时候要特别注意最好不要有这种<strong>嵌套</strong>的任务。如果有这种嵌套使用线程池的情况的话一定要保证外层的线程不会等待内层线程完成再返回，或者为等待添加超时时间</p><h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><p><a href="https://blog.csdn.net/weixin_60272582/article/details/123265596">https://blog.csdn.net/weixin_60272582/article/details/123265596</a></p><p><img src="https://img-blog.csdnimg.cn/16d6679a2a0b4a2285f0954bdccc2925.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATXIu57Gz5pav54m55YS_6LW1,size_15,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>是不是吓一跳,下面我们来一项一项说明各种锁的概念以及使用</p><h2 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1.乐观锁"></a>1.乐观锁</h2><p>乐观锁顾名思义就是一种乐观的思想,认为读数据时没有别的线程进行过修改,所以不会上锁,写数据时判断当前与期望的值是否相同,如果相同进行更新(更新期间是要枷锁的,为了保证<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&spm=1001.2101.3001.7020">原子性</a>)</p><p>举例:java中的乐观锁—<a href="https://so.csdn.net/so/search?q=CAS&spm=1001.2101.3001.7020">CAS</a></p><p>​        CAS的使用以及CAS<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020">原子操作</a>面临的问题,以及解决方案</p><p>​        CAS的详细内容请参考</p><p><a href="https://blog.csdn.net/weixin_60272582/article/details/123164851?spm=1001.2014.3001.5501">多线程常见面试题总结(简单版)_Mr.米斯特儿赵的博客-CSDN博客</a> 第17个回答</p><h2 id="2-悲观锁"><a href="#2-悲观锁" class="headerlink" title="2.悲观锁"></a>2.悲观锁</h2><p>  悲观锁顾名思义就是一种悲观的思想,每次拿数据都会悲观的认为其他线程修改了数据,所以每次读写时都会上锁,其他线程想要读写这个数据时,就会被该线程阻塞 ,直到这个线程释放锁.</p><p>举例: java中的悲观锁 synchronized修饰的方法和方法块 比如我们尝试用的hashtable,以及StringBuffer他们的方法都被synchronized修饰,ReentrantLock不仅悲观还重入(也属于重入锁)</p><h2 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3.自旋锁"></a>3.自旋锁</h2><p>自旋锁就是在获取锁的时候，如果锁被其他线程获取,该线程就会一直循环等待,一直尝试着去获取锁,直到目标达成。而不像普通的锁那样，如果获取不到锁就进入阻塞</p><p>自旋锁的优点: 避免了线程切换的开销,不会使线程进入阻塞的状态,减少了不必要的上下文的切换,执行速度块</p><p>自旋锁的缺点: 长时间占用处理器,会白白消耗 处理器资源,却没有干任何事情,性能浪费，所以自旋等待的时间必须有一定的限度 超过限度就挂起 线程</p><p>自旋默认的次数: 10次</p><h2 id="4-可重入锁-递归锁"><a href="#4-可重入锁-递归锁" class="headerlink" title="4.可重入锁(递归锁)"></a>4.可重入锁(递归锁)</h2><p>可重入锁使一种技术,任意线程在获取到 锁之后能够再次 获取 该锁而不会被锁阻塞</p><p>原理 : 通过组合自定义同步器来实现锁的获取和释放</p><p>再次获取锁: 识别获取 锁的线程是否为当前占据锁的线程,如果是,则再次成功获取,获取锁后,进行计数自增</p><p>释放锁: 释放锁 进行计数自减</p><p>java中的可重入锁:</p><p>ReentrantLock、synchronized修饰的方法或代码段</p><h2 id="5-读写锁"><a href="#5-读写锁" class="headerlink" title="5.读写锁"></a>5.读写锁</h2><p>读写锁使一种技术,通过ReentrantReadWriteLock类来实现的,为了提高性能,Java提供了读写锁,读的地方使用 读锁,写的地方使用写锁,在没有写锁的情况下,读锁是无阻塞的,多个读锁不互斥,读锁与写锁互斥,这是由jvm来控制的</p><p>读锁:  允许线程获取读锁,同时访问一个资源</p><p>写锁:  允许一个线程获取 写锁,不允许 同时访问一个资源</p><p>如何使用:<br>1.创建一个读写锁<br>ReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();</p><p>2.获取读锁和释放锁<br>&#x2F;&#x2F; 获取读锁rwLock.readLock().lock();&#x2F;&#x2F; 释放读锁rwLock.readLock().unlock();</p><p>3.获取写锁和释放锁<br>创建一个写锁rwLock.writeLock().lock();&#x2F;&#x2F; 写锁 释rwLock.writeLock().unlock()</p><h2 id="6-公平锁"><a href="#6-公平锁" class="headerlink" title="6.公平锁"></a>6.公平锁</h2><p>公平锁使一种思想,多个线程按照顺序来获取锁 ,并发环境中,每个线程会去查看锁的维护队列,如果队列为空,就占有锁,如果队列不为空,就加入等待队列的末尾,按照FIFO原则获取锁</p><h2 id="7-非公平锁"><a href="#7-非公平锁" class="headerlink" title="7.非公平锁"></a>7.非公平锁</h2><p>非公平锁也是一种思想,线程尝试获取锁,如果获取不到,按照公平锁的方式,多个线程获取锁不是按照 先到先得的顺序.是无序的,有可能后到了先获取到锁</p><p>优点:    比公平锁性能高</p><p>缺点:    线程 饥饿(某个线程很长一段时间获取不到锁)</p><p>举例:    synchronized是非公平锁  </p><p><strong>ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的。</strong></p><h2 id="8-共享锁"><a href="#8-共享锁" class="headerlink" title="8.共享锁"></a>8.共享锁</h2><p>共享锁是一种思想,可以多个线程获取读锁,以共享的方式持有锁,和乐观锁还有读写锁同义</p><h2 id="9-独占锁"><a href="#9-独占锁" class="headerlink" title="9.独占锁"></a>9.独占锁</h2><p>独占锁是一种思想,只能有一个线程获取锁,以独有的方式持有锁,悲观锁和互斥锁同义</p><p>synchronized，ReentrantLock</p><h2 id="10-重量级锁"><a href="#10-重量级锁" class="headerlink" title="10.重量级锁"></a>10.重量级锁</h2><p>synchronized 就是重量级锁,为了优化重量级锁,引入了轻量级锁和偏向锁</p><h2 id="11-轻量级锁"><a href="#11-轻量级锁" class="headerlink" title="11.轻量级锁"></a>11.轻量级锁</h2><p> <strong>jdk6是加入的一种锁的优化机制</strong>,轻量级锁是在没有多线程竞争的情况下使用的CAS操作去消除同步使用的互斥量 </p><p>上面理解起来很吃力,解析一下,首先是没有竞争,也就是说是单线程 ,两条以上线程,轻量级锁不会生效</p><h2 id="12-偏向锁"><a href="#12-偏向锁" class="headerlink" title="12.偏向锁"></a>12.偏向锁</h2><p><strong>偏向锁 是JDK6时加入的一种锁优化机制：</strong> 在无竞争的情况下把整个同步都消除掉,连CAS操作都不去做了。偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作.</p><h2 id="13-分段锁"><a href="#13-分段锁" class="headerlink" title="13.分段锁"></a>13.分段锁</h2><p>是一种机制,是不是想到了ConcurrentHashMap了,默认情况下ConcurrentHashMap被细分为16个段(Segment)每次上锁只是锁的每个segment. segment通过继承ReentrntLock来进行加锁,只要保证每个segment是线程安全的,是不是就保证了全局的线程安全.</p><h2 id="14-互斥锁"><a href="#14-互斥锁" class="headerlink" title="14.互斥锁"></a>14.互斥锁</h2><p>互斥锁和悲观锁还有独占锁同义,某个资源,只能被一个线程访问,其他线程不能访问.</p><p>例如上文提到的读写锁中的写锁,写与写之间是互斥的,写与读之间也是互斥的</p><h2 id="15-同步锁"><a href="#15-同步锁" class="headerlink" title="15.同步锁"></a>15.同步锁</h2><p>与互斥锁同义,字并发执行多个线程时,在同一时间只允许一个线程访问共享数据  synchronized</p><p><a href="https://download.csdn.net/download/weixin_38632006/12808349">Java锁之阻塞锁介绍和代码实例pdf<img src="https://csdnimg.cn/release/blogv2/dist/components/img/star.png" alt="img">0星超过10%的资源47KB<img src="https://csdnimg.cn/release/blogv2/dist/components/img/arrowDownWhite.png" alt="img">下载</a></p><h2 id="16-死锁"><a href="#16-死锁" class="headerlink" title="16.死锁"></a>16.死锁</h2><p><strong>死锁是一种现象：</strong> 如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获</p><p>取不到对方的资源，就会造成死锁。</p><p>Java中的死锁不能自行打破，所以线程死锁后，线程不能进行响应。所以一定要注意</p><p>程序的并发场景，避免造成死锁。</p><h2 id="17-synchronized-简单总结"><a href="#17-synchronized-简单总结" class="headerlink" title="17.synchronized(简单总结)"></a>17.synchronized(简单总结)</h2><p>synchronized是java中的关键字,用来修饰方法,对象实例,属于独占锁,悲观锁,可重入锁,非公平锁</p><p>用于实例方法时,锁住的是对象的实例也就是this</p><p>用于静态方法上,锁主的是Class类</p><h2 id="18-Lock和synchronized的区别"><a href="#18-Lock和synchronized的区别" class="headerlink" title="18.Lock和synchronized的区别"></a>18.Lock和synchronized的区别</h2><p>lock 是java中的接口,是可重入锁,悲观锁,独占锁,互斥锁,同步锁</p><p>lock 需要手动获取锁和释放锁</p><p>lock 是一个接口,synchronized是关键字</p><p>synchronized发生异常会自动释放锁,不会导致死锁现象,而lock发生异常如果没有unlock()释放锁,就有可能产生死锁,一般使用lock锁的时候,需要在finally中进行释放锁</p><p>lock锁可以使等待的线程响应中断,而synchronized不会,会一直等待下去</p><h2 id="19-ReentrantLock-和synchronized的区别"><a href="#19-ReentrantLock-和synchronized的区别" class="headerlink" title="19.ReentrantLock 和synchronized的区别"></a>19.ReentrantLock 和synchronized的区别</h2><p>Reentrantlock是java中的类,继承了lock类,是可重入锁,悲观锁,独占锁,互斥锁,同步锁</p><p>相同点:    主要解决共享变量如何访问的问题</p><p>都是可重入锁,同一线程可以多次获取锁</p><p>保证了线程安全的两大特性  可见性  原子性</p><p>不同点: </p><ol><li>ReentrantLock 就像手动汽车，需要显示的调用lock和unlock方法,synchronized 隐式获得释放锁。</li><li>ReentrantLock 可响应中断， synchronized 是不可以响应中断的ReentrantLock 为处理锁的不可用性提供了更高的灵活性</li><li>ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的</li><li>ReentrantLock 可以实现公平锁、非公平锁，默认非公平锁，synchronized 是非公平锁，且不可更改。</li><li>ReentrantLock 通过 Condition 可以绑定多个条件</li></ol>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Sql记录</title>
      <link href="/2022/09/01/50.%E5%B8%B8%E7%94%A8Sql%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/09/01/50.%E5%B8%B8%E7%94%A8Sql%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">找出前缀为qr的所有数据库</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">CONCAT(<span class="string">&#x27;drop table &#x27;</span>,table_name,<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">information_schema. TABLES</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">table_name <span class="keyword">LIKE</span> <span class="string">&#x27;qr_%&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="mysql不同时间粒度下的分组统计"><a href="#mysql不同时间粒度下的分组统计" class="headerlink" title="mysql不同时间粒度下的分组统计"></a>mysql不同时间粒度下的分组统计</h1><p>我们在做项目或者数据分析时，经常遇到这样的需求：统计不同时间粒度下的数据分布情况，例如，每一天中每个小时网站的访问量，某路口每半个小时通过的车辆数量等。对于此类的问题，一个sql简单的查询就能实现，故特此记录下，方便以后使用。<br>在MySQL中，我的表为：track<br>数据结构如下所示：<br><img src="https://img-blog.csdnimg.cn/20181105163738204.png" alt="表track的数据结构示意"></p><h2 id="按天统计"><a href="#按天统计" class="headerlink" title="按天统计"></a>按天统计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">DATE</span>(TimeStart) <span class="keyword">AS</span> <span class="type">date</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> track</span><br><span class="line"><span class="keyword">WHERE</span> Flag <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> Duration <span class="operator">&gt;=</span> <span class="number">300</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">date</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">date</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="按小时统计"><a href="#按小时统计" class="headerlink" title="按小时统计"></a>按小时统计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(TimeStart, <span class="string">&#x27;%Y-%m-%d %H:00:00&#x27;</span>) <span class="keyword">AS</span> <span class="type">time</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> track</span><br><span class="line"><span class="keyword">WHERE</span> Flag <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> Duration <span class="operator">&gt;=</span> <span class="number">300</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/20181105164437450.png" alt="一小时结果"></p><h2 id="按半小时统计"><a href="#按半小时统计" class="headerlink" title="按半小时统计"></a>按半小时统计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">time</span>, <span class="built_in">COUNT</span>( <span class="operator">*</span> ) <span class="keyword">AS</span> num </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> Duration,</span><br><span class="line">DATE_FORMAT(</span><br><span class="line">concat( <span class="type">date</span>( TimeStart ), <span class="string">&#x27; &#x27;</span>, <span class="keyword">HOUR</span> ( TimeStart ), <span class="string">&#x27;:&#x27;</span>, <span class="built_in">floor</span>( <span class="keyword">MINUTE</span> ( TimeStart ) <span class="operator">/</span> <span class="number">30</span> ) <span class="operator">*</span> <span class="number">30</span> ),</span><br><span class="line"><span class="string">&#x27;%Y-%m-%d %H:%i&#x27;</span> </span><br><span class="line">) <span class="keyword">AS</span> <span class="type">time</span> </span><br><span class="line"><span class="keyword">FROM</span> tarck</span><br><span class="line"><span class="keyword">WHERE</span> Flag <span class="operator">=</span> <span class="number">0</span>  <span class="keyword">AND</span> Duration <span class="operator">&gt;=</span> <span class="number">300</span> </span><br><span class="line">) a </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> DATE_FORMAT( <span class="type">time</span>, <span class="string">&#x27;%Y-%m-%d %H:%i&#x27;</span> ) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/20181105164102966.png" alt="半小时查询结果"></p><h2 id="按N分钟统计"><a href="#按N分钟统计" class="headerlink" title="按N分钟统计"></a>按N分钟统计</h2><p>将上面的<a href="https://so.csdn.net/so/search?q=SQL%E8%AF%AD%E5%8F%A5&spm=1001.2101.3001.7020">SQL语句</a>稍微修改下，就可以实现按任意N分钟为时间片的分组统计，如按10分钟统计，先上代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">time</span>, <span class="built_in">COUNT</span>( <span class="operator">*</span> ) <span class="keyword">AS</span> num </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> Duration,</span><br><span class="line">DATE_FORMAT(</span><br><span class="line">concat( <span class="type">date</span>( TimeStart ), <span class="string">&#x27; &#x27;</span>, <span class="keyword">HOUR</span> ( TimeStart ), <span class="string">&#x27;:&#x27;</span>, <span class="built_in">floor</span>( <span class="keyword">MINUTE</span> ( TimeStart ) <span class="operator">/</span> <span class="number">10</span> ) <span class="operator">*</span> <span class="number">10</span> ),</span><br><span class="line"><span class="string">&#x27;%Y-%m-%d %H:%i&#x27;</span> </span><br><span class="line">) <span class="keyword">AS</span> <span class="type">time</span> </span><br><span class="line"><span class="keyword">FROM</span> tarck</span><br><span class="line"><span class="keyword">WHERE</span> Flag <span class="operator">=</span> <span class="number">0</span>  <span class="keyword">AND</span> Duration <span class="operator">&gt;=</span> <span class="number">300</span> </span><br><span class="line">) a </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> DATE_FORMAT( <span class="type">time</span>, <span class="string">&#x27;%Y-%m-%d %H:%i&#x27;</span> ) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本思路：<br>将datetime类型的时间转化为相应时间片的时间，例如将‘2017-03-01 01:08:19’ 转化为‘2017-03-01 01:00:00’，然后group by即可。</p><h2 id="按分钟统计"><a href="#按分钟统计" class="headerlink" title="按分钟统计"></a>按分钟统计</h2><p>将按小时统计的SQL语句稍微修改下，就可以实现按分钟统计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(TimeStart, <span class="string">&#x27;%Y-%m-%d %H:%i:00&#x27;</span>) <span class="keyword">AS</span> <span class="type">time</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> track </span><br><span class="line"><span class="keyword">WHERE</span> Flag <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> Duration <span class="operator">&gt;=</span> <span class="number">300</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DATE_FORMAT功能强大，可以根据format字符串格式化date值，参考下面链接<br><a href="http://www.w3school.com.cn/sql/func_date_format.asp">http://www.w3school.com.cn/sql/func_date_format.asp</a></p>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现Serializable接口的作用</title>
      <link href="/2022/08/28/49.Serializable%E4%BD%9C%E7%94%A8/"/>
      <url>/2022/08/28/49.Serializable%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/390884501">https://zhuanlan.zhihu.com/p/390884501</a></p><p>这个问题说的不清楚，集合类<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>中的接口没有实现Cloneable和Serializable接口，但是具体的实现类是实现了这些接口的，比如Arraylist。</p><p>接口，比如<a href="https://so.csdn.net/so/search?q=collection&spm=1001.2101.3001.7020">collection</a> list iterable</p><p>克隆（cloning）或者<a href="https://so.csdn.net/so/search?q=%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">序列化</a>（serialization）的予以和含义是根具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p><p>实现<a href="https://so.csdn.net/so/search?q=Serializable&spm=1001.2101.3001.7020">Serializable</a>序列化的作用：将对象状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按置将对象从一个应用程序域发送到另一个应用程序域。</p><p>实现Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果不需要分布式应用就没必要实现序列化。</p><p>java如果用json传输数据javabean时许需要实现Serializable</p><p><strong>个人观点：我写的应用中不需要实现Serializable因为我使用了json数据格式。</strong></p><p><strong>结论</strong>：java如果使用json+restfulAPI进行数据交互那么javabean不需要implements Serializable接口因为对象数据并没有真正的进行网络传输或者持久化。而是转换为了json字符串。进行网络传输的是对象的具体信息而不是对象本身。所以在这种场景下不需要implements Serializable。</p><p>如果使用dubbo这种RPC（Remote Procedure Call）框架那么使用面向接口编程的时候，接口中的参数如果是类那么该类就必须implements Serializable才可以让对象在远程调用的时候在网络上传输。</p><p><strong>javabean为什么不implements Serializable也可以保存到数据库中</strong></p><p>不是说数据持久化就必须implements Serializable接口么</p><p>原因：</p><p>Java的基本数据类型（primitive：short int long float double byte char boolean）在数据库中都有对应的字段。一些Java的集合具体实现类也都实现了Serializable接口。那么JavaBean此时不实现该接口也可以存储到数据库中</p><p><strong>序列化绝对不止实现Serializable接口一种方式。还存在其他序列化方式可能效率更高。但是稳定性肯定是Serializable最好。因为该接口从Java1.1开始就存在并且一直保持使用</strong></p><p><a href="https://github.com/eishay/jvm-serializers/wiki">https://github.com/eishay/jvm-serializers/wiki</a></p><p>序列化存储到本地，若从存储介质中读取数据字节流并反序列化的时候并不会调用类的构造函数</p><h3 id="一、序列化的含义、意义及使用场景"><a href="#一、序列化的含义、意义及使用场景" class="headerlink" title="一、序列化的含义、意义及使用场景"></a>一、序列化的含义、意义及使用场景</h3><ul><li><strong>序列化：将对象写入到IO流中</strong></li><li><strong>反序列化：从IO流中恢复对象</strong></li><li><strong>意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。</strong></li><li><strong>使用场景：所有可在网络上传输的对象都必须是可序列化的，</strong>比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；<strong>所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。</strong></li></ul><h3 id="二、序列化实现的方式"><a href="#二、序列化实现的方式" class="headerlink" title="二、序列化实现的方式"></a>二、序列化实现的方式</h3><p>如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口之一。</p><h4 id="1、Serializable"><a href="#1、Serializable" class="headerlink" title="1、Serializable"></a>1、Serializable</h4><h5 id="1-1-普通序列化"><a href="#1-1-普通序列化" class="headerlink" title="1.1 普通序列化"></a>1.1 普通序列化</h5><p>Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。</p><ol><li><strong>序列化步骤：</strong></li></ol><ul><li><p><strong>步骤一：创建一个ObjectOutputStream输出流；</strong></p></li><li><p><strong>步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">  <span class="keyword">private</span> int age;</span><br><span class="line">  <span class="comment">//我不提供无参构造器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">Person</span>(<span class="title class_">String</span> name, int age) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">              <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">              <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">              <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteObject</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> (<span class="comment">//创建一个ObjectOutputStream输出流</span></span><br><span class="line">           <span class="title class_">ObjectOutputStream</span> oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.txt&quot;</span>))) &#123;</span><br><span class="line">          <span class="comment">//将对象序列化到文件s</span></span><br><span class="line">          <span class="title class_">Person</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>);</span><br><span class="line">          oos.<span class="title function_">writeObject</span>(person);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">          e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>反序列化步骤：</strong></li></ol><ul><li><p><strong>步骤一：创建一个ObjectInputStream输入流；</strong></p></li><li><p><strong>步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。</strong></p><p>我们将上面序列化到person.txt的person对象反序列化回来</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">  <span class="keyword">private</span> int age;</span><br><span class="line">  <span class="comment">//我不提供无参构造器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">Person</span>(<span class="title class_">String</span> name, int age) &#123;</span><br><span class="line">      <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;反序列化，你调用我了吗？&quot;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">              <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">              <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">              <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadObject</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> (<span class="comment">//创建一个ObjectInputStream输入流</span></span><br><span class="line">           <span class="title class_">ObjectInputStream</span> ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">          <span class="title class_">Person</span> brady = (<span class="title class_">Person</span>) ois.<span class="title function_">readObject</span>();</span><br><span class="line">          <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(brady);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">          e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;9龙&#x27;, age=23&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>waht????    输出告诉我们，反序列化并不会调用构造方法。反序列的对象是由JVM自己生成的对象，不通过构造方法生成。</strong></p></li></ul><h5 id="1-2-成员是引用的序列化"><a href="#1-2-成员是引用的序列化" class="headerlink" title="1.2 成员是引用的序列化"></a>1.2 成员是引用的序列化</h5><p><strong>如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。</strong></p><p>看例子，我们新增一个Teacher类。将Person去掉实现Serializable接口代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//省略相关属性与方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, Person person)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;路飞&quot;</span>, <span class="number">20</span>);</span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;雷利&quot;</span>, person);</span><br><span class="line">            oos.writeObject(teacher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/21/16ad9dbc177d9abb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>我们看到程序直接报错，因为Person类的对象是不可序列化的，这导致了Teacher的对象不可序列化</p><h5 id="1-3-同一对象序列化多次的机制"><a href="#1-3-同一对象序列化多次的机制" class="headerlink" title="1.3 同一对象序列化多次的机制"></a>1.3 同一对象序列化多次的机制</h5><p><strong>同一对象序列化多次，会将这个对象序列化多次吗？</strong>答案是<strong>否定</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteTeacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;路飞&quot;</span>, <span class="number">20</span>);</span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;雷利&quot;</span>, person);</span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;红发香克斯&quot;</span>, person);</span><br><span class="line">            <span class="comment">//依次将4个对象写入输入流</span></span><br><span class="line">            oos.writeObject(t1);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>依次将t1、t2、person、t2对象序列化到文件teacher.txt文件中。</p><p><strong>注意：反序列化的顺序与序列化时的顺序一致</strong>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ReadTeacher &#123;</span><br><span class="line">    public static void main(String<span class="section">[]</span> args) &#123;</span><br><span class="line">        try (ObjectInputStream <span class="attr">ois</span> = new ObjectInputStream(new FileInputStream(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            Teacher <span class="attr">t1</span> = (Teacher) ois.readObject()<span class="comment">;</span></span><br><span class="line">            Teacher <span class="attr">t2</span> = (Teacher) ois.readObject()<span class="comment">;</span></span><br><span class="line">            Person <span class="attr">p</span> = (Person) ois.readObject()<span class="comment">;</span></span><br><span class="line">            Teacher <span class="attr">t3</span> = (Teacher) ois.readObject()<span class="comment">;</span></span><br><span class="line">            System.out.println(<span class="attr">t1</span> == t2)<span class="comment">;</span></span><br><span class="line">            System.out.println(t1.getPerson() == p)<span class="comment">;</span></span><br><span class="line">            System.out.println(t2.getPerson() == p)<span class="comment">;</span></span><br><span class="line">            System.out.println(<span class="attr">t2</span> == t3)<span class="comment">;</span></span><br><span class="line">            System.out.println(t1.getPerson() == t2.getPerson())<span class="comment">;</span></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">//false</span><br><span class="line">//true</span><br><span class="line">//true</span><br><span class="line">//true</span><br><span class="line">//true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，<strong>Java序列化同一对象，并不会将此对象序列化多次得到多个对象。</strong></p><ul><li><strong>Java序列化算法</strong></li></ul><ol><li><p><strong>所有保存到磁盘的对象都有一个序列化编码号</strong></p></li><li><p><strong>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</strong></p></li><li><p><strong>如果此对象已经序列化过，则直接输出编号即可。</strong></p><p>图示上述序列化过程。</p></li></ol><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/21/16ad9dbc1863188b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h5 id="1-4-java序列化算法潜在的问题"><a href="#1-4-java序列化算法潜在的问题" class="headerlink" title="1.4 java序列化算法潜在的问题"></a>1.4 java序列化算法潜在的问题</h5><p>由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。<strong>如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class WriteObject &#123;</span><br><span class="line">    public static void main(String<span class="section">[]</span> args) &#123;</span><br><span class="line">        try (ObjectOutputStream <span class="attr">oos</span> = new ObjectOutputStream(new FileOutputStream(<span class="string">&quot;person.txt&quot;</span>))<span class="comment">;</span></span><br><span class="line">             ObjectInputStream <span class="attr">ios</span> = new ObjectInputStream(new FileInputStream(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">            //第一次序列化person</span><br><span class="line">            Person <span class="attr">person</span> = new Person(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>)<span class="comment">;</span></span><br><span class="line">            oos.writeObject(person)<span class="comment">;</span></span><br><span class="line">            System.out.println(person)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">            //修改name</span><br><span class="line">            person.setName(&quot;海贼王&quot;)<span class="comment">;</span></span><br><span class="line">            System.out.println(person)<span class="comment">;</span></span><br><span class="line">            //第二次序列化person</span><br><span class="line">            oos.writeObject(person)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">            //依次反序列化出p1、p2</span><br><span class="line">            Person <span class="attr">p1</span> = (Person) ios.readObject()<span class="comment">;</span></span><br><span class="line">            Person <span class="attr">p2</span> = (Person) ios.readObject()<span class="comment">;</span></span><br><span class="line">            System.out.println(<span class="attr">p1</span> == p2)<span class="comment">;</span></span><br><span class="line">            System.out.println(p1.getName().equals(p2.getName()))<span class="comment">;</span></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">//Person&#123;<span class="attr">name</span>=<span class="string">&#x27;9龙&#x27;</span>, age=<span class="number">23</span>&#125;</span><br><span class="line">//Person&#123;<span class="attr">name</span>=<span class="string">&#x27;海贼王&#x27;</span>, age=<span class="number">23</span>&#125;</span><br><span class="line">//true</span><br><span class="line">//true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="1-5-可选的自定义序列化"><a href="#1-5-可选的自定义序列化" class="headerlink" title="1.5 可选的自定义序列化"></a>1.5 可选的自定义序列化</h5><ol><li><p>有些时候，我们有这样的需求，某些属性不需要序列化。<strong>使用transient关键字选择不需要序列化的字段。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">   <span class="comment">//不需要序列化名字与年龄</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">boolean</span> singlehood;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//省略get,set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransientTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ios</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">           <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>);</span><br><span class="line">           person.setHeight(<span class="number">185</span>);</span><br><span class="line">           System.out.println(person);</span><br><span class="line">           oos.writeObject(person);</span><br><span class="line">           <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person)ios.readObject();</span><br><span class="line">           System.out.println(p1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;9龙&#x27;, age=23&#x27;, singlehood=true&#x27;, height=185cm&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;null&#x27;, age=0&#x27;, singlehood=false&#x27;, height=185cm&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从输出我们看到，<strong>使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。</strong></p></li><li><p>使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了<strong>可选的自定义序列化。</strong>可以进行控制序列化的方式，或者对序列化数据进行编码加密等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException；</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectIutputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过重写writeObject与readObject方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象。这里展示对名字进行反转加密。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">   <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span>(<span class="params">ObjectOutputStream <span class="keyword">out</span></span>) throws IOException</span> &#123;</span><br><span class="line">       <span class="comment">//将名字反转写入二进制流</span></span><br><span class="line">       <span class="keyword">out</span>.writeObject(<span class="keyword">new</span> StringBuffer(<span class="keyword">this</span>.name).reverse());</span><br><span class="line">       <span class="keyword">out</span>.writeInt(age);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span>(<span class="params">ObjectInputStream ins</span>) throws IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">       <span class="comment">//将读出的字符串反转恢复回来</span></span><br><span class="line">       <span class="keyword">this</span>.name = ((StringBuffer)ins.readObject()).reverse().toString();</span><br><span class="line">       <span class="keyword">this</span>.age = ins.readInt();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当序列化流不完整时，readObjectNoData()方法可以用来正确地初始化反序列化的对象。例如，使用不同类接收反序列化对象，或者序列化流被篡改时，系统都会调用readObjectNoData()方法来初始化反序列化的对象。</p></li><li><p><strong>更彻底的自定义序列化</strong></p><p>ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;<br>  ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;</p><ul><li><p><strong>writeReplace：在序列化时，会先调用此方法，再调用writeObject方法。此方法可将任意对象代替目标序列化对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">      ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">      list.add(<span class="built_in">this</span>.name);</span><br><span class="line">      list.add(<span class="built_in">this</span>.age);</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">           <span class="type">ObjectInputStream</span> <span class="variable">ios</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">          <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>);</span><br><span class="line">          oos.writeObject(person);</span><br><span class="line">          <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> (ArrayList)ios.readObject();</span><br><span class="line">          System.out.println(list);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//[9龙, 23]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p><strong>readResolve：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在readeObject后调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line">     <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> (<span class="string">&quot;brady&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">ios</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> (HashMap)ios.readObject();</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//&#123;brady=23&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>readResolve常用来反序列单例类，保证单例类的唯一性。</strong></p><p><strong>注意：readResolve与writeReplace的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于final修饰的类重写readResolve方法没有问题；否则，重写readResolve使用private修饰。</strong></p></li></ul></li></ol><h4 id="2、Externalizable：强制自定义序列化"><a href="#2、Externalizable：强制自定义序列化" class="headerlink" title="2、Externalizable：强制自定义序列化"></a>2、Externalizable：强制自定义序列化</h4><p>通过实现Externalizable接口，必须实现writeExternal、readExternal方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExPerson</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//注意，必须加上pulic 无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExPerson</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//将name反转后写入二进制流</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(name).reverse();</span><br><span class="line">        System.out.println(reverse.toString());</span><br><span class="line">        out.writeObject(reverse);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//将读取的字符串反转后赋值给name实例变量</span></span><br><span class="line">        <span class="built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ExPerson.txt&quot;</span>));</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;ExPerson.txt&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> <span class="title class_">ExPerson</span>(<span class="string">&quot;brady&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            <span class="type">ExPerson</span> <span class="variable">ep</span> <span class="operator">=</span> (ExPerson) ois.readObject();</span><br><span class="line">            System.out.println(ep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//ydarb</span></span><br><span class="line"><span class="comment">//brady</span></span><br><span class="line"><span class="comment">//ExPerson&#123;name=&#x27;brady&#x27;, age=23&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>注意：Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。</strong></p><h4 id="3、两种序列化对比"><a href="#3、两种序列化对比" class="headerlink" title="3、两种序列化对比"></a>3、两种序列化对比</h4><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><p><strong>虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。</strong></p><h3 id="三、序列化版本号serialVersionUID"><a href="#三、序列化版本号serialVersionUID" class="headerlink" title="三、序列化版本号serialVersionUID"></a>三、序列化版本号serialVersionUID</h3><p>我们知道，<strong>反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼容性呢？</strong></p><p>java序列化提供了一个private static final long serialVersionUID 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> implements Serializable &#123;</span><br><span class="line">    <span class="comment">//序列化版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID = <span class="number">1111013L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//省略构造方法及get,set</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果反序列化使用的<strong>class的版本号</strong>与序列化时使用的<strong>不一致</strong>，反序列化会<strong>报InvalidClassException异常。</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/21/16ad9dbc2a4e3900~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><strong>序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。</strong></p><p>什么情况下需要修改serialVersionUID呢？分三种情况。</p><ul><li>如果只是修改了方法，反序列化不容影响，则无需修改版本号；</li><li>如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；</li><li>如果修改了非瞬态变量，则可能导致反序列化失败。<strong>如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。</strong>如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li></ul><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ol><li>所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。</li><li>对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。</li><li>如果想让某个变量不被序列化，使用transient修饰。</li><li>序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。</li><li>反序列化时必须有序列化对象的class文件。</li><li>当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。</li><li>单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。</li><li>同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。</li><li>建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Serializable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引使用方式</title>
      <link href="/2022/08/23/47.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/08/23/47.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://blog.csdn.net/qq_44483424/article/details/121385545">https://blog.csdn.net/qq_44483424/article/details/121385545</a></p><p><a href="https://github.com/digoal/blog">https://github.com/digoal/blog</a></p></blockquote><h1 id="数据库索引使用方式"><a href="#数据库索引使用方式" class="headerlink" title="数据库索引使用方式"></a>数据库索引使用方式</h1><p>使用索引是提高数据库查询效率的主要方式，下面从索引结构，索引类型，索引操作，命中索引几个方面来介绍索引。</p><h2 id="一、索引结构"><a href="#一、索引结构" class="headerlink" title="一、索引结构"></a>一、索引结构</h2><p>mysql5.5以上的默认存储引擎innodb，只显式支持BTree( 事实上从数据结构上来讲是B+树，mysql称之为BTree)索引，对于频繁访问的表，innodb会建立自适应hash索引，</p><p>即在B树索引基础上建立hash索引，可以显著提高查找效率，用户是无法自己指定的，除此之外还有Hash索引和全文索引（fullText索引）。 </p><p><strong>B****Tree索引</strong> </p><p>BTree,顾名思义，就是所有的索引节点都按照balance tree的数据结构来存储。BTree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。</p><p>Btree中，每个结点包含： </p><p>1、本结点所含关键字的个数；</p><p>2、指向父结点的指针；</p><p>3、关键字；</p><p>4、指向子结点的指针； </p><p>更详细的B+树介绍参考<a href="https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html">https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html</a></p><p><strong>Hash索引</strong> </p><p>Hash 索引由于使用了hash表结构，其检索效率很高，索引的检索可以一次定位，不像B+树索引需要从根节点到枝节点，</p><p>所以 Hash 索引的查询效率要远高于 B+树 索引。但是，Hash索引的使用范围非常有限。</p><p>  1.在MySQL中，只有HEAP&#x2F;MEMORY引擎表才能支持哈希索引，InnoDB引擎的自适应哈希索引（adaptive hash index）不</p><p>  能在创建索引时指定。</p><p>  2.Hash索引仅支持&#x3D;，&gt;&#x3D;,&lt;&#x3D;这几种条件运算，不支持排序，范围内查找，like等查询。</p><p>  3.Hash索引不支持组合索引中部分索引的查找。</p><p>  4.当Hash值重复较多时，索引速度可能不如BTree索引。</p><p><strong>FullText索引</strong></p><p>Full-text索引就是我们常说的全文索引，他的存储结构也是Btree。主要是为了解决在我们需要用like查询的低效问题。</p><p>只能解决’xxx%’的like查询。如：字段数据为ABCDE，索引建立为A、AB、ABC、ABCD、ABCDE五个。</p><h2 id="二、索引类型"><a href="#二、索引类型" class="headerlink" title="二、索引类型"></a>二、索引类型</h2><p>索引一般有：普通索引，唯一索引，复合索引这几种类型。</p><p>唯一索引：唯一索引要求字段中不会出现重复数据。</p><p>复合索引：将多个字段组合起来作为索引，必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用。</p><h2 id="三、索引操作"><a href="#三、索引操作" class="headerlink" title="三、索引操作"></a>三、索引操作</h2><p>建立索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 表名（索引字段名）</span><br></pre></td></tr></table></figure><p>建立唯一索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index 索引名 on 表名（索引字段名）</span><br></pre></td></tr></table></figure><p>建立复合索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index 索引名 on 表名（索引字段名1，索引字段名2...）</span><br></pre></td></tr></table></figure><p>查看表中索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from 表名</span><br></pre></td></tr></table></figure><p>删除索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index 索引名 on 表名</span><br></pre></td></tr></table></figure><p>查看索引是否命中</p><p>Mysql:当结果的type为 index时索引命中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain +sql语句</span><br></pre></td></tr></table></figure><p>Oracle:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain plan for+sql语句</span><br></pre></td></tr></table></figure><h2 id="四、命中索引"><a href="#四、命中索引" class="headerlink" title="四、命中索引"></a>四、命中索引</h2><h3 id="1-避免判断null值"><a href="#1-避免判断null值" class="headerlink" title="1. 避免判断null值"></a>1. <strong>避免判断null值</strong></h3><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null</span><br></pre></td></tr></table></figure><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=0</span><br></pre></td></tr></table></figure><h3 id="2-避免不等值判断"><a href="#2-避免不等值判断" class="headerlink" title="2. 避免不等值判断"></a><strong>2. 避免不等值判断</strong></h3><p>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p><h3 id="3-避免使用or逻辑"><a href="#3-避免使用or逻辑" class="headerlink" title="3. 避免使用or逻辑"></a>3. <strong>避免使用or逻辑</strong></h3><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=1 or num=2</span><br></pre></td></tr></table></figure><p>可以使用union all来进行查询来命中索引如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=1 union all select id from t where num=2</span><br></pre></td></tr></table></figure><h3 id="4-慎用in和not-in逻辑"><a href="#4-慎用in和not-in逻辑" class="headerlink" title="4 . 慎用in和not in逻辑"></a>4 . <strong>慎用in和not in逻辑</strong></h3><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t1 where num in(select id from t2 where id &gt; 10)</span><br></pre></td></tr></table></figure><p>此时外层查询会全表扫描，不使用索引。可以修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t1,(select id from t1 where id &gt; 10)t2 where t1.id = t2.id</span><br></pre></td></tr></table></figure><p>此时索引被使用，可以明显提升查询效率。</p><h3 id="5-注意模糊查询"><a href="#5-注意模糊查询" class="headerlink" title="5. 注意模糊查询"></a>5. <strong>注意模糊查询</strong></h3><p>下面的查询也将导致全表扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#x27;%abc%&#x27;</span><br></pre></td></tr></table></figure><p>不要在like条件左边加’%’,这样不会走索引模糊查询如果是必要条件时，可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#x27;abc%&#x27;</span><br></pre></td></tr></table></figure><p>来实现模糊查询，此时索引将被使用。如果头匹配是必要的，可以使用elasticsearch等全文搜索引擎。</p><h3 id="6-避免查询条件中字段计算"><a href="#6-避免查询条件中字段计算" class="headerlink" title="6. 避免查询条件中字段计算"></a>6. <strong>避免查询条件中字段计算</strong></h3><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num/2=100</span><br></pre></td></tr></table></figure><p>应改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=100*2</span><br></pre></td></tr></table></figure><h3 id="7-避免查询条件中对字段进行函数操作"><a href="#7-避免查询条件中对字段进行函数操作" class="headerlink" title="7. 避免查询条件中对字段进行函数操作"></a>7. <strong>避免查询条件中对字段进行函数操作</strong></h3><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where substring(name,1,3)=&#x27;abc&#x27;</span><br></pre></td></tr></table></figure><p>name以abc开头的id</p><p>应改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#x27;abc%&#x27;</span><br></pre></td></tr></table></figure><h3 id="8-“-x3D-”左边避免表达式运算"><a href="#8-“-x3D-”左边避免表达式运算" class="headerlink" title="8. “&#x3D;”左边避免表达式运算** **"></a>8. “&#x3D;”左边避免表达式运算** **</h3><p>不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><h3 id="9-组合索引使用"><a href="#9-组合索引使用" class="headerlink" title="9. 组合索引使用"></a>9. <strong>组合索引使用</strong></h3><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><h3 id="10-exists"><a href="#10-exists" class="headerlink" title="10 exists"></a>10 <strong>exists</strong></h3><p>很多时候用 exists 代替 in 是一个好的选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where num in(select num from b)</span><br></pre></td></tr></table></figure><p>用下面的语句替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where exists(select 1 from b where num=a.num)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBase </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pgsql自动创建序列</title>
      <link href="/2022/08/21/46.pgsql%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2022/08/21/46.pgsql%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在数据库设计过程中，我们通常会把数据库表中的ID字段设置成自增。下面以常用的<strong>数据字典表</strong>为例，说明如何在各数据库下设置自增字段。</p></blockquote><h2 id="1-MySQL"><a href="#1-MySQL" class="headerlink" title="1. MySQL"></a>1. MySQL</h2><p>MySQL数据库只需要在目标字段上添加<strong>AUTO_INCREMENT</strong>，并且为表设置<strong>AUTO_INCREMENT&#x3D;x</strong>。<br><strong>x</strong>：自增开始的数字。</p><p>参考示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dictionary` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `parent_id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;父ID&#x27;</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;元数据类型&#x27;</span>,</span><br><span class="line">  `item_name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;元数据项显示名&#x27;</span>,</span><br><span class="line">  `item_value` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;元数据项存储值&#x27;</span>,</span><br><span class="line">  `comment` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  `deleted` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标记&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;数据字典&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="2-PostgreSQL"><a href="#2-PostgreSQL" class="headerlink" title="2. PostgreSQL"></a>2. PostgreSQL</h2><p>PostgreSQL数据库有多种方法可实现自增字段的设置，常用的有：</p><ol><li>SERIAL，最简单</li><li>IDENTITY，是PostgreSQL 10的新增特性</li><li>创建SEQUENCE，更灵活</li></ol><h3 id="2-1-SERIAL"><a href="#2-1-SERIAL" class="headerlink" title="2.1 SERIAL"></a>2.1 SERIAL</h3><p>SMALLSERIAL、SERIAL 和 BIGSERIAL 范围：</p><table><thead><tr><th align="left">伪类型</th><th align="left">存储大小</th><th align="left">范围</th></tr></thead><tbody><tr><td align="left"><code>SMALLSERIAL</code></td><td align="left">2字节</td><td align="left">1 到 32,767</td></tr><tr><td align="left"><code>SERIAL</code></td><td align="left">4字节</td><td align="left">1 到 2,147,483,647</td></tr><tr><td align="left"><code>BIGSERIAL</code></td><td align="left">8字节</td><td align="left">1 到 922,337,2036,854,775,807</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dictionary (</span><br><span class="line">   id                   SERIAL <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">   parent_id            INT4                 <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">   type                 <span class="type">VARCHAR</span>(<span class="number">50</span>)          <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">   item_name            <span class="type">VARCHAR</span>(<span class="number">100</span>)         <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">   item_value           <span class="type">VARCHAR</span>(<span class="number">100</span>)         <span class="keyword">null</span>,</span><br><span class="line">   comment              <span class="type">VARCHAR</span>(<span class="number">200</span>)         <span class="keyword">null</span>,</span><br><span class="line">   deleted              INT2                 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">   create_time          <span class="type">DATE</span>                 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">   <span class="keyword">constraint</span> PK_dictionary <span class="keyword">primary</span> key (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-2-SEQUENCE"><a href="#2-2-SEQUENCE" class="headerlink" title="2.2 SEQUENCE"></a>2.2 SEQUENCE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SEQUENCE users_id_seq    <span class="operator">/</span><span class="operator">/</span>设置序列名</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span><span class="operator">/</span><span class="operator">/</span>初始值</span><br><span class="line">INCREMENT <span class="keyword">BY</span> <span class="number">1</span>                  <span class="operator">/</span><span class="operator">/</span>增长值</span><br><span class="line"><span class="keyword">NO</span> MINVALUE<span class="operator">/</span><span class="operator">/</span>最小值</span><br><span class="line"><span class="keyword">NO</span> MAXVALUE                     <span class="operator">/</span><span class="operator">/</span>最大值 </span><br><span class="line">CACHE <span class="number">1</span>;<span class="operator">/</span><span class="operator">/</span>缓存</span><br><span class="line"></span><br><span class="line">INCREMENT <span class="keyword">BY</span> ： 每次序列增加（或减少）的步长</span><br><span class="line">MINVALUE ： 序列最小值，<span class="keyword">NO</span> MINVALUE表示没有最小值</span><br><span class="line">MAXVALUE ： 序列最大值，<span class="keyword">NO</span> MAXVALUE表示没有最大值</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> ：以什么序列值开始</span><br><span class="line"><span class="keyword">CYCLE</span> ： 序列是否循环使用</span><br><span class="line">OWNED <span class="keyword">BY</span> ： 可以直接指定一个表的字段，也可以不指定。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">alter</span> <span class="keyword">column</span> id <span class="keyword">set</span> <span class="keyword">default</span> nextval(<span class="string">&#x27;users_id_seq&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dictionary (</span><br><span class="line">  id int4 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> nextval(<span class="string">&#x27;users_id_seq&#x27;</span>),</span><br><span class="line">  parent_id            INT4                 <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  type                 <span class="type">VARCHAR</span>(<span class="number">50</span>)          <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  item_name            <span class="type">VARCHAR</span>(<span class="number">100</span>)         <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  item_value           <span class="type">VARCHAR</span>(<span class="number">100</span>)         <span class="keyword">null</span>,</span><br><span class="line">  comment              <span class="type">VARCHAR</span>(<span class="number">200</span>)         <span class="keyword">null</span>,</span><br><span class="line">  deleted              INT2                 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  create_time          <span class="type">DATE</span>                 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">   <span class="keyword">constraint</span> PK_dictionary <span class="keyword">primary</span> key (id)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时，在使用第二种方式时，可能会见到这种语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">ONLY</span> table_name <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> id <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> nextval(<span class="string">&#x27;table_name_id_seq&#x27;</span>::regclass);</span><br></pre></td></tr></table></figure><p>这里，::是postgresql的类型转换操作符，是将SEQUENCE类型的’table_name_id_seq’转换成regclass类型，regclass类型是postgresql系统表用到的一个隐藏字段，值唯一，可以作为隐藏主键。用户表不建议使用。::regclass可以省略。</p><p>使用如下sql可以获取序列当前值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> currval(<span class="string">&#x27;test_id_seq&#x27;</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>返回类型</th><th>描述</th><th></th></tr></thead><tbody><tr><td>nextval(regclass)</td><td>bigint</td><td>递增序列对象到它的下一个数值并且返回该值。这个动作是自动完成的。即使多个会话并发运行nextval，每个进程也会安全地收到一个唯一的序列值。</td><td>获取指定序列最近一次使用netxval后的数值，如果没有使用nextval而直接使用currval会出错</td></tr><tr><td>currval(regclass)</td><td>bigint</td><td>在当前会话中返回最近一次nextval抓到的该序列的数值。(如果在本会话中从未在该序列上调用过 nextval，那么会报告一个错误。)请注意因为此函数返回一个会话范围的数值，而且也能给出一个可预计的结果，因此可以用于判断其它会话是否执行过nextval。</td><td>返回最近一次用 nextval 获取的任意序列的数值</td></tr><tr><td>lastval()</td><td>bigint</td><td>返回当前会话里最近一次nextval返回的数值。这个函数等效于currval，只是它不用序列名为参数，它抓取当前会话里面最近一次nextval使用的序列。如果当前会话还没有调用过nextval，那么调用lastval将会报错。</td><td>递增序列并返回新值</td></tr><tr><td>setval(regclass, bigint)</td><td>bigint</td><td>重置序列对象的计数器数值。设置序列的last_value字段为指定数值并且将其is_called字段设置为true，表示下一次nextval将在返回数值之前递增该序列。</td><td>设置序列的当前数值</td></tr><tr><td>setval(regclass, bigint, boolean)</td><td>bigint</td><td>重置序列对象的计数器数值。功能等同于上面的setval函数，只是is_called可以设置为true或false。如果将其设置为false，那么下一次nextval将返回该数值，随后的nextval才开始递增该序列。</td><td>设置序列的当前数值以及 is_called 标志，如果为true则立即生效，如果为false，则调用一次nextval后才会生效</td></tr></tbody></table><h2 id="3-Oracle"><a href="#3-Oracle" class="headerlink" title="3. Oracle"></a>3. Oracle</h2><p>Oracle数据库常用的设置自增字段的两种方法：</p><ol><li>创建SEQUENCE</li><li>IDENTITY，要求Oracle数据库版本是12c或以上</li></ol><p>12c版本示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table &quot;dictionary&quot; (</span><br><span class="line">   &quot;id&quot;                 INTEGER  generated as identity ( start with 1 nocycle noorder)  not null,</span><br><span class="line">   &quot;parent_id&quot;          INTEGER               not null,</span><br><span class="line">   &quot;type&quot;               VARCHAR2(50)          not null,</span><br><span class="line">   &quot;item_name&quot;          VARCHAR2(100)         not null,</span><br><span class="line">   &quot;item_value&quot;         VARCHAR2(100),</span><br><span class="line">   &quot;comment&quot;            VARCHAR2(200),</span><br><span class="line">   &quot;deleted&quot;            SMALLINT             default 0  not null,</span><br><span class="line">   &quot;create_time&quot;        TIMESTAMP            default CURRENT_TIMESTAMP  not null,</span><br><span class="line">   constraint &quot;PK_dictionary&quot; primary key (&quot;id&quot;)</span><br><span class="line">);</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure><p>11g版本示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 建表</span><br><span class="line">create table &quot;dictionary&quot; (</span><br><span class="line">   &quot;id&quot;                 INTEGER               not null,</span><br><span class="line">   &quot;parent_id&quot;          INTEGER               not null,</span><br><span class="line">   &quot;type&quot;               VARCHAR2(50)          not null,</span><br><span class="line">   &quot;item_name&quot;          VARCHAR2(100)         not null,</span><br><span class="line">   &quot;item_value&quot;         VARCHAR2(100),</span><br><span class="line">   &quot;comment&quot;            VARCHAR2(200),</span><br><span class="line">   &quot;deleted&quot;            SMALLINT             default 0  not null,</span><br><span class="line">   &quot;create_time&quot;        TIMESTAMP            default CURRENT_TIMESTAMP  not null,</span><br><span class="line">   constraint &quot;PK_dictionary&quot; primary key (&quot;id&quot;)</span><br><span class="line">);</span><br><span class="line">-- 创建序列</span><br><span class="line">CREATE SEQUENCE DICTIONARY_ID_SEQ</span><br><span class="line">INCREMENT BY 1</span><br><span class="line">START WITH 1;</span><br><span class="line">-- 创建触发器，非必须</span><br><span class="line">CREATE OR REPLACE TRIGGER DICTIONARY_ID_SEQ_TRG</span><br><span class="line">BEFORE INSERT ON &quot;dictionary&quot;</span><br><span class="line">FOR EACH ROW</span><br><span class="line">WHEN (NEW.&quot;id&quot; IS NULL)</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT DICTIONARY_ID_SEQ.NEXTVAL</span><br><span class="line">  INTO :NEW.&quot;id&quot;</span><br><span class="line">  FROM DUAL;</span><br><span class="line">END;</span><br><span class="line">1234567891011121314151617181920212223242526</span><br></pre></td></tr></table></figure><h2 id="4-MsSQL"><a href="#4-MsSQL" class="headerlink" title="4. MsSQL"></a>4. MsSQL</h2><p>MsSQL即SQL Server数据库，使用<strong>IDENTITY</strong>即可。</p><p>参考示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table dictionary (</span><br><span class="line">   id                   int                  identity,</span><br><span class="line">   parent_id            int                  not null,</span><br><span class="line">   type                 varchar(50)          not null,</span><br><span class="line">   item_name            varchar(100)         not null,</span><br><span class="line">   item_value           varchar(100)         null,</span><br><span class="line">   comment              varchar(200)         null,</span><br><span class="line">   deleted              smallint             not null default 0,</span><br><span class="line">   create_time          datetime             not null default CURRENT_TIMESTAMP,</span><br><span class="line">   constraint PK_dictionary primary key (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postgres </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>validate注解校验传参</title>
      <link href="/2022/08/16/51.validate%E6%B3%A8%E8%A7%A3%E6%A0%A1%E9%AA%8C%E4%BC%A0%E5%8F%82/"/>
      <url>/2022/08/16/51.validate%E6%B3%A8%E8%A7%A3%E6%A0%A1%E9%AA%8C%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><p>注：从<code>springboot-2.3</code>开始，校验包被独立成了一个<code>starter</code>组件，所以需要引入validation和web，而<code>springboot-2.3</code>之前的版本只需要引入 web 依赖就可以了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者也可以引入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">8.0</span><span class="number">.0</span>.CR3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-简单的例子"><a href="#2-简单的例子" class="headerlink" title="2. 简单的例子"></a>2. 简单的例子</h2><h3 id="2-1-例子"><a href="#2-1-例子" class="headerlink" title="2.1 例子"></a>2.1 例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Validated</span> <span class="comment">//注意，当使用单参数校验时需要在Controller上加上@Validated注解，否则不生效。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;RequestBody校验&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/valid/test1&quot;)</span>   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> ValidVO validVO)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test1 valid success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;Form校验&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/valid/test2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(<span class="meta">@Validated</span> ValidVO validVO)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test2 valid success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//注意，当使用单参数校验时需要在Controller上加上@Validated注解，否则不生效。</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/valid/test3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test3</span><span class="params">(<span class="meta">@Email</span> String email)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;email is &#123;&#125;&quot;</span>, email);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;email valid success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-方法级别的单个参数校验"><a href="#2-2-方法级别的单个参数校验" class="headerlink" title="2.2 方法级别的单个参数校验"></a>2.2 方法级别的单个参数校验</h3><p>1、在方法所在的类上添加 @Validated 。注意，此处 只能使用 @Validated 注解 ，@Valid 无效 ，因为 @Valid 不能用在类上。</p><p>2、对方法中的每个参数上加上所需的验证注解，如 @Rang， @Max，@Min、自定义注解 等注解 ；</p><p>3、定义 ConstraintViolationException 的异常拦截器 （这是系统全局 捕获异常。也可以使用BindingResult 捕获）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span>   <span class="comment">//第1步，告诉MethodValidationPostProcessor此Bean需要开启方法级别验证支持</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/validation/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo1</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Range(min = 1, max = 9, message = &quot;年级只能从1-9&quot;)</span>   //第<span class="number">2</span>步</span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(name = &quot;grade&quot;, required = true)</span> <span class="type">int</span> grade, //</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="meta">@Min(value = 1, message = &quot;班级最小只能1&quot;)</span> <span class="meta">@Max(value = 99, message = &quot;班级最大只能99&quot;)</span>  //第<span class="number">2</span>步</span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(name = &quot;classroom&quot;, required = true)</span> <span class="type">int</span> classroom)</span> &#123; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">System.out.println(grade + <span class="string">&quot;,&quot;</span> + classroom);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-全局异常处理器"><a href="#3-全局异常处理器" class="headerlink" title="3. 全局异常处理器"></a>3. 全局异常处理器</h2><p>@Valid 和 @Validated 的异常信息捕获必须使用 <code>BindingResult bindingResult</code> （如下示例）， 非常麻烦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAll</span><span class="params">(<span class="meta">@Validated</span> User user, BindingResult bindingResult)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : bindingResult.getAllErrors()) &#123;</span><br><span class="line">           ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Validator</code>校验框架返回的错误提示太臃肿了，不便于阅读，为了方便前端提示，我们需要将其简化一下。</p><p>直接修改之前定义的<code>RestExceptionHandler</code>，单独拦截参数校验的三个异常：<code>javax.validation.ConstraintViolationException</code>，<code>org.springframework.validation.BindException</code>，<code>org.springframework.web.bind.MethodArgumentNotValidException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(value = &#123;</span></span><br><span class="line"><span class="meta">BindException.class,ValidationException.class,MethodArgumentNotValidException.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;ResultData&lt;String&gt;&gt; <span class="title function_">handleValidatedException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  ResultData&lt;String&gt; resp = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line">    <span class="comment">// BeanValidation exception</span></span><br><span class="line">    <span class="type">MethodArgumentNotValidException</span> <span class="variable">ex</span> <span class="operator">=</span> (MethodArgumentNotValidException) e;</span><br><span class="line">    resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),</span><br><span class="line">                           ex.getBindingResult().getAllErrors().stream()</span><br><span class="line">                           .map(ObjectError::getDefaultMessage)</span><br><span class="line">                           .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))</span><br><span class="line">                          );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConstraintViolationException) &#123;</span><br><span class="line">    <span class="comment">// BeanValidation GET simple param</span></span><br><span class="line">    <span class="type">ConstraintViolationException</span> <span class="variable">ex</span> <span class="operator">=</span> (ConstraintViolationException) e;</span><br><span class="line">    resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),</span><br><span class="line">                           ex.getConstraintViolations().stream()</span><br><span class="line">                           .map(ConstraintViolation::getMessage)</span><br><span class="line">                           .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))</span><br><span class="line">                          );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">    <span class="comment">// BeanValidation GET object param</span></span><br><span class="line">    <span class="type">BindException</span> <span class="variable">ex</span> <span class="operator">=</span> (BindException) e;</span><br><span class="line">    resp = ResultData.fail(HttpStatus.BAD_REQUEST.value(),</span><br><span class="line">                           ex.getAllErrors().stream()</span><br><span class="line">                           .map(ObjectError::getDefaultMessage)</span><br><span class="line">                           .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>))</span><br><span class="line">                          );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(resp,HttpStatus.BAD_REQUEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-嵌套验证"><a href="#4-嵌套验证" class="headerlink" title="4. 嵌套验证"></a>4. 嵌套验证</h2><p>在实际的开发中，前台会后台传递一个list，我们不仅要限制每次请求list内的个数，同时还要对list内基本元素的属性值进行校验。这个时候就需要进行嵌套验证了，实现的方式很简单。在list上添加@Vaild就可以实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonRequestForm</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Vaild</span></span><br><span class="line">    <span class="meta">@Size(min = 1 ,max =  10 , message = &quot;列表中的元素数量为1~10&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RequestForm&gt; requestFormList;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-自定义参数校验"><a href="#5-自定义参数校验" class="headerlink" title="5. 自定义参数校验"></a>5. 自定义参数校验</h2><p>面对复杂的定义，我们还是需要自己定义相关注解来实现自动校验。比如实体类中的sex性别属性，只允许前端传递传 M，F 这2个枚举值</p><h3 id="5-1-创建自定义注解"><a href="#5-1-创建自定义注解" class="headerlink" title="5.1 创建自定义注解"></a>5.1 创建自定义注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(EnumString.List.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = EnumStringValidator.class)</span><span class="comment">//标明由哪个类执行校验逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnumString &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;value not in enum values.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> date must in this value array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Defines several &#123;<span class="doctag">@link</span> EnumString&#125; annotations on the same element.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> EnumString</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@interface</span> List &#123;</span><br><span class="line"></span><br><span class="line">        EnumString[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-自定义校验逻辑"><a href="#5-2-自定义校验逻辑" class="headerlink" title="5.2 自定义校验逻辑"></a>5.2 自定义校验逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumStringValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;EnumString, String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; enumStringList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(EnumString constraintAnnotation)</span> &#123;</span><br><span class="line">        enumStringList = Arrays.asList(constraintAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enumStringList.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-在字段上增加注解"><a href="#5-3-在字段上增加注解" class="headerlink" title="5.3 在字段上增加注解"></a>5.3 在字段上增加注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;性别&quot;)</span></span><br><span class="line"><span class="meta">@EnumString(value = &#123;&quot;F&quot;,&quot;M&quot;&#125;, message=&quot;性别只允许为F或M&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String sex;</span><br></pre></td></tr></table></figure><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>有的时候，开发者在某一个实体类中定义了很多校验规则，但是在某一次业务处理中，并不需要这么多校验规则，此时就可以使用分组校验：</p><p>首先创建两个分组接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidationGroup1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidationGroup2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在实体类中添加分组信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//groups属性，表示该校验属性规则所属的分组</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size(min = 5, max = 10, message = &quot;&#123;user.name.size&#125;&quot;, groups = ValidationGroup1.class)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;&#123;user.address.notnull&#125;&quot;, groups = ValidationGroup2.class)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DecimalMin(value = &quot;1&quot;, message = &quot;&#123;user.age.size&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@DecimalMax(value = &quot;200&quot;, message = &quot;&#123;user.age.size&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;&#123;user.email.pattern&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;&#123;user.email.notnull&#125;&quot;, groups = &#123;ValidationGroup1.class, ValidationGroup2.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@Validated注解中指定校验分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Validated(ValidationGroup2.class) 表示这里的校验使用ValidationGroup2分组的校验规则，即只校验邮箱地址是否为空、用户地址是否为空</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@Validated(ValidationGroup2.class)</span> User user, BindingResult result)</span>&#123;</span><br><span class="line">        List&lt;String&gt; errors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(result.hasErrors())&#123;</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = result.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span>(ObjectError error : allErrors)&#123;</span><br><span class="line">                errors.add(error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> errors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-分组校验"><a href="#6-分组校验" class="headerlink" title="6. 分组校验"></a>6. 分组校验</h2><p>一个VO对象在新增的时候某些字段为必填，在更新的时候又非必填。如上面的<code>ValidVO</code>中 id 和 appId 属性在新增操作时都是<strong>非必填</strong>，而在编辑操作时都为<strong>必填</strong>，name在新增操作时为<strong>必填</strong>，面对这种场景你会怎么处理呢？</p><p>在实际开发中我见到很多同学都是建立两个VO对象，<code>ValidCreateVO</code>，<code>ValidEditVO</code>来处理这种场景，这样确实也能实现效果，但是会造成类膨胀，而且极其容易被开发老鸟们嘲笑。</p><p>其实<code>Validator</code>校验框架已经考虑到了这种场景并且提供了解决方案，就是<strong>分组校验</strong></p><h3 id="6-1-定义分组接口"><a href="#6-1-定义分组接口" class="headerlink" title="6.1 定义分组接口"></a>6.1 定义分组接口</h3><p>这里我们定义一个分组接口ValidGroup让其继承<code>javax.validation.groups.Default</code>，再在分组接口中定义出多个不同的操作类型，Create，Update，Query，Delete。至于为什么需要继承Default我们稍后再说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidGroup</span> <span class="keyword">extends</span> <span class="title class_">Default</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Crud</span> <span class="keyword">extends</span> <span class="title class_">ValidGroup</span>&#123;</span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Create</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Update</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Query</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Delete</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-在模型中给参数分配分组"><a href="#6-2-在模型中给参数分配分组" class="headerlink" title="6.2 在模型中给参数分配分组"></a>6.2 在模型中给参数分配分组</h3><p>给参数指定分组，对于未指定分组的则使用的是默认分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;参数校验类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidVO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Null(groups = ValidGroup.Crud.Create.class)</span></span><br><span class="line">    <span class="meta">@NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Null(groups = ValidGroup.Crud.Create.class)</span></span><br><span class="line">    <span class="meta">@NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = ValidGroup.Crud.Create.class,message = &quot;名字为必填项&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Email(message = &quot;请填写正取的邮箱地址&quot;)</span></span><br><span class="line">    privte String email;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-给需要参数校验的方法指定分组"><a href="#6-3-给需要参数校验的方法指定分组" class="headerlink" title="6.3 给需要参数校验的方法指定分组"></a>6.3 给需要参数校验的方法指定分组</h3><p>这里我们通过<code>value</code>属性给<code>add()</code>和<code>update()</code>方法分别指定Create和Update分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(&quot;参数校验&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/valid/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Create.class)</span> ValidVO validVO)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test3 valid success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;更新&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/valid/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Update.class)</span> ValidVO validVO)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test4 valid success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-体验效果"><a href="#6-4-体验效果" class="headerlink" title="6.4 体验效果"></a>6.4 体验效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http://localhost:8080/valid/add</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">name=javadaily&amp;level=12&amp;email=476938977@qq.com&amp;sex=F</span><br></pre></td></tr></table></figure><p>在Create时我们没有传递id和appId参数，校验通过。</p><p>当我们使用同样的参数调用update方法时则提示参数校验错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: 400,</span><br><span class="line">  &quot;message&quot;: &quot;ID不能为空; 应用ID不能为空&quot;,</span><br><span class="line">  &quot;data&quot;: null,</span><br><span class="line">  &quot;timestamp&quot;: 1628492514313</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于email属于默认分组，而我们的分组接口<code>ValidGroup</code>已经继承了<code>Default</code>分组，所以也是可以对email字段作参数校验的。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST http://localhost:8080/valid/add</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">name=javadaily&amp;level=12&amp;email=476938977&amp;sex=F</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: 400,</span><br><span class="line">  &quot;message&quot;: &quot;请填写正取的邮箱地址&quot;,</span><br><span class="line">  &quot;data&quot;: null,</span><br><span class="line">  &quot;timestamp&quot;: 1628492637305</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果你的ValidGroup没有继承Default分组，那在代码属性上就需要加上<code>@Validated(value = &#123;ValidGroup.Crud.Create.class, Default.class&#125;</code>才能让<code>email</code>字段的校验生效。</p><h2 id="7-常用注解"><a href="#7-常用注解" class="headerlink" title="7. 常用注解"></a>7. 常用注解</h2><table><thead><tr><th>注解</th><th>作用类型</th><th>解释</th><th>null是否能通过验证</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>Boolean、boolean</td><td>该字段值为false时，验证才能通过</td><td>YES</td></tr><tr><td>@AssertTrue</td><td>Boolean、boolean</td><td>该字段值为true时，验证才能通过</td><td>YES</td></tr><tr><td>@DecimalMax</td><td>数字类型（原子和包装）</td><td>验证小数的最大值<code>@DecimalMax(value = &quot;12.35&quot;) private double money;</code></td><td>YES</td></tr><tr><td>@DecimalMin</td><td>数字类型（原子和包装）</td><td>验证小数的最小值</td><td>YES</td></tr><tr><td>@Digits</td><td>数字类型（原子和包装）</td><td>验证数字的整数位和小数位的位数是否超过指定的长度<code>@Digits(integer = 2, fraction = 2) private double money;</code></td><td>YES</td></tr><tr><td>@Email</td><td>String</td><td>该字段为Email格式，才能通过</td><td>YES</td></tr><tr><td>@Future</td><td>时期、时间</td><td>验证日期是否在当前时间之后，否则无法通过校验<code>@Future private Date date;</code></td><td>YES</td></tr><tr><td>@FutureOrPresent</td><td>时期、时间</td><td>时间在当前时间之后 或者等于此时</td><td>YES</td></tr><tr><td>@Max</td><td>数字类型（原子和包装）</td><td><code>//该字段的最大值为18，否则无法通过验证 @Max(value = 18) private Integer age;</code></td><td>YES</td></tr><tr><td>@Min</td><td>数字类型（原子和包装）</td><td>同上，不能低于某个值否则无法通过验证</td><td>YES</td></tr><tr><td>@Negative</td><td></td><td>数字&lt;0</td><td>YES</td></tr><tr><td>@NegativeOrZero</td><td></td><td>数字&#x3D;&lt;0</td><td>YES</td></tr><tr><td>@NotBlank</td><td>String 该注解用来判断字符串或者字符，只用在String上面</td><td>字符串不能为null,字符串trim()后也不能等于“”</td><td>NO</td></tr><tr><td>@NotEmpty</td><td>String、集合、数组、Map、链表List</td><td>不能为null，不能是空字符，集合、数组、map等size()不能为0；字符串trim()后可以等于“”</td><td>NO</td></tr><tr><td>@NotNull</td><td>任何类型</td><td>使用该注解的字段的值不能为null，否则验证无法通过</td><td>NO</td></tr><tr><td>@Null</td><td></td><td>修饰的字段在验证时必须是null，否则验证无法通过</td><td>YES</td></tr><tr><td>@Past</td><td>时间、日期</td><td>验证日期是否在当前时间之前，否则无法通过校验,必须是一个过去的时间或日期</td><td>YES</td></tr><tr><td>@PastOrPresent</td><td>时间、日期</td><td>验证日期是否在当前时间之前或等于当前时间</td><td>YES</td></tr><tr><td>@Pattern</td><td></td><td>用于验证字段是否与给定的正则相匹配<code>@Pattern(regexp = &quot;正则&quot;) private String name;</code></td><td>YES</td></tr><tr><td>@Positive</td><td></td><td>数字&gt;0</td><td>YES</td></tr><tr><td>@PositiveOrZero</td><td></td><td>数字&gt;&#x3D;0</td><td>YES</td></tr><tr><td>@Size</td><td>字符串String、集合Set、数组Array、Map，List** **</td><td><code>修饰的字段长度不能超过5或者低于1 @Size(min = 1, max = 5) private String name;</code>集合、数组、map等的size()值必须在指定范围内<code>    //只能一个    @Size(min = 1, max = 1)    private List&lt;String&gt; names;</code></td><td>YES</td></tr><tr><td>@URL(protocol&#x3D;, host&#x3D;, port&#x3D;, regexp&#x3D;, flags&#x3D;)</td><td>被注解的对象必须是字符串</td><td>检查是否是一个有效的URL，如果提供了protocol，host等，则该URL还需满足提供的条件</td><td></td></tr><tr><td>@Range(min&#x3D;, max&#x3D;)</td><td>数据：BigDecimal, BigInteger, String, byte, short, int, long and 原始类型的包装类</td><td>被注释的元素必须在合适的范围内</td><td></td></tr><tr><td>@Length(min&#x3D;, max&#x3D;)</td><td>String</td><td>被注解的对象必须是字符串的大小必须在制定的范围内</td><td></td></tr></tbody></table><h2 id="8-Validated与-Valid区别"><a href="#8-Validated与-Valid区别" class="headerlink" title="8. @Validated与@Valid区别"></a>8. @Validated与@Valid区别</h2><p>@Validated是对@Valid进行了二次封装，它们的区别如下表</p><table><thead><tr><th>不同</th><th>@Valid</th><th>@Validated</th></tr></thead><tbody><tr><td>来源</td><td>是Hibernate validation 的 校验注解</td><td>是 Spring Validator 的校验注解，是 Hibernate validation 基础上的增加版</td></tr><tr><td>注解位置</td><td>用在 构造函数、方法、方法参数 和 成员属性上</td><td>用在 类、方法和方法参数上。 但不能用于成员属性</td></tr><tr><td>嵌套验证</td><td>用在级联对象的成员属性上面</td><td>不支持</td></tr><tr><td>分组</td><td>无此功能</td><td>提供分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> validate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java &amp; Springboot SPI</title>
      <link href="/2022/08/15/44.Java_SPI%E5%92%8CSpringBoot_SPI/"/>
      <url>/2022/08/15/44.Java_SPI%E5%92%8CSpringBoot_SPI/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><h2 id="1-SPI是什么"><a href="#1-SPI是什么" class="headerlink" title="1. SPI是什么"></a>1. SPI是什么</h2><p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p><p>整体机制图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5618238-5d8948367cb9b18e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/848/format/webp" alt="img"></p><p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p><p>系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</p><p>Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是<strong>解耦</strong>。</p><h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h2><p>概括地说，适用于：<strong>调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略</strong></p><p>比较常见的例子：</p><ul><li>数据库驱动加载接口实现类的加载<br> JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载<br> SLF4J加载不同提供商的日志实现类</li><li>Spring<br> Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</li><li>Dubbo<br> Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</li></ul><h2 id="3-使用介绍"><a href="#3-使用介绍" class="headerlink" title="3. 使用介绍"></a>3. 使用介绍</h2><p>要使用Java SPI，需要遵循如下约定：</p><ul><li>1、当服务提供者提供了接口的一种具体实现后，在jar包的 <strong>META-INF&#x2F;services</strong> 目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li><li>2、接口实现类所在的jar包放在主程序的classpath中；</li><li>3、主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF&#x2F;services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li><li>4、SPI的实现类必须携带一个不带参数的构造方法；</li></ul><h2 id="4-原理解析"><a href="#4-原理解析" class="headerlink" title="4. 原理解析"></a>4. 原理解析</h2><p>参考具体ServiceLoader具体源码，代码量不多，加上注释一共587行，梳理了一下，实现的流程如下：</p><ul><li>1 应用程序调用ServiceLoader.load方法<br> ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括：<ul><li>loader(ClassLoader类型，类加载器)</li><li>acc(AccessControlContext类型，访问控制器)</li><li>providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类)</li><li>lookupIterator(实现迭代器功能)</li></ul></li><li>2 应用程序通过迭代器接口获取对象实例<br> ServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。<br> 如果没有缓存，执行类的装载，实现如下：</li><li>(1) 读取META-INF&#x2F;services&#x2F;下的配置文件，获得所有能被实例化的类的名称，值得注意的是，ServiceLoader<strong>可以跨越jar包获取META-INF下的配置文件</strong>，具体加载配置的实现代码如下：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> fullName = PREFIX + service.getName();</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        configs = loader.getResources(fullName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">    fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2) 通过反射方法Class.forName()加载类对象，并用instance()方法将类实例化。</li><li>(3) 把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型）<br> 然后返回实例对象。</li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><strong>优点</strong>：<br> 使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过**Class.forName(“com.mysql.jdbc.Driver”)**，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF&#x2F;services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类</p><p><strong>缺点</strong>：</p><ul><li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li></ul><h1 id="SpringBoot-SPI"><a href="#SpringBoot-SPI" class="headerlink" title="SpringBoot SPI"></a>SpringBoot SPI</h1><p>待更新。。。</p>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2022/08/10/45.Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/08/10/45.Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-git合并某个或某些commit到其他分支"><a href="#1-git合并某个或某些commit到其他分支" class="headerlink" title="1. git合并某个或某些commit到其他分支"></a>1. git合并某个或某些commit到其他分支</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick [commit] 命令的常用配置项如下。</span><br><span class="line">（<span class="number">1</span>）-e</span><br><span class="line">打开外部编辑器，编辑提交信息。</span><br><span class="line">（<span class="number">2</span>）-n</span><br><span class="line">只更新工作区和暂存区，不产生新的提交。</span><br><span class="line">（<span class="number">3</span>）-x</span><br><span class="line">在提交信息的末尾追加一行(cherry picked from commit …)，方便以后查到这个提交是如何产生的。</span><br><span class="line">（<span class="number">4</span>）-s</span><br><span class="line">在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</span><br><span class="line">（<span class="number">5</span>）-m parent-number</span><br><span class="line">如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</span><br><span class="line">-m配置项告诉 Git，应该采用哪个分支的变动。它的参数parent-number是一个从<span class="number">1</span>开始的整数，代表原始提交的父分支编号。</span><br></pre></td></tr></table></figure><p>使用git 命令合并</p><p>1.git pull（下拉所有分支代码，预防冲突）<br>2.git log （查看提交的信息,复制你要合的提交的 commit id. 你可以百度git log获取更多查看操作）<br>3.git checkout 分支id （切换到要修改的分支）<br>4.git cherry-pick</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">1.A是commit <span class="built_in">id</span></span></span><br><span class="line">git cherry-pick A </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">2.合并A B</span></span><br><span class="line">git cherry-pick A B </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">3.合并从A到B的所有提交，不包括A</span></span><br><span class="line">git cherry-pick A..B </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">4.合并从A到B的所有提交，包括A</span></span><br><span class="line">git cherry-pick A^..B</span><br></pre></td></tr></table></figure><h2 id="2-git剔除某个提交"><a href="#2-git剔除某个提交" class="headerlink" title="2. git剔除某个提交"></a>2. git剔除某个提交</h2><p>像A-B-C这种比较简单的历史，要去掉B的话可以这样</p><blockquote><p>git reset A –hard<br>git cherry-pick C</p></blockquote><p>回退到A上然后把C再cherrypick过来，这样就把B给跳过了。</p><p>如果待处理的提交历史比较长，那用rebase -i更方便一些</p><blockquote><p>git rebase -i A</p></blockquote><p>这个命令以A为新的基准（base），将A之后的commit列出来让用户选择如何处理。在出现的编辑界面上，把B前面的pick改成d或者drop，或者把一整行删除掉，保存退出就可以了。</p><p>同样地，处理A1-B1-A2-B2，要删除B1的话</p><blockquote><p>git reset A1 –hard<br>git cherry-pick A2 B2</p></blockquote><p>或者</p><blockquote><p>git rebase -i A1</p></blockquote><p>把B1从编辑列表里删掉，保存退出。</p><p>第一个例子和第二个例子有个不同的地方，第一个例子里的commit都是本地还没推送的，这种可以随意整，整好了以后再推送，不会影响别人。第二个例子里，commit很可能都是已经推送到大家共用的中央仓库的，B1很可能已经被拉取到了其他人的本地仓库里。你这边将其删除后，需要用强制推送更新中央仓库里的分支，并且通知其他人这个变动，否则其他人很可能会将新旧版本的分支历史不经意间merge到一起再推送回中央仓库，导致B1没删掉还多了一个merge commit，将分支历史变得更加复杂了。</p>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H2数据库使用和配置</title>
      <link href="/2022/08/04/43.H2%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/08/04/43.H2%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.Embedded 嵌入式</span><br><span class="line">   URL jdbc:h2:〜/test表示数据库存储在用户主目录中以“ test”开头的文件中。</span><br><span class="line">   ”~”这个符号代表的就是当前登录到操作系统的用户对应的用户目录，所以testdatabase数据库对应的文件存放在登录到操作系统的用户对应的用户目录当中，比如我当前是使用Administrator用户登录操作系统的，所以在”C:\Documents and Settings\Administrator.h2”目录中就可以找到test数据库对应的数据库文件了</span><br><span class="line"></span><br><span class="line"> 支持绝对位置，如jdbc:h2:/data/db/test。</span><br><span class="line"> 在嵌入式模式下，数据库与应用程序以相同的过程运行。任何时候都只能有一个进程访问数据库。</span><br><span class="line"> 如果您拥有权限，则不存在的数据库将自动创建。形式为jdbc:h2:./data/test的URL相对于当前工作目录（启动应用程序的目录）。</span><br><span class="line"> 建议使用相对于〜或绝对位置的位置。</span><br><span class="line"></span><br><span class="line">2.Remote (client/server) 远程连接</span><br><span class="line">   URL jdbc:h2:tcp://localhost/〜/test表示通过TCP / IP连接到此计算机上运行的H2 TCP服务器，</span><br><span class="line"> 并在用户主目录中打开一个名为test的数据库。 必须首先启动服务器。 任意数量的客户端都可以连接到同一数据库。</span><br><span class="line"> 适用与嵌入式数据库相同的位置规则。</span><br><span class="line"></span><br><span class="line">3.In-Memory 内存</span><br><span class="line">   URL jdbc:h2:mem:test意味着打开一个名为“test”的内存数据库。数据不持久，当最后一个数据库连接关闭时，数据会丢失。</span><br><span class="line"> 多个线程可以访问同一个数据库，但是数据只能在同一个进程中可见。</span><br></pre></td></tr></table></figure><ul><li>DB_CLOSE_DELAY：要求最后一个正在连接的连接断开后，不要关闭数据库</li><li>MODE&#x3D;MySQL：兼容模式，H2兼容多种数据库，该值可以为：DB2、Derby、HSQLDB、MSSQLServer、MySQL、Oracle、PostgreSQL</li><li>AUTO_RECONNECT&#x3D;TRUE：连接丢失后自动重新连接</li><li>AUTO_SERVER&#x3D;TRUE：启动自动混合模式，允许开启多个连接，该参数不支持在内存中运行模式</li><li>TRACE_LEVEL_SYSTEM_OUT、TRACE_LEVEL_FILE：输出跟踪日志到控制台或文件， 取值0为OFF，1为ERROR（默认值），2为INFO，3为DEBUG</li><li>SET TRACE_MAX_FILE_SIZE mb：设置跟踪日志文件的大小，默认为16M</li></ul><p><strong>数据库支持多种连接模式和连接设置，不同的连接模式和连接设置是通过不同的URL来区分的，URL中的设置是不区分大小写。</strong></p><table><thead><tr><th></th><th>URL Format and Examples</th></tr></thead><tbody><tr><td><a href="http://www.h2database.com/html/features.html#embedded_databases">Embedded (local) connection</a></td><td>jdbc:h2:[file:][&lt;path&gt;]<databaseName> jdbc:h2:~&#x2F;test jdbc:h2:file:&#x2F;data&#x2F;sample jdbc:h2:file:C:&#x2F;data&#x2F;sample (Windows only)</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#in_memory_databases">In-memory (private)</a></td><td>jdbc:h2:mem:</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#in_memory_databases">In-memory (named)</a></td><td>jdbc:h2:mem:<databaseName> jdbc:h2:mem:test_mem</td></tr><tr><td><a href="http://www.h2database.com/html/tutorial.html#using_server">Server mode (remote connections) using TCP&#x2F;IP</a></td><td>jdbc:h2:tcp:&#x2F;&#x2F;<server>[:<port>]&#x2F;[<path>]<databaseName> jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;<del>&#x2F;test jdbc:h2:tcp:&#x2F;&#x2F;dbserv:8084&#x2F;</del>&#x2F;sample jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;mem:test</td></tr><tr><td><a href="http://www.h2database.com/html/advanced.html#tls_connections">Server mode (remote connections) using TLS</a></td><td>jdbc:h2:ssl:&#x2F;&#x2F;<server>[:<port>]&#x2F;<databaseName> jdbc:h2:ssl:&#x2F;&#x2F;localhost:8085&#x2F;~&#x2F;sample;</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#file_encryption">Using encrypted files</a></td><td>jdbc:h2:<url>;CIPHER&#x3D;AES jdbc:h2:ssl:&#x2F;&#x2F;localhost&#x2F;<del>&#x2F;test;CIPHER&#x3D;AES jdbc:h2:file:</del>&#x2F;secure;CIPHER&#x3D;AES</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#database_file_locking">File locking methods</a></td><td>jdbc:h2:<url>;FILE_LOCK&#x3D;{FILE|SOCKET|NO} jdbc:h2:file:~&#x2F;private;CIPHER&#x3D;AES;FILE_LOCK&#x3D;SOCKET</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#database_only_if_exists">Only open if it already exists</a></td><td>jdbc:h2:<url>;IFEXISTS&#x3D;TRUE jdbc:h2:file:~&#x2F;sample;IFEXISTS&#x3D;TRUE</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#do_not_close_on_exit">Don’t close the database when the VM exits</a></td><td>jdbc:h2:<url>;DB_CLOSE_ON_EXIT&#x3D;FALSE</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#execute_sql_on_connection">Execute SQL on connection</a></td><td>jdbc:h2:<url>;INIT&#x3D;RUNSCRIPT FROM ‘<del>&#x2F;create.sql’ jdbc:h2:file:</del>&#x2F;sample;INIT&#x3D;RUNSCRIPT FROM ‘<del>&#x2F;create.sql’;RUNSCRIPT FROM ‘</del>&#x2F;populate.sql’</td></tr><tr><td><a href="http://www.h2database.com/html/advanced.html#passwords">User name and&#x2F;or password</a></td><td>jdbc:h2:<url>[;USER&#x3D;<username>][;PASSWORD&#x3D;] jdbc:h2:file:~&#x2F;sample;USER&#x3D;sa;PASSWORD&#x3D;123</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#trace_options">Debug trace settings</a></td><td>jdbc:h2:<url>;TRACE_LEVEL_FILE&#x3D;&lt;level 0..3&gt; jdbc:h2:file:~&#x2F;sample;TRACE_LEVEL_FILE&#x3D;3</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#ignore_unknown_settings">Ignore unknown settings</a></td><td>jdbc:h2:<url>;IGNORE_UNKNOWN_SETTINGS&#x3D;TRUE</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#custom_access_mode">Custom file access mode</a></td><td>jdbc:h2:<url>;ACCESS_MODE_DATA&#x3D;rws</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#database_in_zip">Database in a zip file</a></td><td>jdbc:h2:zip:<zipFileName>!&#x2F;<databaseName> jdbc:h2:zip:~&#x2F;db.zip!&#x2F;test</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#compatibility">Compatibility mode</a></td><td>jdbc:h2:<url>;MODE&#x3D;<databaseType> jdbc:h2:~&#x2F;test;MODE&#x3D;MYSQL</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#auto_reconnect">Auto-reconnect</a></td><td>jdbc:h2:<url>;AUTO_RECONNECT&#x3D;TRUE jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;~&#x2F;test;AUTO_RECONNECT&#x3D;TRUE</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#auto_mixed_mode">Automatic mixed mode</a></td><td>jdbc:h2:<url>;AUTO_SERVER&#x3D;TRUE jdbc:h2:~&#x2F;test;AUTO_SERVER&#x3D;TRUE</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#page_size">Page size</a></td><td>jdbc:h2:<url>;PAGE_SIZE&#x3D;512</td></tr><tr><td><a href="http://www.h2database.com/html/features.html#other_settings">Changing other settings</a></td><td>jdbc:h2:<url>;<setting>&#x3D;<value>[;<setting>&#x3D;<value>…] jdbc:h2:file:~&#x2F;sample;TRACE_LEVEL_SYSTEM_OUT&#x3D;3</td></tr></tbody></table><h2 id="2-内嵌多连接"><a href="#2-内嵌多连接" class="headerlink" title="2. 内嵌多连接"></a>2. 内嵌多连接</h2><p><strong>path:</strong> D:&#x2F;IdeaProjects&#x2F;treasure-chest&#x2F;database&#x2F;src&#x2F;main&#x2F;resources&#x2F;db&#x2F;testdb.mv.db</p><p><strong>url:</strong> jdbc:h2:D:&#x2F;IdeaProjects&#x2F;treasure-chest&#x2F;database&#x2F;src&#x2F;main&#x2F;resources&#x2F;db&#x2F;testdb</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">h2:</span></span><br><span class="line">    <span class="attr">console:</span></span><br><span class="line">      <span class="comment">#线上运行时需要设置为false，避免暴露公网</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#进行该配置，你就可以通过YOUR_URL/h2访问h2 web consloe。YOUR_URL是你程序的访问URl。默认为/h2-console</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/h2</span></span><br><span class="line">      <span class="comment">#进行该配置后，h2 web console就可以在远程访问了。否则只能在本机访问。</span></span><br><span class="line">      <span class="attr">settings:</span></span><br><span class="line">        <span class="attr">web-allow-others:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sql:</span></span><br><span class="line">    <span class="attr">init:</span></span><br><span class="line">      <span class="attr">schema-locations:</span> <span class="string">classpath:db/schema-h2.sql</span></span><br><span class="line">      <span class="attr">data-locations:</span> <span class="string">classpath:db/schema-h2.sql</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line"><span class="comment">#    type: org.h2.jdbcx.JdbcConnectionPool</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="comment"># 内嵌模式</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:h2:./database/src/main/resources/db/testdb;AUTO_SERVER=TRUE;MODE=PostgreSQL</span></span><br><span class="line">      <span class="comment"># 远程模式</span></span><br><span class="line"><span class="comment">#      url: jdbc:h2:tcp://localhost:8081/./database/src/main/resources/db/testdb;AUTO_SERVER=TRUE;MODE=PostgreSQL</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="comment"># 初始连接数</span></span><br><span class="line">      <span class="attr">initialSize:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 最小连接池数量</span></span><br><span class="line">      <span class="attr">minIdle:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 最大连接池数量</span></span><br><span class="line">      <span class="attr">maxActive:</span> <span class="number">100</span></span><br><span class="line">      <span class="comment"># 配置获取连接等待超时的时间</span></span><br><span class="line">      <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line">      <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line">      <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">      <span class="comment"># 配置一个连接在池中最大生存的时间，单位是毫秒</span></span><br><span class="line">      <span class="attr">maxEvictableIdleTimeMillis:</span> <span class="number">900000</span></span><br><span class="line">      <span class="comment"># 配置检测连接是否有效</span></span><br><span class="line">      <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">      <span class="attr">webStatFilter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">statViewServlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 设置白名单，不填则允许所有访问</span></span><br><span class="line">        <span class="attr">allow:</span></span><br><span class="line">        <span class="comment"># 控制台登录http://localhost:8081/druid/login.html</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/druid/*</span></span><br><span class="line">        <span class="comment"># 控制台管理用户名和密码</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><p>由于H2是由java语言编写的，所以提供的数据类型都和java契合，下面给出数据类型列表：</p><p>1.基本的数据类型有哪些？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、数字方面</span><br><span class="line">整数（<span class="type">INT</span>）</span><br><span class="line">布尔型（<span class="type">BOOLEAN</span>）</span><br><span class="line">微整数（TINYINT）</span><br><span class="line">小整数（<span class="type">SMALLINT</span>）</span><br><span class="line">大整数（<span class="type">BIGINT</span>）</span><br><span class="line">标识符（<span class="keyword">IDENTITY</span>）</span><br><span class="line">货币数（<span class="type">DECIMAL</span>）</span><br><span class="line">双精度实数（<span class="keyword">DOUBLE</span>）</span><br><span class="line">实数（<span class="type">REAL</span>）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、时间方面</span><br><span class="line">时间（<span class="type">TIME</span>）</span><br><span class="line">日期（<span class="type">DATE</span>）<span class="comment">--在H2中存储为date字段类型将只有年月日</span></span><br><span class="line">时间戳（<span class="type">TIMESTAMP</span>）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、字符文本方面</span><br><span class="line">二进制（<span class="type">BINARY</span>）</span><br><span class="line">其他类型（OTHER）</span><br><span class="line">可变字符串（<span class="type">VARCHAR</span>）</span><br><span class="line">不区分大小写可变字符串（VARCHAR_IGNORECASE）</span><br><span class="line">字符（<span class="type">CHAR</span>）</span><br><span class="line">二进制大对象（<span class="type">BLOB</span>）</span><br><span class="line">文本大对象（<span class="type">CLOB</span>）</span><br><span class="line">通用唯一标识符（UUID）</span><br><span class="line">数组（<span class="keyword">ARRAY</span>）</span><br></pre></td></tr></table></figure><p>2.具体数据类型的简介</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">整数（INT）INT | INTEGER | MEDIUMINT | INT4 | SIGNED</span><br><span class="line">值的范围为： -<span class="number">2147483648</span> 到 <span class="number">2147483647</span>.</span><br><span class="line">对应到Java类型： java.lang.Integer.</span><br><span class="line">例如：INT</span><br><span class="line">    </span><br><span class="line">布尔型（BOOLEAN）BOOLEAN | BIT | BOOL</span><br><span class="line">可能的值为： <span class="literal">TRUE</span> 和 <span class="literal">FALSE</span>。</span><br><span class="line">对应到Java类型： java.lang.Boolean.</span><br><span class="line">例如：BOOLEAN</span><br><span class="line">    </span><br><span class="line">微整数（TINYINT）TINYINT</span><br><span class="line">值的范围为： -<span class="number">128</span> 到 <span class="number">127</span>.</span><br><span class="line">对应到Java类型： java.lang.Byte.</span><br><span class="line">例如：TINYINT</span><br><span class="line">    </span><br><span class="line">小整数（SMALLINT）SMALLINT | INT2 | YEAR</span><br><span class="line">值的范围为： -<span class="number">32768</span> 到 <span class="number">32767</span>.</span><br><span class="line">对应到Java类型： java.lang.Short.</span><br><span class="line">例如：SMALLINT</span><br><span class="line">    </span><br><span class="line">大整数（BIGINT）BIGINT | INT8</span><br><span class="line">值的范围为： -<span class="number">9223372036854775808</span> 到 <span class="number">9223372036854775807</span>.</span><br><span class="line">对应到Java类型：  java.lang.Long.</span><br><span class="line">例如：BIGINT</span><br><span class="line">    </span><br><span class="line">标识符（IDENTITY）IDENTITY</span><br><span class="line">自增值，值的范围为： -<span class="number">9223372036854775808</span> 到 <span class="number">9223372036854775807</span>。使用的值不能再重用，即使事务回滚。</span><br><span class="line">对应到Java类型： java.lang.Long.</span><br><span class="line">例如：IDENTITY</span><br><span class="line">    </span><br><span class="line">货币数（DECIMAL）&#123; DECIMAL | NUMBER | DEC | NUMERIC &#125; ( precisionInt [ , scaleInt ] )</span><br><span class="line">固定整数位和小数位。这个数据类型经常用于存储货币等类型的值。</span><br><span class="line">对应到Java类型： java.math.BigDecimal.</span><br><span class="line">例如：<span class="title function_ invoke__">DECIMAL</span>(<span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">双精度实数（DOUBLE）&#123; DOUBLE [ PRECISION ] | FLOAT | FLOAT4 | FLOAT8 &#125;</span><br><span class="line">浮点数。不能应用到表示货币等值，因为有四舍五入的问题。</span><br><span class="line">对应到Java类型： java.lang.Double.</span><br><span class="line">例如：DOUBLE</span><br><span class="line">    </span><br><span class="line">实数（REAL）REAL</span><br><span class="line">单精度浮点数。不能应用到表示货币等值，因为有四舍五入的问题。</span><br><span class="line">对应到Java类型： java.lang.Float.</span><br><span class="line">例如：REAL</span><br><span class="line">    </span><br><span class="line">时间（TIME）TIME</span><br><span class="line">格式为 hh:mm:ss.</span><br><span class="line">对应到Java类型：java.sql.Time.</span><br><span class="line">例如：TIME</span><br><span class="line">    </span><br><span class="line">日期（DATE）DATE</span><br><span class="line">格式为 yyyy-MM-dd.</span><br><span class="line">对应到Java类型： java.sql.Date</span><br><span class="line">例如：DATE  &lt;span style=<span class="string">&quot;color:#FF0000;&quot;</span>&gt;需要特别注意的是这里，我们在oracle中定义成date是可以保存时分秒的，而在H2中则不会&lt;/span&gt;</span><br><span class="line">时间戳（TIMESTAMP）</span><br><span class="line">    </span><br><span class="line">&#123; TIMESTAMP | DATETIME | SMALLDATETIME &#125;</span><br><span class="line">格式为 yyyy-MM-dd hh:mm:ss[.nnnnnnnnn].</span><br><span class="line">对应到Java类型： java.sql.<span class="title function_ invoke__">Timestamp</span> (java.util.Date 也支持).</span><br><span class="line">例如：TIMESTAMP</span><br><span class="line">    </span><br><span class="line">二进制（BINARY）&#123; BINARY | VARBINARY | LONGVARBINARY | RAW | BYTEA &#125; [ ( precisionInt ) ]</span><br><span class="line">表示一个字节数组。针对更长的数组，使用 BLOB 类型。最大的尺寸为 <span class="number">2</span> GB，当使用这种数据类型时，整个对象都会保存在内存中，在内存中的尺寸是一个精确的指定值，只有实际的数据会被持久化。对于大的文本数据，还是使用 BLOB 和 CLOB 更合适。</span><br><span class="line">对应到Java类型： byte[].</span><br><span class="line">例如：<span class="title function_ invoke__">BINARY</span>(<span class="number">1000</span>)</span><br><span class="line">    </span><br><span class="line">其他类型（OTHER）OTHER</span><br><span class="line">这个类型允许存储可序列化的JAVA对象。在内部，使用的是一个字节数组。序列化和反序列化只在客户端端完成。反序列化仅在 getObject 被调用时才被调用。JAVA操作因为安全的原因并不能在数据库引擎内被执行。可以使用 PreparedStatement.setObject 存储对象。</span><br><span class="line">对应到Java类型： java.lang.<span class="title function_ invoke__">Object</span> (或者是任何子类).</span><br><span class="line">例如：OTHER</span><br><span class="line">    </span><br><span class="line">可变字符串（VARCHAR）&#123; VARCHAR | LONGVARCHAR | VARCHAR2 | NVARCHAR| NVARCHAR2 | VARCHAR_CASESENSITIVE&#125;  [ ( precisionInt ) ]</span><br><span class="line">Unicode 字符串。使用两个单引号(<span class="string">&#x27;&#x27;</span>) 表示一个引用。最大的长度是Integer.MAX_VALUE，字符串的实际长度是精确指定的，仅实际的数据会被持久化。当使用这种数据类型时，整个文本都会保存在内存中。更多的文本数据，使用 CLOB 更合适。</span><br><span class="line">对应到Java类型： java.lang.String.</span><br><span class="line">例如：<span class="title function_ invoke__">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">    </span><br><span class="line">不区分大小写的可变字符串（VARCHAR_IGNORECASE ）VARCHAR_IGNORECASE [ ( precisionInt ) ]</span><br><span class="line">与 VARCHAR 类型类似，只是在比较时不区分大小写。存储时是混合大小写存储的。当使用这种数据类型时，整个文本都会保存在内存中。更多的文本数据，使用 CLOB 更合适。</span><br><span class="line">例如：VARCHAR_IGNORECASE</span><br><span class="line">    </span><br><span class="line">字符（CHAR）</span><br><span class="line">&#123; CHAR | CHARACTER | NCHAR &#125; [ ( precisionInt ) ]</span><br><span class="line">这个类型支持是针对其他数据库或老的应用的兼容性。与VARCHAR 的不同是尾空格将被忽略并且不会被持久化。 Unicode 字符串。使用两个单引号(<span class="string">&#x27;&#x27;</span>) 表示一个引用。最大的长度是Integer.MAX_VALUE，字符串的实际长度是精确指定的，仅实际的数据会被持久化。当使用这种数据类型时，整个文本都会保存在内存中。更多的文本数据，使用 CLOB 更合适。</span><br><span class="line">对应到Java类型： java.lang.String.</span><br><span class="line">例如：<span class="title function_ invoke__">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">二进制大对象（BLOB）</span><br><span class="line">&#123; BLOB | TINYBLOB | MEDIUMBLOB | LONGBLOB | IMAGE | OID &#125; [ ( precisionInt ) ]</span><br><span class="line">类似于BINARY，但是针对的是非常大的值如文件或是图片。跟BINARY不同的是，大对象并不完全保存在内存中。使用 PreparedStatement.setBinaryStream 存储对象，详细请参见 CLOB 和 高级 / 大对象。</span><br><span class="line">对应到Java类型： java.sql.<span class="title function_ invoke__">Blob</span> (java.io.InputStream 也支持)。</span><br><span class="line">例如：BLOB</span><br><span class="line">    </span><br><span class="line">文本大对象（CLOB）</span><br><span class="line">&#123; CLOB | TINYTEXT | TEXT | MEDIUMTEXT | LONGTEXT | NTEXT | NCLOB &#125; [ ( precisionInt ) ]</span><br><span class="line">CLOB类似于 VARCHAR，但是针对的是非常大的值。与 VARCHAR不同的是，CLOB 对象并不完全保存在内存中，而是使用的流。CLOB 可以用于文档或文本，如果XML、HTML文档，文本文件、未限制尺寸的备忘录等。使用 PreparedStatement.setCharacterStream 存储对象。详细请参见 高级 / 大对象。</span><br><span class="line">VARCHAR 用于相对较小的文本（如<span class="number">200</span>个字符以内）。小的 CLOB 值被就地存储，但是也比 VARCHAR 要大。</span><br><span class="line">对应到Java类型： java.sql.<span class="title function_ invoke__">Clob</span> (java.io.Reader 也支持).</span><br><span class="line">例如：CLOB</span><br><span class="line">    </span><br><span class="line">通用唯一标识符（UUID）</span><br><span class="line">UUID</span><br><span class="line">UUID（Universally unique identifier），是一个<span class="number">128</span>BIT的值，使用 PreparedStatement.setBytes 或 setString 去存储值。</span><br><span class="line">对应到Java类型： java.util.UUID.</span><br><span class="line">例如：UUID</span><br><span class="line">数组（ARRAY）ARRAY</span><br><span class="line"></span><br><span class="line">一组值，可以使用值列表 (<span class="number">1</span>, <span class="number">2</span>) 或 PreparedStatement.<span class="title function_ invoke__">setObject</span>(.., <span class="keyword">new</span> Object[] &#123;..&#125;) 存储对象。</span><br><span class="line"></span><br><span class="line">对应到Java类型： java.lang.Object[] (没有任何原始类型数组被支持).</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBase </tag>
            
            <tag> H2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kibana常用命令</title>
      <link href="/2022/07/28/38.Kibana%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/28/38.Kibana%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>新建一条记录的话就用post<br>更新一条记录的话就用put</p></blockquote><h2 id="POST和PUT区别"><a href="#POST和PUT区别" class="headerlink" title="POST和PUT区别"></a>POST和PUT区别</h2><p>1.更新：PUT会将新的json值完全替换掉旧的；而POST方式只会更新相同字段的值，其他数据不会改变，新提交的字段若不存在则增加。</p><p>2.PUT和DELETE操作是幂等的。所谓幂等是指不管进行多少次操作，结果都一样。比如用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有什么不同，DELETE也是一样。</p><p>3.POST操作不是幂等的，比如常见的POST重复加载问题：当我们多次发出同样的POST请求后，其结果是创建了若干的资源。</p><p>4.创建操作可以使用POST，也可以使用PUT，区别就在于POST是作用在一个集合资源(&#x2F;articles)之上的，而PUT操作是作用在一个具体资源之上的(&#x2F;articles&#x2F;123)。</p><ul><li>put需要精确到某一个资源文件，这样才能进行对数据的更新和创建操作；</li><li>post能对整个资源集合进行操作，如果没有指定具体修改的文件id，那么post指令会自动生成一个唯一的id进行文件的创建，并将数据写入该文件中。如果指定了文件id，那么就会根据填写的参数对数据进行创建和更新操作；</li></ul><p>##1. 查看集群的健康情况</p><p>GET &#x2F;_cat&#x2F;health?v</p><p>##2. 查看节点的情况<br>GET &#x2F;_cat&#x2F;nodes?v</p><p>##3. 查询各个索引状态<br>GET &#x2F;_cat&#x2F;indices?v</p><p>##4. 创建索引<br>PUT &#x2F;movie_index</p><p>##5. 查看某一个索引的分片情况<br>GET &#x2F;_cat&#x2F;shards&#x2F;movie_index?v</p><p>##6. 删除索引<br>DELETE &#x2F;movie_index</p><p>##7. 创建文档<br>PUT &#x2F;movie_index&#x2F;movie&#x2F;1<br>{ “id”:100,<br>  “name”:”operation red sea”,<br>  “doubanScore”:8.5,<br>  “actorList”:[<br>  {“id”:1,”name”:”zhang yi”},<br>  {“id”:2,”name”:”hai qing”},<br>  {“id”:3,”name”:”zhang han yu”}<br>  ]<br>}</p><p>PUT &#x2F;movie_index&#x2F;movie&#x2F;2<br>{<br>  “id”:200,<br>  “name”:”operation meigong river”,<br>  “doubanScore”:8.0,<br>  “actorList”:[<br>{“id”:3,”name”:”zhang han yu”}<br>]<br>}</p><p>PUT &#x2F;movie_index&#x2F;movie&#x2F;3<br>{<br>  “id”:300,<br>  “name”:”incident red sea”,<br>  “doubanScore”:5.0,<br>  “actorList”:[<br>{“id”:4,”name”:”zhang san feng”}<br>]<br>}</p><p>##8. 查询某一个索引中的全部文档<br>GET &#x2F;movie_index&#x2F;_search</p><p>##9. 根据id查询某一个文档<br>GET &#x2F;movie_index&#x2F;movie&#x2F;3</p><p>##10. 根据文档id，删除某一个文档<br>DELETE &#x2F;movie_index&#x2F;_doc&#x2F;3</p><p>POST &#x2F;_forcemerge</p><p>##11. put 对已经存在的文档进行替换(幂等性)<br>PUT &#x2F;movie_index&#x2F;_doc&#x2F;3<br>{<br>  “id”:300,<br>  “name”:”incident red sea”,<br>  “doubanScore”:5.0,<br>  “actorList”:[<br>{“id”:4,”name”:”zhang cuishan”}<br>]<br>}</p><p>##12. post 进行新增操作，无法保证幂等性</p><h3 id="1-根据主键保证幂等性"><a href="#1-根据主键保证幂等性" class="headerlink" title="1. 根据主键保证幂等性"></a>1. 根据主键保证幂等性</h3><p>POST &#x2F;movie_index&#x2F;_doc&#x2F;<br>{<br>  “id”:300,<br>  “name”:”incident red sea”,<br>  “doubanScore”:5.0,<br>  “actorList”:[<br>{“id”:4,”name”:”zhang cuishan111”}<br>]<br>}</p><p>GET &#x2F;movie_index&#x2F;_search</p><p>GET &#x2F;movie_index&#x2F;movie&#x2F;1</p><p>POST &#x2F;movie_index&#x2F;movie&#x2F;1&#x2F;_update<br>{<br>  “doc”:  { “name”: “新的字段值” }<br>}</p><p>POST &#x2F;movie_index&#x2F;_update_by_query<br>{<br>    “query”: {<br>      “match”:{<br>        “actorList.id”:1<br>      }<br>    },<br>    “script”: {<br>      “lang”: “painless”,<br>      “source”:”for(int i&#x3D;0;i&lt;ctx._source.actorList.length;i++){if(ctx._source.actorList[i].id&#x3D;&#x3D;3){ctx._source.actorList[i].name&#x3D;’tttt’}}”<br>    }<br>}</p><p>GET &#x2F;movie_index&#x2F;_search</p><p>POST &#x2F;movie_index&#x2F;_delete_by_query<br>{<br>  “query”: {<br>    “match_all”: {}<br>  }<br>}</p><h3 id="2-批量添加两个document"><a href="#2-批量添加两个document" class="headerlink" title="2. 批量添加两个document"></a>2. 批量添加两个document</h3><p>POST &#x2F;movie_index&#x2F;movie&#x2F;_bulk<br>{“index”:{“_id”:66}}<br>{“id”:300,”name”:”incident red sea”,”doubanScore”:5.0,”actorList”:[{“id”:4,”name”:”zhang cuishan”}]}<br>{“index”:{“_id”:88}}<br>{“id”:300,”name”:”incident red sea”,”doubanScore”:5.0,”actorList”:[{“id”:4,”name”:”zhang cuishan”}]}</p><p>POST &#x2F;movie_index&#x2F;movie&#x2F;_bulk<br>{“update”:{“_id”:”66”}}<br>{“doc”: { “name”: “wudangshanshang” } }<br>{“delete”:{“_id”:”88”}}</p><p>#——–查询操作——-<br>##1. 查询出当前索引中的全部数据<br>GET &#x2F;movie_index&#x2F;_search</p><p>GET &#x2F;movie_index&#x2F;_search?q&#x3D;_id:66</p><p>##2. 查询全部<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “match_all”: {}<br>  }<br>}</p><p>##3. 根据电影的名称进行查询<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “match”: {<br>      “name”: “operation red sea”<br>    }<br>  }<br>}</p><p>GET &#x2F;movie_index</p><p>##4. 按分词进行查询<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “match”: {<br>      “actorList.name”: “zhang han yu”<br>    }<br>  }<br>}</p><p>##5. 按短语查询  相当于like<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “match_phrase”: {<br>      “actorList.name”: “zhang han yu”<br>    }<br>  }<br>}</p><p>##6. 不分词 通过精准匹配进行查询  term精准匹配<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “term”: {<br>       “actorList.name.keyword”:”zhang han yu”<br>    }<br>  }<br>}</p><p>##7. 容错匹配（对于中文，实现并不太好）<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “fuzzy”: {<br>      “name”: “radd”<br>    }<br>  }<br>}</p><p>##8. 先匹配 再过滤<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “match”: {<br>      “name”: “red”<br>    }<br>  },<br>  “post_filter”: {<br>    “term”: {<br>      “actorList.id”: “3”<br>    }<br>  }<br>}</p><p>##9. 匹配和过滤同时（推荐使用）<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “bool”: {<br>      “must”: [<br>        {<br>          “match”: {<br>            “name”: “red”<br>          }<br>        }<br>      ],<br>      “filter”: {<br>        “term”: {<br>          “actorList.id”: “3”<br>        }<br>      }<br>    }<br>  }<br>}</p><p>##10. 范围过滤  ，将豆瓣评分在6到9的文档查询出来<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “range”: {<br>      “doubanScore”: {<br>        “gte”: 6,<br>        “lte”: 9<br>      }<br>    }<br>  }<br>}</p><p>##11. 按照豆瓣评分降序排序，并包含red<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “match”: {<br>      “name”: “red”<br>    }<br>  },<br>  “sort”: [<br>    {<br>      “doubanScore”: {<br>        “order”: “asc”<br>      }<br>    }<br>  ]<br>}</p><p>##12. 分页查询，from从什么开始，size显示几条<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “from”: 0,<br>  “size”: 2<br>}</p><p>##13. 查询指定字段<br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “_source”: [“name”, “doubanScore”]<br>}</p><p>##14. 高亮显示，pre_tags设置标签，默认为<em><br>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “query”: {<br>    “match”: {<br>      “name”: “red”<br>    }<br>  },<br>  “highlight”: {<br>    “fields”:  {“name”:{} },<br>    “pre_tags”: “<a>“,<br>    “post_tags”: “</a>“<br>  }<br>}</p><p>##15. 需求1：取出每个演员共参演了多少部电影</p><h3 id="aggs-聚合"><a href="#aggs-聚合" class="headerlink" title="aggs 聚合"></a>aggs 聚合</h3><h3 id="term-精准匹配"><a href="#term-精准匹配" class="headerlink" title="term  精准匹配"></a>term  精准匹配</h3><h3 id="terms-聚合操作，相当于groupBy"><a href="#terms-聚合操作，相当于groupBy" class="headerlink" title="terms 聚合操作，相当于groupBy"></a>terms 聚合操作，相当于groupBy</h3><h3 id="myAggs是聚合操作的名字，可以随意取"><a href="#myAggs是聚合操作的名字，可以随意取" class="headerlink" title="myAggs是聚合操作的名字，可以随意取"></a>myAggs是聚合操作的名字，可以随意取</h3><p>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “aggs”: {<br>    “myAggs”: {<br>      “terms”: {<br>        “field”: “actorList.name.keyword”,<br>        “size”: 10<br>      }<br>    }<br>  }<br>}</p><p>##16. 需求2：每个演员参演电影的平均分是多少，并按评分排序</p><p>GET &#x2F;movie_index&#x2F;_search<br>{<br>  “aggs”: {<br>    “groupByName”: {<br>      “terms”: {<br>        “field”: “actorList.name.keyword”,<br>        “size”: 10,<br>        “order”: {<br>          “avg_score”: “asc”<br>        }<br>      },<br>      “aggs”: {<br>        “avg_score”: {<br>          “avg”: {<br>            “field”: “doubanScore”<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p><p>##17. 分词</p><h3 id="1-英文默认分词规则"><a href="#1-英文默认分词规则" class="headerlink" title="1. 英文默认分词规则"></a>1. 英文默认分词规则</h3><p>GET &#x2F;_analyze<br>{<br>  “text”: “hello world”<br>}</p><h3 id="2-中文默认分词规则"><a href="#2-中文默认分词规则" class="headerlink" title="2. 中文默认分词规则"></a>2. 中文默认分词规则</h3><p>GET &#x2F;_analyze<br>{<br>  “text”: “蓝瘦香菇”,<br>  “analyzer”: “ik_smart”<br>}</p><p>GET &#x2F;_analyze<br>{<br>  “text”: “蓝瘦香菇”,<br>  “analyzer”: “ik_max_word”<br>}</p><p>GET &#x2F;movie_index</p><h3 id="3-自动定义mapping"><a href="#3-自动定义mapping" class="headerlink" title="3. 自动定义mapping"></a>3. 自动定义mapping</h3><p>PUT &#x2F;movie_chn_1&#x2F;movie&#x2F;1<br>{ “id”:1,<br>  “name”:”红海行动”,<br>  “doubanScore”:8.5,<br>  “actorList”:[<br>  {“id”:1,”name”:”张译”},<br>  {“id”:2,”name”:”海清”},<br>  {“id”:3,”name”:”张涵予”}<br> ]<br>}<br>PUT &#x2F;movie_chn_1&#x2F;movie&#x2F;2<br>{<br>  “id”:2,<br>  “name”:”湄公河行动”,<br>  “doubanScore”:8.0,<br>  “actorList”:[<br>{“id”:3,”name”:”张涵予”}<br>]<br>}</p><p>PUT &#x2F;movie_chn_1&#x2F;movie&#x2F;3<br>{<br>  “id”:3,<br>  “name”:”红海事件”,<br>  “doubanScore”:5.0,<br>  “actorList”:[<br>{“id”:4,”name”:”张三丰”}<br>]<br>}</p><p>GET &#x2F;movie_chn_1&#x2F;_search<br>{<br>  “query”: {<br>    “match”: {<br>      “name”: “海行”<br>    }<br>  }<br>}</p><p>GET &#x2F;movie_chn_1&#x2F;_mapping</p><p>##18. 自定义mapping<br>DELETE movie_chn_2</p><p>PUT movie_chn_2<br>{<br>  “mappings”: {<br>    “movie”:{<br>      “properties”: {<br>        “id”:{<br>          “type”: “long”<br>        },<br>        “name”:{<br>          “type”: “keyword”<br>        },<br>        “doubanScore”:{<br>          “type”: “double”<br>        },<br>        “actorList”:{<br>          “properties”: {<br>            “id”:{<br>              “type”:”long”<br>            },<br>            “name”:{<br>              “type”:”keyword”<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p><p>PUT &#x2F;movie_chn_2&#x2F;movie&#x2F;1<br>{ “id”:1,<br>  “name”:”红海行动”,<br>  “doubanScore”:8.5,<br>  “actorList”:[<br>  {“id”:1,”name”:”张译”},<br>  {“id”:2,”name”:”海清”},<br>  {“id”:3,”name”:”张涵予”}<br> ]<br>}<br>PUT &#x2F;movie_chn_2&#x2F;movie&#x2F;2<br>{<br>  “id”:2,<br>  “name”:”湄公河行动”,<br>  “doubanScore”:8.0,<br>  “actorList”:[<br>{“id”:3,”name”:”张涵予”}<br>]<br>}</p><p>PUT &#x2F;movie_chn_2&#x2F;movie&#x2F;3<br>{<br>  “id”:3,<br>  “name”:”红海事件”,<br>  “doubanScore”:5.0,<br>  “actorList”:[<br>{“id”:4,”name”:”张三丰”}<br>]<br>}</p><p>GET &#x2F;movie_chn_2&#x2F;_mapping</p><p>GET &#x2F;movie_chn_2&#x2F;_search<br>{<br>  “query”: {<br>    “match”: {<br>      “name”: “海行”<br>    }<br>  }<br>}</p><p>POST &#x2F;_reindex<br>{<br>  “source”: {}<br>  , “dest”: {}<br>}</p><p>##19. 创建索引  并指定别名<br>PUT movie_chn_3<br>{<br>  “aliases”: {<br>      “movie_chn_3_aliase”: {}<br>  },<br>  “mappings”: {<br>    “movie”:{<br>      “properties”: {<br>        “id”:{<br>          “type”: “long”<br>        },<br>        “name”:{<br>          “type”: “text”,<br>          “analyzer”: “ik_smart”<br>        },<br>        “doubanScore”:{<br>          “type”: “double”<br>        },<br>        “actorList”:{<br>          “properties”: {<br>            “id”:{<br>              “type”:”long”<br>            },<br>            “name”:{<br>              “type”:”keyword”<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p><p>GET &#x2F;_cat&#x2F;indices</p><p>GET &#x2F;_cat&#x2F;aliases</p><p>POST &#x2F;_aliases<br>{<br>  “actions”: [<br>    {<br>      “add”: {<br>        “index”: “movie_chn_3”,<br>        “alias”: “movie_chn_3_a2”<br>      }<br>    }<br>  ]<br>}</p><p>GET &#x2F;movie_chn_3&#x2F;_search</p><p>GET &#x2F;movie_chn_3_a2&#x2F;_search</p><p>GET &#x2F;_cat&#x2F;aliases</p><p>POST &#x2F;_aliases<br>{<br>  “actions”: [<br>    {<br>      “remove”: {“index”: “movie_chn_3”,”alias”: “movie_chn_3_a2”}<br>    }<br>  ]<br>}</p><p>GET &#x2F;movie_chn_1&#x2F;_search</p><p>GET &#x2F;movie_chn_2&#x2F;_search</p><p>POST  _aliases<br>{<br>    “actions”: [<br>        { “add”:    { “index”: “movie_chn_1”, “alias”: “movie_chn_query” }},<br>        { “add”:    { “index”: “movie_chn_2”, “alias”: “movie_chn_query” }}<br>    ]<br>}</p><p>GET &#x2F;movie_chn_query&#x2F;_search</p><p>POST  _aliases<br>{<br>    “actions”: [<br>        {<br>          “add”:<br>          {<br>            “index”: “movie_chn_1”,<br>            “alias”: “movie_chn_1_sub_query”,<br>            “filter”: {<br>                “term”: {  “actorList.id”: “4”}<br>            }<br>          }<br>        }<br>    ]<br>}</p><p>GET &#x2F;movie_chn_1_sub_query&#x2F;_search</p><p>POST &#x2F;_aliases<br>{<br>    “actions”: [<br>        { “remove”: { “index”: “movie_chn_1”, “alias”: “movie_chn_query” }},<br>        { “remove”: { “index”: “movie_chn_2”, “alias”: “movie_chn_query” }},<br>        { “add”:    { “index”: “movie_chn_3”, “alias”: “movie_chn_query” }}<br>    ]<br>}</p><p>##20. 创建模板<br>PUT _template&#x2F;template_movie0523<br>{<br>  “index_patterns”: [“movie_test*”],<br>  “settings”: {<br>    “number_of_shards”: 1<br>  },<br>  “aliases” : {<br>    “{index}-query”: {},<br>    “movie_test-query”:{}<br>  },<br>  “mappings”: {<br>    “_doc”: {<br>      “properties”: {<br>        “id”: {<br>          “type”: “keyword”<br>        },<br>        “movie_name”: {<br>          “type”: “text”,<br>          “analyzer”: “ik_smart”<br>        }<br>      }<br>    }<br>  }<br>}</p><p>##21. 创建索引，并创建文档<br>POST movie_test_202010&#x2F;_doc<br>{<br>  “id”:”333”,<br>  “name”:”zhang3”<br>}</p><p>GET &#x2F;movie_test_202010-query&#x2F;_mapping</p><p>GET &#x2F;_cat&#x2F;templates</p><p>GET &#x2F;_template&#x2F;template_movie*</p>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletableFuture使用</title>
      <link href="/2022/07/19/39.CompletableFuture/"/>
      <url>/2022/07/19/39.CompletableFuture/</url>
      
        <content type="html"><![CDATA[<p>#1. CompletableFuture</p><h2 id="1-0-Future"><a href="#1-0-Future" class="headerlink" title="1.0 Future"></a>1.0 Future</h2><p>学习CompletableFuture之前了解下Future，它是Java5新加的一个接口，它提供了一种异步并行计算的功能。如果主线程需要执行一个很耗时的计算任务，我们就可以通过future把这个任务放到异步线程中执行。主线程继续处理其他任务，处理完成后，再通过Future获取计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//1. 执行业务逻辑1</span></span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.submit(futureTask1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 模拟主线程其它操作耗时</span></span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 执行业务逻辑2</span></span><br><span class="line">    FutureTask&lt;String&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.submit(futureTask2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 获取结果</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> futureTask1.get();</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> futureTask2.get();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;总共用时&quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<strong>future+线程池</strong>异步配合，提高了程序的执行效率，避免了主线程串行执行计算。</p><p>但是Future对于结果的获取，不是很友好，只能通过<strong>阻塞</strong>或者<strong>轮询的方式</strong>得到任务的结果。</p><ul><li>Future.get() 就是阻塞调用，在线程获取结果之前<strong>get方法会一直阻塞</strong>；</li><li>Future.get(long timeout, TimeUnit unit)，可以设置一个超时时间，<strong>未在设置时间范围内返回结果会抛出TimeoutException异常；</strong></li><li>Future提供了一个isDone方法，可以在程序中<strong>轮询这个方法查询</strong>执行结果；</li></ul><p><strong>阻塞的方式和异步编程的设计理念相违背，而轮询的方式会耗费无谓的CPU资源</strong>。因此，JDK8设计出CompletableFuture。CompletableFuture提供了一种<strong>观察者模式类似的机制</strong>，可以让任务执行完成后通知监听的一方。</p><h2 id="1-1含义"><a href="#1-1含义" class="headerlink" title="1.1含义"></a>1.1含义</h2><p>CompletableFuture字面翻译过来，就是“可完成的Future”。同传统的Future相比较，CompletableFuture能够主动设置计算的结果值（主动终结计算过程，即completable），从而在某些场景下主动结束阻塞等待。而Future由于不能主动设置计算结果值，一旦调用get()进行阻塞等待，要么当计算结果产生，要么超时，才会返回。</p><p>CompletableFuture是如何被主动完成的。在下面这段代码中，由于调用了complete方法，所以最终的打印结果是“manual test”，而不是”test”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;failed test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果计算没完成的话就将返回传入的值，这里即：manual test</span></span><br><span class="line">future.complete(<span class="string">&quot;manual test&quot;</span>);</span><br><span class="line">System.out.println(future.join());</span><br></pre></td></tr></table></figure><p>可以发现，使用CompletableFuture，代码简洁了很多。CompletableFuture的supplyAsync方法，提供了异步执行的功能，线程池也不用单独创建了。实际上，它CompletableFuture使用了默认线程池：<code>ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</code></p><h2 id="1-2-CompletableFuture的get-和join-区别"><a href="#1-2-CompletableFuture的get-和join-区别" class="headerlink" title="1.2 CompletableFuture的get()和join()区别"></a>1.2 CompletableFuture的get()和join()区别</h2><h3 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h3><ul><li><p><strong>get()</strong> 方法抛出的是checkException（受检异常）， <strong>需要用户手动处理</strong>（抛出或者 try catch）</p></li><li><p><strong>join() <strong>方法抛出的是uncheckException（非受检异常)，</strong>不会强制开发者强制捕捉</strong></p></li></ul><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>java.lang.Throwable</p><ul><li>Error</li><li>Exception<ul><li>uncheckException - RuntimeException</li><li>checkException -  IOException</li></ul></li></ul><p>异常分为两种，运行时异常(也就是uncheckException)和已检查异常checkException；</p><ul><li><p>运行时异常包括平常遇到的各种异常，如空指针异常，数据格式异常等一系列异常，这种异常是可以不捕获的，可通过throws抛出异常，交给别的代码或者JAVA虚拟机来完成。</p></li><li><p>checkException是必须要处理的，也就是不能抛出，必须通过try-catch来完成，不处理的话是不能进行编译的。但是checkException不是一个具体的异常类型，它只是一个概念。所以你判断一个异常是已检查异常还是未检查异常，只需要通过抛出这个异常就可以知道了。</p></li></ul><p><strong>Error类</strong><br>Error是系统中的错误，程序员是不能通过代码进行逻辑捕获的，这个错误是在程序编译时出现的，只能通过修改代码才能改正。属于uncheckedException。<br>如：内存空间不足，方法调用栈溢等。</p><p><strong>受检异常(checkedException)</strong><br>除去RuntimeException和Error外的异常都属于受检异常，该异常需要强制处理(<a href="https://so.csdn.net/so/search?q=throws&spm=1001.2101.3001.7020">throws</a>给方法调用者，或者在发生的方法中try&#x2F;catch掉)。</p><p><strong>常见受检异常如下：</strong><br>Java.lang.ClassNotFoundException –找不到类异常<br>Java.lang.CloneNotSupportedException –clone异常-未实现Cloneable接口<br>Java.lang.IOException –IO流异常<br>Java.lang.SqlException –sql异常<br>Java.lang.IllegalAccessException –访问权限异常-private<br>Java.lang.DataFormatException –数据格式化异常<br>Java.lang.NoSuchFieldException –反射异常<br>Java.lang.NoSuchMethodException –方法未找到异常</p><p><strong>非受检异常(uncheckedException)</strong><br>RuntimeException是所有非受检异常类的基类，即所有非受检异常继承自该类。该类异常不强制处理，但通常开发人员为了代码健全会进行封装处理，该异常发生的原因也通常是程序员对逻辑的考虑不周而出现的。</p><p>常见非受检异常如下：<br>Java.lang.ClassCastException –类型转换异常<br>Java.lang.NumberFormatException –数字转换异常<br>Java.lang.NullPointerException –空指针异常<br>Java.lang.IndexOutOfBoundsException –索引越界异常<br>Java.lang.ArrayIndexOutOfBoundsException –数组下标越界异常<br>Java.lang.StringIndexOutOfBoundsException –字符串截取下标越界异常<br>Java.lang.NegativeArraySizeException –数组大小为负数异常<br>Java.lang.ArithmeticException –算术异常<br>Java.lang.ArrayStoreException –数组元素不匹配异常<br>Java.lang.EnumConstantNotPresentException –枚举常量不存在异常<br>Java.lang.IllegalArgumentException –非法参数异常<br>Java.lang.IllegalThreadStateException –线程异常<br>Java.lang.IllegalMonitorStateException –违法的监控状态异常<br>Java.lang.TypeNotPresentException –类型不存在异常</p><h2 id="1-4-创建异步方法"><a href="#1-4-创建异步方法" class="headerlink" title="1.4 创建异步方法"></a>1.4 创建异步方法</h2><p>CompletableFuture创建异步任务，一般有supplyAsync和runAsync两个方法</p><ul><li>supplyAsync执行CompletableFuture任务，支持返回值</li><li>runAsync执行CompletableFuture任务，没有返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//无返回值 使用默认线程池 ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(</span><br><span class="line">        () -&gt; System.out.println(<span class="string">&quot;无返回值&quot;</span>)</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//可以自定义线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//无返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(</span><br><span class="line">        () -&gt; System.out.println(<span class="string">&quot;无返回值&quot;</span>), executor</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(</span><br><span class="line">        () -&gt; System.out.println(<span class="string">&quot;无返回值&quot;</span>), executor</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//runAsync的future没有返回值，输出null</span></span><br><span class="line">    System.out.println(runFuture.join());</span><br><span class="line">    <span class="comment">//supplyAsync的future，有返回值</span></span><br><span class="line">    System.out.println(supplyFuture.join());</span><br><span class="line">    pool.shutdown(); <span class="comment">// 线程池需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-任务异步回调"><a href="#1-5-任务异步回调" class="headerlink" title="1.5 任务异步回调"></a>1.5 任务异步回调</h2><p><strong>方法一览：</strong></p><p><img src="C:\Users\wshoto\Documents\blog\picture\CompletableFuture.png"></p><h3 id="1-thenRun-x2F-thenRunAsync"><a href="#1-thenRun-x2F-thenRunAsync" class="headerlink" title="1. thenRun&#x2F;thenRunAsync"></a>1. thenRun&#x2F;thenRunAsync</h3><p>thenRun方法：做完第一个任务后，再做第二个任务。某个任务执行完成后，执行回调方法；但是<strong>前后两个任务没有参数传递，第二个任务也没有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行第一个任务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;第一个任务返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">thenRunFuture</span> <span class="operator">=</span> future.thenRun(</span><br><span class="line">        () -&gt; System.out.println(<span class="string">&quot;接着执行第二个任务&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(thenRunFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">执行第一个任务</span><br><span class="line">接着执行第二个任务</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h3><p><strong>thenRun 和thenRunAsync区别：</strong></p><p>如果你执行第一个任务的时候，传入了一个自定义线程池：</p><ul><li>调用thenRun方法执行第二个任务时，则第二个任务和第一个任务是<strong>共用同一个线程池</strong>。</li><li>调用thenRunAsync执行第二个任务时，则第一个任务使用的是你自己传入的线程池，<strong>第二个任务使用的是ForkJoin线程池</strong></li></ul><p>后面介绍的thenAccept和thenAcceptAsync，thenApply和thenApplyAsync等，它们之间的区别也是这个。</p><h3 id="2-thenAccept-x2F-thenAcceptAsync"><a href="#2-thenAccept-x2F-thenAcceptAsync" class="headerlink" title="2. thenAccept&#x2F;thenAcceptAsync"></a>2. thenAccept&#x2F;thenAcceptAsync</h3><p>CompletableFuture的thenAccept方法表示，第一个任务执行完成后，执行第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，但是回调方法是<strong>没有返回值</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future执行第一个任务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; thenAcceptFuture = future.thenAccept((param) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenAcceptFuture接受第一个任务的入参=&quot;</span> + param);</span><br><span class="line">        System.out.println(<span class="string">&quot;thenAcceptFuture接着执行第二个任务&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;thenAcceptFuture结果=&quot;</span>+thenAcceptFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">future执行第一个任务</span><br><span class="line">thenAcceptFuture接受第一个任务的入参=abc</span><br><span class="line">thenAcceptFuture接着执行第二个任务</span><br><span class="line">thenAcceptFuture结果=<span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="3-thenApply-x2F-thenApplyAsync"><a href="#3-thenApply-x2F-thenApplyAsync" class="headerlink" title="3. thenApply&#x2F;thenApplyAsync"></a>3. thenApply&#x2F;thenApplyAsync</h3><p>CompletableFuture的thenApply方法表示，第一个任务执行完成后，执行第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，并且回调方法是有返回值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future执行第一个任务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;future第一个任务返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; thenApplyFuture = future.thenApply((param) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApplyFuture任务1入参打印出来=&quot;</span> + param);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;thenApplyFuture第二个任务返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;thenApplyFuture获取结果=&quot;</span> + thenApplyFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">future执行第一个任务</span><br><span class="line">thenApplyFuture任务<span class="number">1</span>入参打印出来=future第一个任务返回值</span><br><span class="line">thenApplyFuture获取结果=thenApplyFuture第二个任务返回值</span><br></pre></td></tr></table></figure><h3 id="4-exceptionally"><a href="#4-exceptionally" class="headerlink" title="4. exceptionally"></a>4. exceptionally</h3><p>CompletableFuture的exceptionally方法表示，某个任务执行异常时，执行的回调方法;并且有<strong>抛出异常作为参数</strong>，传递到回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future执行第一个任务&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; exceptionFuture = future.exceptionally((exception) -&gt; &#123;</span><br><span class="line">        <span class="comment">// exception.printStackTrace();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;你的程序异常啦&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(exceptionFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">future执行第一个任务</span><br><span class="line">你的程序异常啦</span><br></pre></td></tr></table></figure><h3 id="5-whenComplete"><a href="#5-whenComplete" class="headerlink" title="5. whenComplete"></a>5. whenComplete</h3><p>CompletableFuture的whenComplete方法表示，某个任务执行完成后，执行的回调方法，<strong>无返回值</strong>；并且whenComplete方法返回的CompletableFuture的<strong>result是上个任务的结果</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务一当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            int s = 10/0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;future任务一返回值&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; whenCompleteFuture = future.whenComplete((param,exception) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务二当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;param=【&quot;</span>+param+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;exception=【&quot;</span>+exception+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;最后返回值=&quot;</span>+whenCompleteFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">任务一当前线程名称：ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">任务二当前线程名称：ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">param=【future任务一返回值】</span><br><span class="line">exception=【<span class="literal">null</span>】</span><br><span class="line">最后返回值=future任务一返回值</span><br></pre></td></tr></table></figure><h3 id="6-handle"><a href="#6-handle" class="headerlink" title="6. handle"></a>6. handle</h3><p>CompletableFuture的handle方法表示，<strong>某个任务执行完成后，执行回调方法，并且是有返回值的</strong>；并且handle方法返回的CompletableFuture的result是<strong>回调方法</strong>执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务一当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;future返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; handleFuture = future.handle((param, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handleFuture当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;handleFuture入參&quot;</span>+param);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;handleFuture返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;最終結果=&quot;</span>+handleFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">任务一当前线程名称：ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">handleFuture当前线程名称：ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">handleFuture入參future返回值</span><br><span class="line">最終結果=handleFuture返回值</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-6-多任务组合处理"><a href="#1-6-多任务组合处理" class="headerlink" title="1.6 多任务组合处理"></a>1.6 多任务组合处理</h2><p><strong>方法一览：</strong></p><p><img src="C:\Users\wshoto\Documents\blog\picture\CompletableFuture2.png"></p><h3 id="1-AND组合关系"><a href="#1-AND组合关系" class="headerlink" title="1. AND组合关系"></a>1. AND组合关系</h3><p>thenCombine &#x2F; thenAcceptBoth &#x2F; runAfterBoth都表示：<strong>将两个CompletableFuture组合起来，只有这两个都正常执行完了，才会执行某个任务</strong>。</p><p>区别在于：</p><ul><li>thenCombine：会将两个任务的执行结果作为方法入参，传递到指定方法中，且<strong>有返回值</strong></li><li>thenAcceptBoth：会将两个任务的执行结果作为方法入参，传递到指定方法中，且<strong>无返回值</strong></li><li>runAfterBoth：不会把执行结果当做方法入参，且没有返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; first = CompletableFuture.completedFuture(<span class="string">&quot;第一个异步任务&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;第二个异步任务&quot;</span>, executor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (w, s) -&gt; System.out.println(s) 是第三个任务</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = second.thenCombineAsync(first, (var1, var2) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;var1=&quot;</span> + var1);</span><br><span class="line">        System.out.println(<span class="string">&quot;var2=&quot;</span> + var2);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;两个异步任务的组合&quot;</span>;</span><br><span class="line">    &#125;, executor);</span><br><span class="line">    System.out.println(<span class="string">&quot;最終結果=&quot;</span> + future.join());</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">var1=第二个异步任务</span><br><span class="line">var2=第一个异步任务</span><br><span class="line">最終結果=两个异步任务的组合</span><br></pre></td></tr></table></figure><h3 id="2-OR组合关系"><a href="#2-OR组合关系" class="headerlink" title="2. OR组合关系"></a>2. OR组合关系</h3><p>applyToEither &#x2F; acceptEither &#x2F; runAfterEither 都表示：将两个CompletableFuture组合起来，只要其中一个执行完了,就会执行某个任务。</p><p>区别在于：</p><ul><li>applyToEither：会将已经执行完成的任务，作为方法入参，传递到指定方法中，且有返回值</li><li>acceptEither: 会将已经执行完成的任务，作为方法入参，传递到指定方法中，且无返回值</li><li>runAfterEither： 不会把执行结果当做方法入参，且没有返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第一个异步任务，休眠2秒，保证它执行晚点</span></span><br><span class="line">            <span class="comment">//                Thread.sleep(2000L);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;执行第一个异步任务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;第一个任务异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;第一个任务返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;执行第二个异步任务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;第二个任务异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;第二个任务返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三个任务</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; result = future.acceptEitherAsync(first, (param) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三个任务执行=&quot;</span> + param);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;最終結果=&quot;</span> + result.join());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">执行第一个异步任务</span><br><span class="line">第三个任务执行=第一个任务返回值</span><br><span class="line">最終結果=<span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="3-AllOf组合关系"><a href="#3-AllOf组合关系" class="headerlink" title="3. AllOf组合关系"></a>3. AllOf组合关系</h3><p>AllOf返回的CompletableFuture是多个任务都执行完成后才会执行，只有有一个任务执行异常，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回null。常见用法：</p><p><code>CompletableFuture.allOf(c1, c2, c3).join(); </code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务1睡觉5秒！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务1执行完了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务1结果&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务2执行完了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务2结果&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future3 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务3执行前&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在继续程序之前等待传入的一组CompletableFuture完成,如果有异常的话，会等最后一个任务完成才会抛异常，</span></span><br><span class="line">    CompletableFuture.allOf(future1, future2).join();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果要获取每个CompletableFuture的结果需要单独获取</span></span><br><span class="line">    future1.whenComplete((s, exception) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future1=&quot;</span> + s);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    future2.whenComplete((s, exception) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future2=&quot;</span> + s);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">任务<span class="number">1</span>睡觉<span class="number">5</span>秒！</span><br><span class="line">任务<span class="number">2</span>执行完了</span><br><span class="line">任务<span class="number">1</span>执行完了</span><br><span class="line">future1=任务<span class="number">1</span>结果</span><br><span class="line">future2=任务<span class="number">2</span>结果</span><br></pre></td></tr></table></figure><p>AllOf大数据量批量处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// 多线程处理</span></span><br><span class="line">    List&lt;String&gt; resultBo = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; paramList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    CompletableFuture[] completableFutures = paramList.stream().map(s -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            result.add(s);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;, threadPool);</span><br><span class="line">    &#125;).toArray(CompletableFuture[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待所有任务执行完成，如果有异常则抛出异常</span></span><br><span class="line">    CompletableFuture.allOf(completableFutures).join();</span><br><span class="line"><span class="comment">//单独获取每个CompletableFuture结果</span></span><br><span class="line">    <span class="keyword">for</span> (CompletableFuture future : completableFutures) &#123;</span><br><span class="line">        future.whenComplete((result, throwable) -&gt; &#123;</span><br><span class="line">            resultBo.addAll((List&lt;String&gt;) result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-AnyOf组合关系"><a href="#4-AnyOf组合关系" class="headerlink" title="4. AnyOf组合关系"></a>4. AnyOf组合关系</h3><p>任意一个任务执行完，就执行anyOf返回的CompletableFuture。如果执行的任务异常，anyOf的CompletableFuture，执行get方法，会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;future1执行完了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future2执行完了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;future2结果&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Object&gt; anyOfFuture = CompletableFuture</span><br><span class="line">        .anyOf(future1, future2)</span><br><span class="line">        .whenComplete((param, exception) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;anyOfFuture param=&quot;</span>+param);</span><br><span class="line">            System.out.println(<span class="string">&quot;anyOfFuture exception=&quot;</span>+exception);</span><br><span class="line">            System.out.println(<span class="string">&quot;anyOfFuture finish&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">join</span> <span class="operator">=</span> anyOfFuture.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;最終結果=&quot;</span> + join);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">future2执行完了</span><br><span class="line">anyOfFuture param=future2结果</span><br><span class="line">anyOfFuture exception=<span class="literal">null</span></span><br><span class="line">anyOfFuture finish</span><br><span class="line">最終結果=future2结果</span><br></pre></td></tr></table></figure><h3 id="5-thenCompose"><a href="#5-thenCompose" class="headerlink" title="5. thenCompose"></a>5. thenCompose</h3><p>thenCompose方法会在A任务执行完成后，将A任务的执行结果,作为方法入参,去执行指定的方法。该方法会返回一个新的CompletableFuture实例</p><ul><li>如果该CompletableFuture实例的result不为null，则返回一个基于该result新的CompletableFuture实例；</li><li>如果该CompletableFuture实例为null，然后就执行这个新任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.completedFuture(<span class="string">&quot;第一个任务&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;第二个任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future3 = future2.thenCompose(data -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future3=&quot;</span> + data);</span><br><span class="line">        <span class="keyword">return</span> future1; <span class="comment">//使用第一个任务作为返回</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//future3的结果是他返回的future1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;最終結果=&quot;</span>+future3.join());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">future3=第二个任务</span><br><span class="line">最終結果=第一个任务</span><br></pre></td></tr></table></figure><h2 id="1-7-CompletableFuture使用有哪些注意点"><a href="#1-7-CompletableFuture使用有哪些注意点" class="headerlink" title="1.7 CompletableFuture使用有哪些注意点"></a>1.7 CompletableFuture使用有哪些注意点</h2><ul><li>Future需要获取返回值才能获取异常信息</li><li>他的get()和join() 方法是阻塞的</li><li>需要注意默认线程池，即<code>ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</code></li><li>自定义线程池是<code>DiscardPolicy</code>或者<code>DiscardOldestPolicy</code>饱和策略</li></ul><p><strong>1.Future需要获取返回值，才能获取异常信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5L</span>,</span><br><span class="line">    TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">666</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b / a;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;,pool).thenAccept(System.out::println);</span><br><span class="line">   </span><br><span class="line"> <span class="comment">//如果不加 get()方法这一行，看不到异常信息</span></span><br><span class="line"> <span class="comment">//future.get();</span></span><br></pre></td></tr></table></figure><p><strong>2.Future需要获取返回值，才能获取到异常信息。</strong></p><p>如果不加 get()&#x2F;join()方法，看不到异常信息。使用的时候，注意一下考虑是否加try…catch…或者使用exceptionally方法。</p><p>CompletableFuture的get()方法是阻塞的。</p><p>CompletableFuture的get()方法是阻塞的，如果使用它来获取异步调用的返回值，需要添加超时时间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"> CompletableFuture.<span class="keyword">get</span>();</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">CompletableFuture.<span class="keyword">get</span>(<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><strong>3.默认线程池的注意点</strong></p><p>CompletableFuture代码中又使用了默认的线程池，即<code>ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</code> 处理的线程个数是电脑CPU核数-1。在<strong>大量请求过来的时候，处理逻辑复杂的话，响应会很慢</strong>。一般建议使用自定义线程池，优化线程池配置参数。</p><p><strong>4.自定义线程池时，注意饱和策略</strong></p><p>CompletableFuture的get()方法是阻塞的，我们一般建议使用<code>future.get(3, TimeUnit.SECONDS)</code>。并且一般建议使用自定义线程池。</p><p>但是如果线程池拒绝策略是<code>DiscardPolicy</code>或者<code>DiscardOldestPolicy</code>，当线程池饱和时，会直接丢弃任务，不会抛弃异常。因此建议，CompletableFuture线程池策略<strong>最好使用AbortPolicy</strong>，然后耗时的异步线程，做好<strong>线程池隔离</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> CompletableFuture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的常用注解</title>
      <link href="/2022/07/07/33.SSM%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/07/07/33.SSM%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>copy by  <a href="https://blog.csdn.net/guorui_java/article/details/107347754">https://blog.csdn.net/guorui_java/article/details/107347754</a></p></blockquote><h2 id="一、Spring的常用注解"><a href="#一、Spring的常用注解" class="headerlink" title="一、Spring的常用注解"></a>一、Spring的常用注解</h2><h3 id="1、给容器中注入组件"><a href="#1、给容器中注入组件" class="headerlink" title="1、给容器中注入组件"></a>1、给容器中注入组件</h3><p>（1）包扫描+组件标注注解</p><p>@Component：泛指各种组件</p><p>@Controller、@Service、@Repository都可以称为@Component。</p><p>@Controller：控制层</p><p>@Service：业务层</p><p>@Repository：数据访问层</p><p>（2）@Bean</p><p>导入第三方包里面的注解</p><p>（3）@Import</p><p>@Import(要导入到容器中的组件)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Color.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig2</span> &#123;</span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Bean(&quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是Person&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;素小暖&quot;</span>,<span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ImportSelector：返回需要导入的组件的全类名数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="comment">//返回值就是导入容器的组件全类目</span></span><br><span class="line">    <span class="comment">// AnnotationMetadata 当前标注@Import注解的类的所有注解信息</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="comment">//importingClassMetadata.get</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.atguigu.bean.Blue&quot;</span>,<span class="string">&quot;com.atguigu.bean.Red&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ImportBeanDefinitionRegistrar：手动注册bean到容器中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * AnnotationMetadata：当前类的注解信息</span></span><br><span class="line"><span class="comment">    * BeanDefinitionRegistry：BeanDefinition注册类</span></span><br><span class="line"><span class="comment">    * 把所有需要添加到容器中的bean，调用BeanDefinitionRegistry.registerBeanDefinition手动注入</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">definition</span> <span class="operator">=</span> registry.containsBeanDefinition(<span class="string">&quot;com.atguigu.bean.Red&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">definition2</span> <span class="operator">=</span> registry.containsBeanDefinition(<span class="string">&quot;com.atguigu.bean.Blue&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(definition &amp;&amp; definition2)&#123;</span><br><span class="line">            <span class="comment">//指定bean定义信息（bean的类型，bean的scope）</span></span><br><span class="line">            <span class="type">RootBeanDefinition</span> <span class="variable">rootBeanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(RainBow.class);</span><br><span class="line">            <span class="comment">//注册一个bean，指定bean名</span></span><br><span class="line">            registry.registerBeanDefinition(<span class="string">&quot;rainBow&quot;</span>,rootBeanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）使用spring提供的FactoryBean（工厂Bean）</p><ul><li>默认获取到的是工厂Bean调用getObject创建的对象</li><li>要获取工厂Bean本身，需要在id前面加一个&amp;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ColorFactoryBean <span class="title function_">colorFactoryBean</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ColorFactoryBean</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个spring定义的FactoryBean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Color&gt; &#123;</span><br><span class="line">    <span class="comment">//返回一个Color对象，并将Color添加到容器中</span></span><br><span class="line">    <span class="keyword">public</span> Color <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ColorFactoryBean,getObject()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Color.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、注入bean的注解"><a href="#2、注入bean的注解" class="headerlink" title="2、注入bean的注解"></a>2、注入bean的注解</h3><p>@Autowired：由bean提供</p><ul><li>@Autowired可以作用在变量、setter方法、构造函数上；</li><li>有个属性为required，可以配置为false；</li></ul><p>@Inject：由JSR-330提供</p><ul><li>@Inject用法和@Autowired一样。</li></ul><p>@Resource：由JSR-250提供</p><p>@Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的，@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Name一起使用。</p><p>@Primary</p><p>让spring进行自动装配的时候，默认使用首选的bean，和@Qualifier一个效果。</p><h3 id="3、-JsonIgnore"><a href="#3、-JsonIgnore" class="headerlink" title="3、@JsonIgnore"></a>3、@JsonIgnore</h3><p>（1）作用</p><p>在json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。</p><p>（2）使用方法</p><p>一般标记在属性或者方法上，返回的json数据即不包含该属性。</p><p>（3）注解失效</p><p>如果注解失效，可能是因为你使用的是fastJson，尝试使用对应的注解来忽略字段，注解为：@JSONField(serialize &#x3D; false)，使用方法一样。</p><h3 id="4、初始化和销毁方法"><a href="#4、初始化和销毁方法" class="headerlink" title="4、初始化和销毁方法"></a>4、初始化和销毁方法</h3><p>（1）通过@Bean(initMethod&#x3D;”init”,destoryMethod&#x3D;”destory”)方法</p><p>（2）通过bean实现InitializingBean来定义初始化逻辑，DisposableBean定义销毁逻辑</p><p>（3）可以使用JSR250：@PostConstruct：初始化方法；@PreDestory：销毁方法。</p><p>（4）BeanPostProcessor：bean的后置处理器，在bean初始化前后进行一些处理工作</p><p>postProcessBeforeInitialization：在初始化之前工作；</p><p>postProcessAfterInitialization：在初始化工作之后工作；</p><h3 id="5、Java配置类相关注解"><a href="#5、Java配置类相关注解" class="headerlink" title="5、Java配置类相关注解"></a>5、Java配置类相关注解</h3><p>@Configuration</p><p>声明当前类为配置类；</p><p>@Bean</p><p>注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式；</p><p>@ComponentScan</p><p>用于对Component进行扫描；</p><h3 id="6、切面（AOP）相关注解"><a href="#6、切面（AOP）相关注解" class="headerlink" title="6、切面（AOP）相关注解"></a>6、切面（AOP）相关注解</h3><p><a href="https://blog.csdn.net/JinXYan/article/details/89302126">Spring AOP详细介绍</a></p><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面</p><p>@After 在方法执行之后执行（方法上）</p><p>@Before 在方法执行之前执行（方法上）</p><p>@Around 在方法执行之前与之后执行（方法上）</p><p>@PointCut 声明切点</p><p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持</p><h3 id="7、-Bean的属性支持"><a href="#7、-Bean的属性支持" class="headerlink" title="7、@Bean的属性支持"></a>7、@Bean的属性支持</h3><p>@Scope设置类型包括：</p><p>设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p><p>① Singleton</p><p>（单例,一个Spring容器中只有一个bean实例，默认模式）,</p><p>② Protetype</p><p>（每次调用新建一个bean）,</p><p>③ Request</p><p>（web项目中，给每个http request新建一个bean）,</p><p>④ Session</p><p>（web项目中，给每个http session新建一个bean）,</p><p>⑤ GlobalSession</p><p>（给每一个 global http session新建一个Bean实例）</p><h3 id="8、-Value注解"><a href="#8、-Value注解" class="headerlink" title="8、@Value注解"></a>8、@Value注解</h3><p>（1）支持如下方式的注入：</p><ul><li>注入普通字符</li><li>注入操作系统属性</li><li>注入表达式结果</li><li>注入其它bean属性</li><li>注入文件资源</li><li>注入网站资源</li><li>注入配置文件</li></ul><p>（2）@Value三种情况的用法。</p><ol><li>${}是去找外部配置的参数，将值赋过来</li><li>#{}是SpEL表达式，去寻找对应变量的内容</li><li>#{}直接写字符串就是将字符串的值注入进去</li></ol><h3 id="9、环境切换"><a href="#9、环境切换" class="headerlink" title="9、环境切换"></a>9、环境切换</h3><p>@Profile</p><p>指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件。</p><p>@Conditional</p><p>通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。</p><h3 id="10、异步相关"><a href="#10、异步相关" class="headerlink" title="10、异步相关"></a>10、异步相关</h3><p>@EnableAsync</p><p>配置类中通过此注解开启对异步任务的支持；</p><p>@Async</p><p>在实际执行的bean方法使用该注解来声明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p><h3 id="11、定时任务相关"><a href="#11、定时任务相关" class="headerlink" title="11、定时任务相关"></a>11、定时任务相关</h3><p>@EnableScheduling</p><p>在配置类上使用，开启计划任务的支持（类上）</p><p>@Scheduled</p><p>来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><h3 id="12、Enable-注解说明"><a href="#12、Enable-注解说明" class="headerlink" title="12、Enable***注解说明"></a>12、Enable***注解说明</h3><p>这些注解主要是用来开启对xxx的支持：</p><ul><li>@EnableAspectAutoProxy：开启对AspectJ自动代理的支持；</li><li>@EnableAsync：开启异步方法的支持；</li><li>@EnableScheduling：开启计划任务的支持；</li><li>@EnableWebMvc：开启web MVC的配置支持；</li><li>@EnableConfigurationProperties：开启对@ConfigurationProperties注解配置Bean的支持；</li><li>@EnableJpaRepositories：开启对SpringData JPA Repository的支持；</li><li>@EnableTransactionManagement：开启注解式事务的支持；</li><li>@EnableCaching：开启注解式的缓存支持；</li></ul><h3 id="13、测试相关注解"><a href="#13、测试相关注解" class="headerlink" title="13、测试相关注解"></a>13、测试相关注解</h3><p>@RunWith</p><p>运行器，Spring中通常用于对JUnit的支持</p><p>@ContextConfiguration</p><p>用来加载配置配置文件，其中classes属性用来加载配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath*:/*.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ContextConfiguration这个注解通常与@RunWith(SpringJUnit4ClassRunner.class)联合使用用来测试。</p><p>@ContextConfiguration括号里的locations &#x3D; {“classpath*:&#x2F;*.xml”}就表示将classpath路径里所有的xml文件都包括进来，自动扫描的bean就可以拿到，此时就可以在测试类中使用@Autowired注解来获取之前自动扫描包下的所有bean。</p><h3 id="14、-EqualsAndHashCode"><a href="#14、-EqualsAndHashCode" class="headerlink" title="14、@EqualsAndHashCode"></a>14、@EqualsAndHashCode</h3><p>任意类的定义都可以添加<code>@EqualsAndHashCode</code>注解，让lombok帮你生成<code>equals(Object other)</code>和<code>hashCode()</code>方法的实现。默认情况下会使用非静态和非transient型字段来生成，但是你也通过在字段上添加 @EqualsAndHashCode.Include 或者@EqualsAndHashCode.Exclude 修改你使用的字段（甚至指定各种方法的输出）。或者你也可以通过在类上使用 @EqualsAndHashCode(onlyExplicitlyIncluded &#x3D; true) ，且在特定字段或特定方法上添加 @EqualsAndHashCode.Include 来指定他们。</p><p>如果将<code>@EqualsAndHashCode</code>添加到继承于另一个类的类上，这个功能会有点棘手。一般情况下，为这样的类自动生成<code>equals</code>和<code>hashCode</code>方法是一个坏思路，因为超类也有定义了一些字段，他们也需要equals&#x2F;hashCode方法但是不会自动生成。通过设置callSuper&#x3D;true，可以在生成的<code>equals</code>和<code>hashCode</code>方法里包含超类的方法。对于<code>hashCode</code>，·super.hashCode()·会被包含在hash算法内，而对于<code>equals</code>，如果超类实现认为它与传入的对象不一致则会返回false。注意：并非所有的<code>equals</code>都能正确的处理这样的情况。然而刚好lombok可以，若超类也使用lombok来生成equals方法，那么你可以安全的使用它的equals方法。如果你有一个明确的超类, 你得在callSuper上提供一些值来表示你已经斟酌过，要不然的话就会产生一条警告信息。</p><p>当你的类没有继承至任何类（非<code>java.lang.Object</code>, 当然任何类都是继承于Object类的），而你却将callSuer置为true, 这会产生编译错误（译者注： java: Generating equals&#x2F;hashCode with a supercall to java.lang.Object is pointless. ）。因为这会使得生成的<code>equals</code>和<code>hashCode</code>方法实现只是简单的继承至Object类的方法，只有相同的对象并且相同的hashCode才会判定他们相等。若你的类继承至另一个类又没有设置callSuper, 则会产品一个告警，因为除非超类没有（或者没有跟相等相关的）字段，否则lombok无法为你生成考虑超类声明字段的实现。</p><h3 id="15、XmlAccessorType"><a href="#15、XmlAccessorType" class="headerlink" title="15、XmlAccessorType"></a>15、XmlAccessorType</h3><p>类级别的注解</p><p>定义这个类中何种类型需要映射到XML。</p><ol><li>XmlAccessType.FIELD：映射这个类中的所有字段到XML</li><li>XmlAccessType.PROPERTY：映射这个类中的属性（get&#x2F;set方法）到XML</li><li>XmlAccessType.PUBLIC_MEMBER：将这个类中的所有public的field或property同时映射到XML（默认）</li><li>XmlAccessType.NONE：不映射</li></ol><h3 id="16、-SuppressWarnings"><a href="#16、-SuppressWarnings" class="headerlink" title="16、@SuppressWarnings"></a>16、@SuppressWarnings</h3><p>Suppress  抑制；镇压；废止 Warnings警告 </p><p>@SuppressWarnings(“resource”)是J2SE 提供的一个批注。该批注的作用是给编译器一条指令，告诉它对被批注的代码元素内部的某些警告保持静默。</p><p>@SuppressWarnings 批注允许您选择性地取消特定代码段（即，类或方法）中的警告。其中的想法是当您看到警告时，您将调查它，如果您确定它不是问题，您就可以添加一个 @SuppressWarnings 批注，以使您不会再看到警告。<br>虽然它听起来似乎会屏蔽潜在的错误，但实际上它将提高代码安全性，因为它将防止您对警告无动于衷 — 您看到的每一个警告都将值得注意。</p><h2 id="二、SpringMVC常用注解"><a href="#二、SpringMVC常用注解" class="headerlink" title="二、SpringMVC常用注解"></a>二、SpringMVC常用注解</h2><h3 id="1、-EnableWebMvc"><a href="#1、-EnableWebMvc" class="headerlink" title="1、@EnableWebMvc"></a>1、@EnableWebMvc</h3><p>在配置类中开启Web MVC的配置支持。</p><h3 id="2、-Controller"><a href="#2、-Controller" class="headerlink" title="2、@Controller"></a>2、@Controller</h3><h3 id="3、-RequestMapping"><a href="#3、-RequestMapping" class="headerlink" title="3、@RequestMapping"></a>3、@RequestMapping</h3><p>用于映射web请求，包括访问路径和参数。</p><h3 id="4、-ResponseBody"><a href="#4、-ResponseBody" class="headerlink" title="4、@ResponseBody"></a>4、@ResponseBody</h3><p>支持将返回值放到response内，而不是一个页面，通常用户返回json数据。</p><h3 id="5、-RequestBody"><a href="#5、-RequestBody" class="headerlink" title="5、@RequestBody"></a>5、@RequestBody</h3><p>允许request的参数在request体中，而不是在直接连接的地址后面。（放在参数前）</p><h3 id="6、-PathVariable"><a href="#6、-PathVariable" class="headerlink" title="6、@PathVariable"></a>6、@PathVariable</h3><p>用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)声明的路径，将注解放在参数前，即可获取该值，通常作为Restful的接口实现方法。</p><h3 id="7、-RestController"><a href="#7、-RestController" class="headerlink" title="7、@RestController"></a>7、@RestController</h3><p>该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><h3 id="8、-ControllerAdvice"><a href="#8、-ControllerAdvice" class="headerlink" title="8、@ControllerAdvice"></a>8、@ControllerAdvice</h3><ul><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ul><p><a href="https://blog.csdn.net/guorui_java/article/details/106883939">ControllerAdvice的常用场景</a></p><h3 id="9、-ExceptionHandler"><a href="#9、-ExceptionHandler" class="headerlink" title="9、@ExceptionHandler"></a>9、@ExceptionHandler</h3><p>用于全局处理控制器里的异常。</p><h3 id="10、-InitBinder"><a href="#10、-InitBinder" class="headerlink" title="10、@InitBinder"></a>10、@InitBinder</h3><p>用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p><h3 id="11、-ModelAttribute"><a href="#11、-ModelAttribute" class="headerlink" title="11、@ModelAttribute"></a>11、@ModelAttribute</h3><p>（1）@ModelAttribute注释方法 </p><p>如果把@ModelAttribute放在方法的注解上时，代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法。可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。比如权限的验证（也可以使用Interceptor）等。</p><p>（2）@ModelAttribute注释一个方法的参数 </p><p>当作为方法的参数使用，指示的参数应该从模型中检索。如果不存在，它应该首先实例化，然后添加到模型中，一旦出现在模型中，参数字段应该从具有匹配名称的所有请求参数中填充。</p><p><img src="https://img-blog.csdnimg.cn/20210106195653897.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210106195702208.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>hellorWord方法的userLogin参数的值来源于getUserLogin()方法中的model属性。</p><h3 id="12、-Transactional"><a href="#12、-Transactional" class="headerlink" title="12、@Transactional"></a>12、@Transactional</h3><p>@Transactional 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。EmployeeService 的所有方法都支持事务并且是只读。当类级别配置了@Transactional，方法级别也配置了@Transactional，应用程序会以方法级别的事务属性信息来管理事务，换言之，方法级别的事务属性信息会覆盖类级别的相关配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)</span></span><br><span class="line"><span class="meta">@Service(value =&quot;employeeService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeService</span></span><br></pre></td></tr></table></figure><p>@Transactional 注解的属性信息</p><table><thead><tr><th align="left">属性名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td></tr><tr><td align="left">propagation</td><td align="left">事务的传播行为，默认值为 REQUIRED。</td></tr><tr><td align="left">isolation</td><td align="left">事务的隔离度，默认值采用 DEFAULT。</td></tr><tr><td align="left">timeout</td><td align="left">事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td align="left">read-only</td><td align="left">指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td></tr><tr><td align="left">rollback-for</td><td align="left">用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td></tr><tr><td align="left">no-rollback- for</td><td align="left">抛出 no-rollback-for 指定的异常类型，不回滚事务。</td></tr></tbody></table><h2 id="三、其它注解"><a href="#三、其它注解" class="headerlink" title="三、其它注解"></a>三、其它注解</h2><h3 id="1、-JsonIgnore"><a href="#1、-JsonIgnore" class="headerlink" title="1、@JsonIgnore"></a>1、@JsonIgnore</h3><p>（1）作用</p><p>在json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。</p><p>（2）使用方法</p><p>一般标记在属性或者方法上，返回的json数据即不包含该属性。</p><p>（3）注解失效</p><p>如果注解失效，可能是因为你使用的是fastJson，尝试使用对应的注解来忽略字段，注解为：@JSONField(serialize &#x3D; false)，使用方法一样。</p><h3 id="2、-Schema"><a href="#2、-Schema" class="headerlink" title="2、@Schema"></a>2、@Schema</h3><p>@schema注解标注在class上，表示此类对应的数据库表对应的schema。</p><p>可以用如下语句判断某个实体类上是否带有@schema注解，从而得到schema。</p><blockquote><p>bean.getClass().isAnnotationPresent(Schema.class)</p></blockquote><h2 id="四、json常用注解"><a href="#四、json常用注解" class="headerlink" title="四、json常用注解"></a>四、json常用注解</h2><h3 id="1、-JsonIgnoreProperties"><a href="#1、-JsonIgnoreProperties" class="headerlink" title="1、@JsonIgnoreProperties"></a>1、@JsonIgnoreProperties</h3><p>此注解是类注解，作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。</p><p>写法将此标签加在user类的类名上 ，可以多个属性也可以单个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json时将name和age属性过滤</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;name&quot;&#125;,&#123;&quot;age&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">user</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、-JsonIgnore"><a href="#2、-JsonIgnore" class="headerlink" title="2、@JsonIgnore"></a>2、@JsonIgnore</h3><p>此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json 时不生成age 属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">user</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、-JsonFormat"><a href="#3、-JsonFormat" class="headerlink" title="3、@JsonFormat"></a>3、@JsonFormat</h3><p>此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、-JsonSerialize"><a href="#4、-JsonSerialize" class="headerlink" title="4、@JsonSerialize"></a>4、@JsonSerialize</h3><p>此注解用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码，比如序列化一个double时在其后面限制两位小数点。</p><h3 id="5、-JsonDeserialize"><a href="#5、-JsonDeserialize" class="headerlink" title="5、@JsonDeserialize"></a>5、@JsonDeserialize</h3><p>此注解用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码，类似于上面的@JsonSerialize</p><h3 id="6、-Transient"><a href="#6、-Transient" class="headerlink" title="6、@Transient"></a>6、@Transient</h3><p>如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient，否则ORM框架默认其注解为@Basic；</p><h3 id="7、-JsonIgnoreType"><a href="#7、-JsonIgnoreType" class="headerlink" title="7、@JsonIgnoreType"></a>7、@JsonIgnoreType</h3><p>标注在类上，当其他类有该类作为属性时，该属性将被忽略。</p><h3 id="8、-JsonProperty"><a href="#8、-JsonProperty" class="headerlink" title="8、@JsonProperty"></a>8、@JsonProperty</h3><p>@JsonProperty 可以指定某个属性和json映射的名称。例如我们有个json字符串为{“user_name”:”aaa”}，<br>而java中命名要遵循驼峰规则，则为userName，这时通过@JsonProperty 注解来指定两者的映射规则即可。这个注解也比较常用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeEntity</span> &#123;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;user_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、只在序列化情况下生效的注解"><a href="#9、只在序列化情况下生效的注解" class="headerlink" title="9、只在序列化情况下生效的注解"></a>9、只在序列化情况下生效的注解</h3><p>@JsonPropertyOrder</p><p>在将 java pojo 对象序列化成为 json 字符串时，使用 @JsonPropertyOrder 可以指定属性在 json 字符串中的顺序。</p><p>@JsonInclude</p><p>在将 java pojo 对象序列化成为 json 字符串时，使用 @JsonInclude 注解可以控制在哪些情况下才将被注解的属性转换成 json，例如只有属性不为 null 时。</p><p>@JsonInclude(JsonInclude.Include.NON_NULL)</p><p>这个注解放在类头上，返给前端的json里就没有null类型的字段，即实体类与json互转的时候 属性值为null的不参与序列化。<br>另外还有很多其它的范围，例如 NON_EMPTY、NON_DEFAULT等</p><h3 id="10、在反序列化情况下生效的注解"><a href="#10、在反序列化情况下生效的注解" class="headerlink" title="10、在反序列化情况下生效的注解"></a>10、在反序列化情况下生效的注解</h3><p>@JsonSetter</p><p>@JsonSetter 标注于 setter 方法上，类似 @JsonProperty ，也可以解决 json 键名称和 java pojo 字段名称不匹配的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> Annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】Spring Security</title>
      <link href="/2022/07/07/32.SpringSecurity/"/>
      <url>/2022/07/07/32.SpringSecurity/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/xiyang_1990/article/details/123710017?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123710017-blog-122289943.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123710017-blog-122289943.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2</span><br></pre></td></tr></table></figure><h1 id="1-拦截器的两种实现方式"><a href="#1-拦截器的两种实现方式" class="headerlink" title="1. 拦截器的两种实现方式"></a>1. 拦截器的两种实现方式</h1><p><strong>在Spring MVC中定义一个拦截器有两种方法：</strong></p><ul><li>通过<strong>实现HandlerInterceptor接口</strong>，或<strong>继承HandlerInterceptor接口的实现类</strong>（如HandlerInterceptorAdapter）来定义。</li><li>通过<strong>实现WebRequestInterceptor接口</strong>，或<strong>继承WebRequestInterceptor接口的实现类</strong>来定义。</li></ul><h1 id="2-Spring-Security"><a href="#2-Spring-Security" class="headerlink" title="2.Spring Security"></a>2.Spring Security</h1><h2 id="2-1-理解"><a href="#2-1-理解" class="headerlink" title="2.1 理解"></a>2.1 理解</h2><p><strong>Spring Security的核心逻辑全在这一套过滤器中，过滤器里会调用各种组件完成功能，掌握了这些过滤器和组件你就掌握了Spring Security</strong>！这个框架的使用方式就是对这些过滤器和组件进行扩展。</p><table><thead><tr><th>过滤器</th><th>作用</th></tr></thead><tbody><tr><td>WebAsyncManagerIntegrationFilter</td><td>将WebAsyncManger与SpringSecurity上下文进行集成</td></tr><tr><td>SecurityContextPersistenceFilter</td><td>在处理请求之前, 将安全信息加载到SecurityContextHolder中</td></tr><tr><td>HeaderWriterFilter</td><td>处理头信息假如响应中</td></tr><tr><td>CsrfFilter</td><td>处理CSRF攻击</td></tr><tr><td>LogoutFilter</td><td>处理注销登录</td></tr><tr><td><strong>UsernamePasswordAuthenticationFilter</strong></td><td><strong>处理表单登录</strong></td></tr><tr><td>DefaultLoginPageGeneratingFilter</td><td>配置默认登录页面</td></tr><tr><td>DefaultLogoutPageGeneratingFilter</td><td>配置默认注销页面</td></tr><tr><td>BasicAuthenticationFilter</td><td>处理HttpBasic登录</td></tr><tr><td>RequestCacheAwareFilter</td><td>处理请求缓存</td></tr><tr><td>SecurityContextHolderAwareRequestFilter</td><td>包装原始请求</td></tr><tr><td>AnonymousAuthenticationFilter</td><td>配置匿名认证</td></tr><tr><td>SessionManagementFilter</td><td>处理session并发问题</td></tr><tr><td>ExceptionTranslationFilter</td><td>处理认证&#x2F;授权中的异常</td></tr><tr><td><strong>FilterSecurityInterceptor</strong></td><td><strong>处理授权相关</strong></td></tr></tbody></table><h2 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h2><h3 id="2-2-1-导包"><a href="#2-2-1-导包" class="headerlink" title="2.2.1 导包"></a>2.2.1 导包</h3><p>要使用Spring Security肯定是要先引入依赖包（Web项目其他必备依赖我在之前文章中已讲解，这里就不过多阐述了）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖包导入后，Spring Security就默认提供了许多功能将整个应用给保护了起来，要求经过身份验证的用户才能与应用程序进行交互。</p><h3 id="2-2-2-配置类"><a href="#2-2-2-配置类" class="headerlink" title="2.2.2 配置类"></a>2.2.2 配置类</h3><p>在实际开发中，这些<strong>默认配置好的功能往往不符合我们的实际需求，所以我们一般会自定义一些配置</strong>。配置方式很简单，新建一个配置类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该类中重写<code>WebSecurityConfigurerAdapter</code>的方法就能对Spring Security进行自定义配置。</p><p>###2.2.3 三个核心组件</p><p>我们需要通过 <strong><code>SecurityContext</code></strong> 来获取<code>Authentication</code>，这个<code>SecurityContext</code>就是我们的上下文对象！</p><blockquote><p>这种在一个线程中横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context）。上下文对象是非常有必要的，否则你每个方法都得额外增加一个参数接收对象，实在太麻烦了。</p></blockquote><p>这个上下文对象则是交由 <strong><code>SecurityContextHolder</code></strong> 进行管理，你可以在程序<strong>任何地方</strong>使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br></pre></td></tr></table></figure><p>可以看到调用链路是这样的：<code>SecurityContextHolder</code> -&gt; <code>SecurityContext</code> -&gt; <code>Authentication</code>。</p><p><code>SecurityContextHolder</code>原理非常简单，使用<code>ThreadLocal</code>来保证一个线程中传递同一个对象！</p><p>现在我们已经知道了Spring Security中三个核心组件：</p><ul><li><code>Authentication</code>：存储了认证信息，代表当前登录用户</li><li><code>SeucirtyContext</code>：上下文对象，用来获取<code>Authentication </code></li><li><code>SecurityContextHolder</code>：上下文管理对象，用来在程序任何地方获取<code>SecurityContext</code></li></ul><p><img src="https://fastly.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/SecurityContextHolder.637wmh9seyg0.png"></p><p><code>Authentication</code>中那三个就是认证信息：</p><p><code>Principal</code>：用户信息，没有认证时一般是用户名，认证后一般是用户对象</p><p><code>Credentials</code>：用户凭证，一般是密码</p><p><code>Authorities</code>：用户权限</p><h3 id="2-2-4-最简单的认证"><a href="#2-2-4-最简单的认证" class="headerlink" title="2.2.4 最简单的认证"></a>2.2.4 最简单的认证</h3><p>认证过程就是登录过程，不使用安全框架时咱们的认证过程是这样的：</p><p>查询用户数据 - 判断账号密码是否正确 - 正确则将用户信息存储到上下文中 - 上下文中有了这个对象则代表该用户登录了</p><p>Spring Security的认证流程也是如此：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(用户名, 用户密码, 用户的权限集合);</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authentication);</span><br></pre></td></tr></table></figure><p>和不使用安全框架一样，将认证信息放到上下文中就代表用户已登录。上面代码演示的就是Spring Security最简单的认证方式，直接将<code>Authentication</code>放置到<code>SecurityContext</code>中就完成认证了！</p><h2 id="2-3-oauth2各种依赖区别"><a href="#2-3-oauth2各种依赖区别" class="headerlink" title="2.3 oauth2各种依赖区别"></a>2.3 oauth2各种依赖区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring-security-oauth2  -&gt; 被废弃，建议不使用，否则后期无法维护</span><br><span class="line">spring-security-oauth2-autoconfigure  -&gt; 自动配置，没有用处</span><br><span class="line">spring-boot-starter-oauth2-client -&gt; 最新</span><br><span class="line">spring-boot-starter-oauth2-resource-server  -&gt; 最新</span><br><span class="line">spring-cloud-starter-oauth2 -&gt; 引用 spring-security-oauth2，但尚未标注被废弃</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】try catch finally含return的几种情况</title>
      <link href="/2022/07/07/31.try%20catch%20finally%E5%90%ABreturn%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/"/>
      <url>/2022/07/07/31.try%20catch%20finally%E5%90%ABreturn%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="0-总结："><a href="#0-总结：" class="headerlink" title="0. 总结："></a>0. 总结：</h2><ul><li>当 try 代码块和 catch 代码块中有 return 语句时，finally 仍然会被执行；</li><li>执行 try 代码块或 catch 代码块中的 return 语句之前，<strong>都会先执行 finally 语句</strong>；</li><li>finally 代码块中的 return 语句会<strong>覆盖 try 或 catch 中的 return</strong>， finally 中最好不要出现 return；</li><li>finally 中没有 return 语句的情况下，对变量进行修改：return 语句中是基本数据类型，则 finally 中对变量进行操作不会改变其值；return 语句中是引用数据类型，finally 中则会修改里面的数据；</li></ul><h2 id="1-在try和catch中有return，finally中没有return，try发生异常"><a href="#1-在try和catch中有return，finally中没有return，try发生异常" class="headerlink" title="1. 在try和catch中有return，finally中没有return，try发生异常"></a>1. 在try和catch中有return，finally中没有return，try发生异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        result = num();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">4</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span> num+<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span> num+<span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不管你怎么样，我都是要执行&quot;</span>);    </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出内容为：</span><br><span class="line">不管你怎么样，我都是要执行</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong>int b&#x3D;4&#x2F;0；发生了异常，直接进入catch的代码块中执行了return num &#x3D; num+3；此时把返回的结果4。如果没有异常的话会执行try中的return，catch中的代码不会执行，但是无论怎样，finally中的代码都会执行。</p><h2 id="2-在try和catch中有return，finally中没有return，在finally中对try或catch中要-return数据进行操作"><a href="#2-在try和catch中有return，finally中没有return，在finally中对try或catch中要-return数据进行操作" class="headerlink" title="2. 在try和catch中有return，finally中没有return，在finally中对try或catch中要 return数据进行操作"></a>2. 在try和catch中有return，finally中没有return，在finally中对try或catch中要 return数据进行操作</h2><p><strong>（1）返回的数据为基本数据类型，则finally中对要返回数据操作无影响</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        result = num();</span><br><span class="line">        System.out.println(result);<span class="comment">//结果不受finally影响，输出4</span></span><br><span class="line">        System.out.println(num);<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">4</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span> num+<span class="number">2</span>; <span class="comment">//3</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span> num+<span class="number">3</span>;<span class="comment">//4</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ++num; <span class="comment">//4+1</span></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong>result的值为4的原因是，当执行到catch中的 return num &#x3D; num+3;时，<strong>已经把要返回的num的值存到了其他局部变量中</strong>，在执行完finally中的++num;后，是从其他局部变量中获取的返回值，而不是直接返回num的值</p><p><strong>（2）返回的数据为引用数据类型，finally中如果改变了返回对象的属性则影响结果，如果改变的是对象的引用则和基本数据类型一样不改变结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        People bride;</span><br><span class="line">        bride = marry();</span><br><span class="line">        System.out.println(bride.getState());<span class="comment">//结果受finally影响，输出dead</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> People <span class="title function_">marry</span><span class="params">()</span> &#123;</span><br><span class="line">        People people=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setState(<span class="string">&quot;happy&quot;</span>);;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">4</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            people.setState(<span class="string">&quot;dead&quot;</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong>bride.getState()的结果为dead的原因是，当执行到catch中的return  people;时，把要返回people的内存地址存储起来，但是finally中对该内存地址对象的属性进行了更改，bride &#x3D; marry();获取的内存地址对应的对象是更改属性后的people，所以属性值改变了。</p><p>改的是对象地址指向的数据</p><h2 id="3-在try和catch中有return，finally中也有return"><a href="#3-在try和catch中有return，finally中也有return" class="headerlink" title="3.在try和catch中有return，finally中也有return"></a>3.在try和catch中有return，finally中也有return</h2><p>try或catch中return后面的代码会执行，但最终返回的结果为finally中return的值，需要注意的是try或catch中return后面的代码会执行，<strong>只是存起来了，并没有返回</strong>，让finally捷足先登先返回了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        result = num();</span><br><span class="line">        System.out.println(result);<span class="comment">//输出结果为1003</span></span><br><span class="line">        System.out.println(num);<span class="comment">//输出结果为1001</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">4</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span> num+<span class="number">1000</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span> num+<span class="number">1000</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num+<span class="number">2</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-在try中有return，在catch中新抛出异常，finally中有return"><a href="#4-在try中有return，在catch中新抛出异常，finally中有return" class="headerlink" title="4.在try中有return，在catch中新抛出异常，finally中有return"></a>4.在try中有return，在catch中新抛出异常，finally中有return</h2><p>如果catch块中捕获了异常, 并且在catch块中将该异常throw给上级调用者进行处理, 但finally中有return, 那么catch块中的throw就失效了, 上级方法调用者是捕获不到异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = num();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;青天大老爷在此&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">num</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> b=<span class="number">4</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;总是异常，反正我又不会执行&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用金钱蒙蔽你的双眼&quot;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上代码输出：</span><br><span class="line"></span><br><span class="line">用金钱蒙蔽你的双眼</span><br><span class="line"></span><br><span class="line">如果把<span class="keyword">finally</span>里的<span class="keyword">return</span>注释掉就会输出：</span><br><span class="line">青天大老爷在此</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> try-catch-finally </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】Async注解实现异步调用</title>
      <link href="/2022/07/06/30.@Async&amp;@Transactional/"/>
      <url>/2022/07/06/30.@Async&amp;@Transactional/</url>
      
        <content type="html"><![CDATA[<p>在类中，调用本类的含有@Async注解的异步方法，不能直接调用（带有@Transactional的也是）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncHandleData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------线程１------------------&quot;</span>+name);</span><br><span class="line">    <span class="type">AsyncService</span> <span class="variable">currentProxy</span> <span class="operator">=</span> (AsyncService) AopContext.currentProxy();</span><br><span class="line">    currentProxy.syncHandleData1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CollectionBatch <span class="title function_">syncHandleData1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------线程２------------------&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始异步处理&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为@Async异步是通过spring的Aop动态代理，若在类中直接调用，相当于this.syncHandleData1的方式，即是通过AsyncService对象直接调用的syncHandleData1方法，而实际上@Async注解异步的实现是通过AsyncService的代理对象调用实现的，所以这样直接调用就让异步无效了。</p><p><strong>解决的方法有三种：</strong></p><ul><li><p>把这个异步方法抽出来放在一个新类里。调用的时候把新类对象通过依赖注入的注解方式放进来直接调用就可以了。因为通过注解注入，那么这个类对象就肯定是由Spring管理的了，Spring容器会对这个类进行一系列的渲染，包括需要用的组件。</p></li><li><p>在AsyncService类中通过Spring上下文获取它的对象（写一个SpringUtil工具类实现ApplicationContextAware ，具体实现可看我另一篇博客），即可以正常调用异步方法。所以该方法获取的对象实际上是AsyncService的代理对象</p></li><li><p>通过AopContext动态代理获取对象，即上面代码所示，然后在启动类中加上下面这个注解，开启cglib代理。（因为默认是jdk代理）。此刻可以看到打印出来的是两个不同线程。</p></li></ul><p>Spring容器对对象的创建不单单是像我们new一个新对象那样简单，而是在初始化时对它进行了一系列的渲染。</p><p>比如Spring在初始化对象时，扫描到这个Bean的@Async注解，就会给它装配异步组件，扫描到它的@Transactional注解，就会给它装配事务的功能，最后我们获取的就是这个bean的代理对象，这就是Spring的动态代理。你需要什么样的对象，就动态的给你创建一个什么样的代理对象供使用。（对于@Transactional注解，放在类上，或在两个方法上都加上该注解，事务也是有效的）</p><p><strong>所以如果你用了Spring的方便的注解，那么在你需要调用这个注解方法时，一定要用Spring管理的对象去调用它，因为没有被Spring容器管理的对象是不具备这些注解的组件功能的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】SSM查漏补缺</title>
      <link href="/2022/07/05/29.SSM%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
      <url>/2022/07/05/29.SSM%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们的程序在编写时，通过控制反转，把对象的创建交给了spring，但是代码中不可能出现没有依赖的情况。ioc解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用spring之后，就让spring来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取</span><br></pre></td></tr></table></figure><h2 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1. Spring"></a>1. Spring</h2><h3 id="1-1-内聚与耦合"><a href="#1-1-内聚与耦合" class="headerlink" title="1.1 内聚与耦合"></a>1.1 内聚与耦合</h3><p>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。</p><p>模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。</p><p>在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则就是高内聚低耦合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">耦合性有如下分类：</span><br><span class="line">（1）内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。</span><br><span class="line">（2）公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</span><br><span class="line">（3）外部耦合。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</span><br><span class="line">（4）控制耦合。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。</span><br><span class="line">（5）标记耦合。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</span><br><span class="line">（6）数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。</span><br><span class="line">（7）非直接耦合。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</span><br><span class="line"></span><br><span class="line">总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。</span><br></pre></td></tr></table></figure><p>内聚与耦合内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。</p><p>**内聚 **是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。</p><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><h3 id="1-2-Spring的优势"><a href="#1-2-Spring的优势" class="headerlink" title="1.2 Spring的优势"></a>1.2 Spring的优势</h3><p><strong>1. 定义：</strong>Spring是分层的Java SE&#x2F;EE应用full-stack轻量级开源框架，以<strong>IoC（Inverse Of Control：反转控制）</strong>和<strong>AOP（Aspect Oriented Programming：面向切面编程）</strong>为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</p><p><strong>2. 控制反转：</strong>（Inversion of Control，缩写为<strong>IoC</strong>），是面向对象编程中的一种设计原则，把创建对象的权利交给框架，其中最常见的方式叫做“<strong>依赖注入</strong>”（Dependency Injection，简称DI），还有一种方式叫“<strong>依赖查找</strong>”（Dependency Lookup）。</p><p><strong>3.依赖注入：</strong>我们的程序在编写时，通过控制反转，把对象的创建交给了spring，但是代码中不可能出现没有依赖的情况。ioc解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用spring之后，就让spring来维护了。简单的说，<strong>就是等框架把持久层对象传入业务层，而不用我们自己去获取</strong>。</p><p><strong>4. 优势：</strong></p><p><strong>方便解耦，简化开发</strong><br>通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p><p><strong>AOP编程的支持</strong><br>通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</p><p><strong>声明式事务的支持</strong><br>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。</p><p><strong>方便程序的测试</strong><br>可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</p><p><strong>方便集成各种优秀框架</strong><br>Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。</p><p><strong>降低JavaEE API的使用难度</strong><br>Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。</p><p><strong>Java源码是经典学习范例</strong><br>Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。 </p><h3 id="1-3-简单使用"><a href="#1-3-简单使用" class="headerlink" title="1.3 简单使用"></a>1.3 简单使用</h3><p>配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件推荐使用这种</li><li>FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</li><li>AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建spring容器。它用来读取注解</li></ul><p><strong>单例对象</strong>：scope&#x3D;”singleton”<br>一个应用只有一个对象的实例。它的作用范围就是整个引用。<br>生命周期：</p><ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。</li><li>对象活着：只要容器在，对象一直活着。</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li></ul><p><strong>多例对象</strong>：scope&#x3D;”prototype”<br>每次访问对象时，都会重新创建对象实例。<br>生命周期：</p><ul><li>对象出生：当使用对象时，创建新的对象实例。</li><li>对象活着：只要对象在使用中，就一直活着。</li><li>对象死亡：当对象长时间不用时，被java的垃圾回收器回收了。</li></ul><p><strong>SpringMVC默认是单例的</strong></p><p>Java里有个API叫做ThreadLocal，spring单例模式下用它来切换不同线程之间的参数。用ThreadLocal是为了保证线程安全，实际上ThreadLoacal的key就是当前线程的Thread实例。</p><p><strong>单例模式下，spring把每个线程可能存在线程安全问题的参数值放进了ThreadLocal。</strong>这样虽然是一个实例在操作，但是不同线程下的数据互相之间都是隔离的，因为运行时创建和销毁的bean大大减少了，所以大多数场景下这种方式对内存资源的消耗较少，而且并发越高优势越明显。</p><p>总的来说就是，单利模式因为大大节省了实例的创建和销毁，有利于提高性能，而ThreadLocal用来保证线程安全性。单例模式是spring推荐的配置，它在高并发下能极大的节省资源，提高服务抗压能力。spring IOC的bean管理器是“绝对的线程安全”。</p><h2 id="2-SpringMVC"><a href="#2-SpringMVC" class="headerlink" title="2. SpringMVC"></a>2. SpringMVC</h2><h2 id="3-MyBatis"><a href="#3-MyBatis" class="headerlink" title="3. MyBatis"></a>3. MyBatis</h2>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】RestTemplate&amp;OkHttp&amp;IO流</title>
      <link href="/2022/07/03/28.RestTemplate-OkHttp-IO%E6%B5%81/"/>
      <url>/2022/07/03/28.RestTemplate-OkHttp-IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://cloud.tencent.com/developer/article/1910477">https://cloud.tencent.com/developer/article/1910477</a></p><p><a href="https://blog.csdn.net/D1842501760/article/details/124216538">https://blog.csdn.net/D1842501760/article/details/124216538</a></p><p><a href="https://juejin.cn/post/7068162792154464264">https://juejin.cn/post/7068162792154464264</a></p></blockquote><h2 id="1-IO流，byte-互相转换"><a href="#1-IO流，byte-互相转换" class="headerlink" title="1. IO流，byte[] 互相转换"></a>1. IO流，byte[] 互相转换</h2><h3 id="1-1-将File转换为byte-数组"><a href="#1-1-将File转换为byte-数组" class="headerlink" title="1.1 将File转换为byte[]数组"></a>1.1 将File转换为byte[]数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.nio.file</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\user\\Pictures\\22.jpg&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = Files.readAllBytes(Paths.get(filePath));</span><br></pre></td></tr></table></figure><h3 id="1-2-将FileInputStream-转换为byte-数组"><a href="#1-2-将FileInputStream-转换为byte-数组" class="headerlink" title="1.2 将FileInputStream 转换为byte[]数组"></a>1.2 将FileInputStream 转换为byte[]数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\user\\Pictures\\22.jpg&quot;</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[fileInputStream.available()];</span><br><span class="line">fileInputStream.read(bytes1);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Apache Common中IOUtils.toByteArray()转换</span></span><br><span class="line"><span class="type">byte</span>[] bytes = IOUtils.toByteArray(inputStream);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\user\\Pictures\\22.jpg&quot;</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (-<span class="number">1</span> != fileInputStream.read(bytes)) &#123;</span><br><span class="line">    output.write(bytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">byte</span>[] bytes2 = output.toByteArray();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Google Guava中ByteStreams.toByteArray()转换</span></span><br><span class="line"><span class="type">byte</span>[] bytes = ByteStreams.toByteArray(inputStream);</span><br></pre></td></tr></table></figure><p><strong>jdk9</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] bytes = inputStream.readAllBytes()</span><br></pre></td></tr></table></figure><h3 id="1-2-将byte-数组转换为InputStream"><a href="#1-2-将byte-数组转换为InputStream" class="headerlink" title="1.2 将byte[]数组转换为InputStream"></a>1.2 将byte[]数组转换为InputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br></pre></td></tr></table></figure><p>###1.3 将byte[]数组转换为File</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\user\\Pictures\\22.jpg&quot;</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(output);</span><br><span class="line">bufferedOutput.write(byt);</span><br></pre></td></tr></table></figure><h3 id="1-4-ByteArrayInputStream"><a href="#1-4-ByteArrayInputStream" class="headerlink" title="1.4 ByteArrayInputStream"></a>1.4 ByteArrayInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] source = ...;</span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(source);</span><br><span class="line"><span class="comment">// read bytes from bis ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="comment">// write bytes to bos ...</span></span><br><span class="line"><span class="type">byte</span>[] sink = bos.toByteArray();</span><br></pre></td></tr></table></figure><h2 id="2-RestTemplate"><a href="#2-RestTemplate" class="headerlink" title="2. RestTemplate"></a>2. RestTemplate</h2><h3 id="2-1-创建RestTemplate"><a href="#2-1-创建RestTemplate" class="headerlink" title="2.1 创建RestTemplate"></a>2.1 创建RestTemplate</h3><p><strong>方式一：</strong></p><p>使用<code>Springboot</code>提供的<code>RestTemplateBuilder</code>构造类来构造一个<code>RestTemplate</code>，可以自定义一些连接参数，如：连接超时时间，读取超时时间，还有认证信息等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">    <span class="comment">//方式一</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                <span class="comment">//设置连接超时时间</span></span><br><span class="line">                .setConnectTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置读取超时时间</span></span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">5000</span>))</span><br><span class="line">                <span class="comment">//设置认证信息</span></span><br><span class="line">                .basicAuthentication(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                <span class="comment">//设置根路径</span></span><br><span class="line">                .rootUri(<span class="string">&quot;https://api.test.com/&quot;</span>)</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//方式二</span></span><br><span class="line">        <span class="comment">//    @Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleClientHttpRequestFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleClientHttpRequestFactory</span>();</span><br><span class="line">        <span class="comment">//指客户端和服务器建立连接的timeout 3秒</span></span><br><span class="line">        factory.setConnectTimeout(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//读取数据的超时时间</span></span><br><span class="line">        factory.setReadTimeout(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(factory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二：</strong></p><ul><li>无参构造 全部参数默认</li><li>指定<code>ClientHttpRequestFactory</code> 的构造方法可以指定自己实现的<code>ClientHttpRequestFactory</code>（客户端<code>http</code>请求工厂）其他的与无参构造相同。</li><li>指定<code>List&lt;HttpMessageConverter&lt;?&gt;&gt;</code>的构造方法可以指定自己是实现的<code>HttpMessageConverter</code>（<code>Http</code>消息转换器）传入其他与无参构造相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-一般使用"><a href="#2-2-一般使用" class="headerlink" title="2.2 一般使用"></a>2.2 一般使用</h3><h4 id="2-2-1-参数含义"><a href="#2-2-1-参数含义" class="headerlink" title="2.2.1 参数含义"></a>2.2.1 参数含义</h4><p><strong>（1）HttpHeaders</strong></p><p> 故名思意，就是用来封装Http请求的请求头的，这里我们要设置他的<code>ContentType</code>为**<code>MediaType.APPLICATION_FORM_URLENCODED</code>**以使得我们提交的参数是以Form(表单)的形式提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line"><span class="comment">//这里指定参数以UTF-8编码格式传输</span></span><br><span class="line"><span class="type">MediaType</span> <span class="variable">mediaType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaType</span>(MediaType.APPLICATION_FORM_URLENCODED, StandardCharsets.UTF_8);</span><br><span class="line">httpHeaders.setContentType(mediaType);</span><br><span class="line"><span class="comment">//提交参数设置</span></span><br><span class="line">MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>（2）MultiValueMap&lt;K,V&gt;</strong></p><p>该类是用来封装请求参数的，是以<code>key-value</code>的形式封装但是以单个key对应多个value的格式传输(也就是是以单个<code>key:[value...]</code>的格式传输的)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交参数设置</span></span><br><span class="line">MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br></pre></td></tr></table></figure><p> <strong>如果像传输单个<code>key</code>对应单个<code>value</code>使用普通的<code>Map</code>传参即可</strong></p><p><strong>（3）HttpEntity<T></strong></p><p> 该类是用来封装请求的，主要作用就是将请求头和请求体封装在一起成为一个请求实体 T用来指定用来封装参数的容器的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组装请求体</span></span><br><span class="line">HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br></pre></td></tr></table></figure><p><strong>（4）EXCHANGE</strong></p><blockquote><p><code>&lt;T&gt; ResponseEntity&lt;T&gt; exchange()</code></p><p>该方法允许用户指定请求的方法（<code>get,post,put</code>等）</p><p>可以在请求中增加body以及头信息，其内容通过参数<code>HttpEntity&lt;?&gt; requestEntity</code>描述</p><p><code>exchange</code>支持’含参数的类型(即泛型)’作为返回类型，该特性通过<code>ParameterizedTypeReferenceresponseType</code> 描述</p></blockquote><p> 该方法支持五个参数:</p><ul><li>第一个是服务地址</li><li>第二个是请求方法</li><li>第三个是写入的请求实体</li><li>第四个是响应内容的类型</li><li>第五个是扩展模板的变量或包含<code>URI</code>模板变量的映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://httpbin.org/post&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;彭于晏&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    HttpEntity&lt;User&gt; userHttpEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(user, httpHeaders);</span><br><span class="line">    ResponseEntity&lt;Object&gt; exchange = restTemplate.exchange(url, HttpMethod.POST, userHttpEntity, Object.class);</span><br><span class="line">    System.out.println(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-原生使用"><a href="#2-2-2-原生使用" class="headerlink" title="2.2.2 原生使用"></a>2.2.2 原生使用</h4><p>常用的方法：</p><ul><li><strong><code>GET</code></strong></li><li><strong><code>POST</code></strong></li><li><strong><code>PUT</code></strong></li><li><strong><code>DELETE</code></strong></li><li><strong><code>HEAD</code></strong></li><li><strong><code>OPTIONS</code></strong></li><li><strong><code>EXCHANGE</code></strong></li><li><strong><code>EXECUTE</code></strong></li></ul><p><strong>GET请求：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/test/api?num=2&quot;</span>;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url, Long.class);</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="comment">//ResponseEntity&lt;Long&gt; forEntity = restTemplate.getForEntity(url, Long.class);</span></span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>POST请求：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Post</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://httpbin.org/post&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请求头, x-www-form-urlencoded格式的数据</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交参数设置</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">    map.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;鲁大师&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组装请求体</span></span><br><span class="line">    HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, httpHeaders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送post请求并打印结果 以String类型接收响应结果JSON字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> restTemplate.postForObject(url, request, String.class);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-FileSystemResource上传文件"><a href="#2-3-FileSystemResource上传文件" class="headerlink" title="2.3 FileSystemResource上传文件"></a>2.3 FileSystemResource上传文件</h3><p><strong>使用这种方式的好处就是写起来比较简单,缺点是会在项目根路径下生成一个临时文件,上传成功之后你需要将生成的临时文件删除掉</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">uploadFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8090/mvc/test/file&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\user\\Pictures\\22.jpg&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用FileSystemResource进行上传，但是FileSystemResource的创建只能通过File或者文件的路径来生成，</span></span><br><span class="line"><span class="comment">     * 也就是说文件已经真实存在磁盘了，所以解决方案是先存到本地然后再进行读取，然后再删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">FileSystemResource</span> <span class="variable">systemResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line"></span><br><span class="line">    MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">    map.add(<span class="string">&quot;files&quot;</span>, systemResource);</span><br><span class="line">    map.add(<span class="string">&quot;files&quot;</span>, systemResource);</span><br><span class="line"></span><br><span class="line">    ResponseEntity&lt;String&gt; post = RestTemplateUtil.post(url, map, String.class);</span><br><span class="line">    System.out.println(post.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-ByteArrayResource上传文件"><a href="#2-4-ByteArrayResource上传文件" class="headerlink" title="2.4 ByteArrayResource上传文件"></a>2.4 ByteArrayResource上传文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">uploadFile2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8090/mvc/test/file&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\user\\Pictures\\22.jpg&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = Files.readAllBytes(Paths.get(filePath));</span><br><span class="line">    System.out.println(<span class="string">&quot;-----数组长度：-----&quot;</span>+bytes.length);</span><br><span class="line">    <span class="type">ByteArrayResource</span> <span class="variable">byteArrayResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayResource</span>(bytes) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getFilename</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;originalFilename.jpg&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">contentLength</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bytes.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">    map.add(<span class="string">&quot;files&quot;</span>, byteArrayResource);</span><br><span class="line">    map.add(<span class="string">&quot;files&quot;</span>, byteArrayResource);</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    headers.setContentType(MediaType.MULTIPART_FORM_DATA);</span><br><span class="line"></span><br><span class="line">    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(map, headers);</span><br><span class="line">    ResponseEntity&lt;String&gt; post = RestTemplateUtil.post(url, entity, String.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(post.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-大文件下载"><a href="#2-5-大文件下载" class="headerlink" title="2.5 大文件下载"></a>2.5 大文件下载</h3><ul><li>设置了请求头APPLICATION_OCTET_STREAM，表示以流的形式进行数据加载</li><li>RequestCallback 结合File.copy保证了接收到一部分文件内容，就向磁盘写入一部分内容。而不是全部加载到内存，最后再写入磁盘文件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDownLoadBigFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// 待下载的文件地址</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8888/2020/08/12/028b38f1-3f9b-4088-9bea-1af8c18cd619.png&quot;</span>;</span><br><span class="line">   <span class="comment">// 文件保存的本地路径</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">targetPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\data\\local\\splash-down-big.png&quot;</span>;</span><br><span class="line">   <span class="comment">//定义请求头的接收类型</span></span><br><span class="line">   <span class="type">RequestCallback</span> <span class="variable">requestCallback</span> <span class="operator">=</span> request -&gt; request.getHeaders()</span><br><span class="line">               .setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM, MediaType.ALL));</span><br><span class="line">   <span class="comment">//对响应进行流式处理而不是将其全部加载到内存中</span></span><br><span class="line">   restTemplate.execute(url, HttpMethod.GET, requestCallback, clientHttpResponse -&gt; &#123;</span><br><span class="line">      Files.copy(clientHttpResponse.getBody(), Paths.get(targetPath));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-文件下载"><a href="#2-6-文件下载" class="headerlink" title="2.6 文件下载"></a>2.6 文件下载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testDownLoad</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// 待下载的文件地址</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8888/2020/08/12/028b38f1-3f9b-4088-9bea-1af8c18cd619.png&quot;</span>;</span><br><span class="line">   ResponseEntity&lt;<span class="type">byte</span>[]&gt; rsp = restTemplate.getForEntity(url, <span class="type">byte</span>[].class);</span><br><span class="line">   System.out.println(<span class="string">&quot;文件下载请求结果状态码：&quot;</span> + rsp.getStatusCode());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将下载下来的文件内容保存到本地</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">targetPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\data\\local\\splash-down.png&quot;</span>;</span><br><span class="line">   Files.write(Paths.get(targetPath), Objects.requireNonNull(rsp.getBody(),</span><br><span class="line">               <span class="string">&quot;未获取到下载文件&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-GET请求"><a href="#2-7-GET请求" class="headerlink" title="2.7 GET请求"></a>2.7 GET请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getReq</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    httpHeaders.setBearerAuth(token);</span><br><span class="line">    ResponseEntity&lt;String&gt; responseEntity = RestTemplateUtil.get(url, httpHeaders, String.class);</span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> responseEntity.getBody();</span><br><span class="line">    System.out.println(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-POST请求"><a href="#2-8-POST请求" class="headerlink" title="2.8 POST请求"></a>2.8 POST请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postReq</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;2173e252-2405-4d68-99e7-6ec6de31ebc4&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url3</span> <span class="operator">=</span> <span class="string">&quot;https://scrmtest.youcash.com/scrm/v3/company-server/customerTag/getTagList&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    jsonObject.put(<span class="string">&quot;isBySecret&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    jsonObject.put(<span class="string">&quot;keyValue&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    header.setBearerAuth(token);</span><br><span class="line">    header.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line"></span><br><span class="line">    HttpEntity&lt;JSONObject&gt; entity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(jsonObject, header);</span><br><span class="line">    ResponseEntity&lt;JSONObject&gt; post = RestTemplateUtil.post(url3, entity, JSONObject.class);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">body</span> <span class="operator">=</span> post.getBody();</span><br><span class="line"></span><br><span class="line">    System.out.println(body.toJSONString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-工具类"><a href="#2-9-工具类" class="headerlink" title="2.9 工具类"></a>2.9 工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unravel.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.client.RestTemplateBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RestTemplate</span> <span class="variable">REST_TEMPLATE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>()</span><br><span class="line">            <span class="comment">//设置连接超时时间</span></span><br><span class="line">            .setConnectTimeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">            <span class="comment">//设置读取超时时间</span></span><br><span class="line">            .setReadTimeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">            <span class="comment">//设置根路径</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">appendParams</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (params == <span class="literal">null</span> || params.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator = params.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">currentKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">currentValue</span> <span class="operator">=</span> params.get(currentKey);</span><br><span class="line">            <span class="keyword">if</span> (currentValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(currentKey);</span><br><span class="line">            sb.append(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">            sb.append(params.get(currentKey));</span><br><span class="line">            <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.equals(<span class="string">&quot;?&quot;</span>) ? <span class="string">&quot;&quot;</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----------------------------------GET-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">get</span><span class="params">(String url, Class&lt;T&gt; responseType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.getForEntity(url, responseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">get</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.getForEntity(url, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">get</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.getForEntity(url, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的GET请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">get</span><span class="params">(String url, Map&lt;String, String&gt; headers, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> get(url, httpHeaders, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的GET请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">get</span><span class="params">(String url, HttpHeaders headers, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;?&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(headers);</span><br><span class="line">        <span class="keyword">return</span> exchange(url, HttpMethod.GET, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的GET请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">get</span><span class="params">(String url, Map&lt;String, String&gt; headers, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> get(url, httpHeaders, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的GET请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">get</span><span class="params">(String url, HttpHeaders headers, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;?&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(headers);</span><br><span class="line">        <span class="keyword">return</span> exchange(url, HttpMethod.GET, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------------POST-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, Class&lt;T&gt; responseType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.postForEntity(url, HttpEntity.EMPTY, responseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, Object requestBody, Class&lt;T&gt; responseType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.postForEntity(url, requestBody, responseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.postForEntity(url, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.postForEntity(url, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, Map&lt;String, String&gt; headers, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> post(url, httpHeaders, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, HttpHeaders headers, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody, headers);</span><br><span class="line">        <span class="keyword">return</span> post(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, Map&lt;String, String&gt; headers, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> post(url, httpHeaders, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, HttpHeaders headers, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody, headers);</span><br><span class="line">        <span class="keyword">return</span> post(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义请求头和请求体的POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity 请求头和请求体封装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.exchange(url, HttpMethod.POST, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义请求头和请求体的POST请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity 请求头和请求体封装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">post</span><span class="params">(String url, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.exchange(url, HttpMethod.POST, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------------PUT-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> put(url, HttpEntity.EMPTY, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody);</span><br><span class="line">        <span class="keyword">return</span> put(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody);</span><br><span class="line">        <span class="keyword">return</span> put(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, Map&lt;String, String&gt; headers, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> put(url, httpHeaders, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, HttpHeaders headers, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody, headers);</span><br><span class="line">        <span class="keyword">return</span> put(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, Map&lt;String, String&gt; headers, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> put(url, httpHeaders, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, HttpHeaders headers, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody, headers);</span><br><span class="line">        <span class="keyword">return</span> put(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义请求头和请求体的PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity 请求头和请求体封装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.exchange(url, HttpMethod.PUT, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义请求头和请求体的PUT请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity 请求头和请求体封装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">put</span><span class="params">(String url, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.exchange(url, HttpMethod.PUT, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------------DELETE-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> delete(url, HttpEntity.EMPTY, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> delete(url, HttpEntity.EMPTY, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody);</span><br><span class="line">        <span class="keyword">return</span> delete(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody);</span><br><span class="line">        <span class="keyword">return</span> delete(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, Map&lt;String, String&gt; headers, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> delete(url, httpHeaders, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, HttpHeaders headers, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(headers);</span><br><span class="line">        <span class="keyword">return</span> delete(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, Map&lt;String, String&gt; headers, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> delete(url, httpHeaders, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, HttpHeaders headers, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(headers);</span><br><span class="line">        <span class="keyword">return</span> delete(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, Map&lt;String, String&gt; headers, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> delete(url, httpHeaders, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, HttpHeaders headers, Object requestBody, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(requestBody, headers);</span><br><span class="line">        <span class="keyword">return</span> delete(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, Map&lt;String, String&gt; headers, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">httpHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        httpHeaders.setAll(headers);</span><br><span class="line">        <span class="keyword">return</span> delete(url, httpHeaders, requestBody, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带请求头的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers 请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 请求参数体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, HttpHeaders headers, Object requestBody, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        HttpEntity&lt;Object&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;Object&gt;(requestBody, headers);</span><br><span class="line">        <span class="keyword">return</span> delete(url, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义请求头和请求体的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity 请求头和请求体封装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.exchange(url, HttpMethod.DELETE, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义请求头和请求体的DELETE请求调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity 请求头和请求体封装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">delete</span><span class="params">(String url, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.exchange(url, HttpMethod.DELETE, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------------通用方法-------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 请求方法类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity 请求头和请求体封装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，按顺序依次对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">exchange</span><span class="params">(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Object... uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.exchange(url, method, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用调用方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 请求URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 请求方法类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity 请求头和请求体封装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables URL中的变量，与Map中的key对应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResponseEntity 响应对象封装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">exchange</span><span class="params">(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE.exchange(url, method, requestEntity, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取RestTemplate实例对象，可自由调用其方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RestTemplate实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REST_TEMPLATE;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-OkHttp"><a href="#3-OkHttp" class="headerlink" title="3. OkHttp"></a>3. OkHttp</h2><ul><li>.header()：可以设置唯一的请求头，如果重新设置相同的请求头信息，后设置的值会覆盖之前的数据</li><li>.addheader()：更适用于多值的请求头</li></ul><h3 id="3-1-post提交json字符串"><a href="#3-1-post提交json字符串" class="headerlink" title="3.1 post提交json字符串"></a>3.1 post提交json字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"><span class="type">MediaType</span> <span class="variable">json</span> <span class="operator">=</span> MediaType.parse(<span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">body</span> <span class="operator">=</span> RequestBody.create(json, <span class="string">&quot;json字符串&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().post(body).url(<span class="string">&quot;请求的url&quot;</span>).build();</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> okHttpClient.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span>(!response.isSuccessful()) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">    <span class="comment">// 一般会在这抛个异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">    response.body().close();</span><br><span class="line">    <span class="keyword">return</span> reslut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-post提交键值对"><a href="#3-2-post提交键值对" class="headerlink" title="3.2 post提交键值对"></a>3.2 post提交键值对</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"><span class="type">FormBody</span> <span class="variable">formBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder()</span><br><span class="line">.add(<span class="string">&quot;参数名1&quot;</span>, <span class="string">&quot;参数1&quot;</span>)</span><br><span class="line">.add(<span class="string">&quot;参数名2&quot;</span>, <span class="string">&quot;参数2&quot;</span>)</span><br><span class="line">.build();</span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;请求的url&quot;</span>).post(formBody).build();</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> okHttpClient.newCall(request).execute();</span><br><span class="line"><span class="keyword">if</span>(!response.isSuccessful()) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">    <span class="comment">// 一般会在这抛个异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">    response.body().close();</span><br><span class="line">    <span class="keyword">return</span> reslut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-上传文件"><a href="#3-3-上传文件" class="headerlink" title="3.3 上传文件"></a>3.3 上传文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"><span class="comment">// file是要上传的文件 File()</span></span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">fileBody</span> <span class="operator">=</span> RequestBody.create(MediaType.parse(<span class="string">&quot;multipart/form-data&quot;</span>), file);</span><br><span class="line">    <span class="comment">// 不仅可以支持传文件，还可以在传文件的同时，传参数</span></span><br><span class="line">    <span class="type">MultipartBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipartBody</span>.Builder()</span><br><span class="line">                .setType(MultipartBody.FORM)</span><br><span class="line">                .addFormDataPart(<span class="string">&quot;参数名1&quot;</span>, <span class="string">&quot;参数1&quot;</span>)</span><br><span class="line">                .addFormDataPart(<span class="string">&quot;接收文件的参数名&quot;</span>, <span class="string">&quot;文件名&quot;</span>, fileBody)</span><br><span class="line">                .build();</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;请求url&quot;</span>).post(requestBody).build();</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> okHttpClient.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span>(!response.isSuccessful()) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">    <span class="comment">// 一般会在这抛个异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">    response.body().close();</span><br><span class="line">    <span class="keyword">return</span> reslut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-工具类"><a href="#3-4-工具类" class="headerlink" title="3.4 工具类"></a>3.4 工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> okhttp3.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManager;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; headerMap;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; paramMap;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> Request.Builder request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化okHttpClient，并且允许https访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">OkHttpUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (okHttpClient == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OkHttpUtils.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (okHttpClient == <span class="literal">null</span>) &#123;</span><br><span class="line">                    TrustManager[] trustManagers = buildTrustManagers();</span><br><span class="line">                    okHttpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                            .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</span><br><span class="line">                            .writeTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br><span class="line">                            .readTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br><span class="line">                            .sslSocketFactory(createSSLSocketFactory(trustManagers), (X509TrustManager) trustManagers[<span class="number">0</span>])</span><br><span class="line">                            .hostnameVerifier((hostName, session) -&gt; <span class="literal">true</span>)</span><br><span class="line">                            .retryOnConnectionFailure(<span class="literal">true</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                    addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于异步请求时，控制访问线程数，返回结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore <span class="title function_">getSemaphoreInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//只能1个线程同时访问</span></span><br><span class="line">        <span class="keyword">synchronized</span> (OkHttpUtils.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (semaphore == <span class="literal">null</span>) &#123;</span><br><span class="line">                semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建OkHttpUtils</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OkHttpUtils <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OkHttpUtils</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加url</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OkHttpUtils <span class="title function_">url</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   参数名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OkHttpUtils <span class="title function_">addParam</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (paramMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            paramMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        paramMap.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加请求头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   参数名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OkHttpUtils <span class="title function_">addHeader</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headerMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            headerMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        headerMap.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化get方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OkHttpUtils <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        request = <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().get();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">urlBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(url);</span><br><span class="line">        <span class="keyword">if</span> (paramMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            urlBuilder.append(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : paramMap.entrySet()) &#123;</span><br><span class="line">                    urlBuilder.append(URLEncoder.encode(entry.getKey(), <span class="string">&quot;utf-8&quot;</span>)).</span><br><span class="line">                            append(<span class="string">&quot;=&quot;</span>).</span><br><span class="line">                            append(URLEncoder.encode(entry.getValue(), <span class="string">&quot;utf-8&quot;</span>)).</span><br><span class="line">                            append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            urlBuilder.deleteCharAt(urlBuilder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        request.url(urlBuilder.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化post方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isJsonPost true等于json的方式提交数据，类似postman里post方法的raw</span></span><br><span class="line"><span class="comment">     *                   false等于普通的表单提交</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OkHttpUtils <span class="title function_">post</span><span class="params">(<span class="type">boolean</span> isJsonPost)</span> &#123;</span><br><span class="line">        RequestBody requestBody;</span><br><span class="line">        <span class="keyword">if</span> (isJsonPost) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (paramMap != <span class="literal">null</span>) &#123;</span><br><span class="line">                json = JSON.toJSONString(paramMap);</span><br><span class="line">            &#125;</span><br><span class="line">            requestBody = RequestBody.create(MediaType.parse(<span class="string">&quot;application/json; charset=utf-8&quot;</span>), json);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            FormBody.<span class="type">Builder</span> <span class="variable">formBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder();</span><br><span class="line">            <span class="keyword">if</span> (paramMap != <span class="literal">null</span>) &#123;</span><br><span class="line">                paramMap.forEach(formBody::add);</span><br><span class="line">            &#125;</span><br><span class="line">            requestBody = formBody.build();</span><br><span class="line">        &#125;</span><br><span class="line">        request = <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().post(requestBody).url(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sync</span><span class="params">()</span> &#123;</span><br><span class="line">        setHeader(request);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> okHttpClient.newCall(request.build()).execute();</span><br><span class="line">            <span class="keyword">assert</span> response.body() != <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> response.body().string();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;请求失败：&quot;</span> + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步请求，有返回值(限流的,同一时间只允许一个访问,其他等待)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">async</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        setHeader(request);</span><br><span class="line">        okHttpClient.newCall(request.build()).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">                buffer.append(<span class="string">&quot;请求出错：&quot;</span>).append(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">assert</span> response.body() != <span class="literal">null</span>;</span><br><span class="line">                buffer.append(response.body().string());</span><br><span class="line">                getSemaphoreInstance().release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getSemaphoreInstance().acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步请求，带有接口回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callBack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">async</span><span class="params">(ICallBack callBack)</span> &#123;</span><br><span class="line">        setHeader(request);</span><br><span class="line">        okHttpClient.newCall(request.build()).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">                callBack.onFailure(call, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">assert</span> response.body() != <span class="literal">null</span>;</span><br><span class="line">                callBack.onSuccessful(call, response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为request添加请求头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeader</span><span class="params">(Request.Builder request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headerMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : headerMap.entrySet()) &#123;</span><br><span class="line">                    request.addHeader(entry.getKey(), entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成安全套接字工厂，用于https请求的证书跳过</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SSLSocketFactory <span class="title function_">createSSLSocketFactory</span><span class="params">(TrustManager[] trustAllCerts)</span> &#123;</span><br><span class="line">        <span class="type">SSLSocketFactory</span> <span class="variable">ssfFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SSLContext</span> <span class="variable">sc</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>);</span><br><span class="line">            sc.init(<span class="literal">null</span>, trustAllCerts, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">            ssfFactory = sc.getSocketFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ssfFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TrustManager[] buildTrustManagers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TrustManager</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">X509TrustManager</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">X509Certificate</span>[]&#123;&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义一个接口回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICallBack</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onSuccessful</span><span class="params">(Call call, String data)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, String errorMsg)</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-使用案例"><a href="#3-5-使用案例" class="headerlink" title="3.5 使用案例"></a>3.5 使用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">一定要在`url`之后在使用`get|post` 否则会空指针异常的</span><br><span class="line"></span><br><span class="line">#### 发送get请求</span><br><span class="line"><span class="type">String</span> <span class="variable">sync</span> <span class="operator">=</span> OkHttpUtils.builder().url(<span class="string">&quot;http://localhost:9100/user/all&quot;</span>)</span><br><span class="line">    .addHeader(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;xxxxxxx&quot;</span>)</span><br><span class="line">    .addParam(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xxx&quot;</span>).addParam(<span class="string">&quot;pass&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    .get()</span><br><span class="line">    .sync();</span><br><span class="line">System.out.println(sync);</span><br><span class="line"></span><br><span class="line">##### 发送Post请求</span><br><span class="line"><span class="type">String</span> <span class="variable">sync</span> <span class="operator">=</span> OkHttpUtils.builder().url(<span class="string">&quot;http://localhost:9100/user/all&quot;</span>)</span><br><span class="line">    .addHeader(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;xxxxxxx&quot;</span>)</span><br><span class="line">    .addParam(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xxx&quot;</span>).addParam(<span class="string">&quot;pass&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    .post(<span class="literal">true</span>) <span class="comment">// true 为json提交方式</span></span><br><span class="line">    .sync();</span><br><span class="line">System.out.println(sync);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 发送异步请求</span><br><span class="line"></span><br><span class="line">需要实现ICallBack接口</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncHttpServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OkHttpUtils</span>.ICallBack &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccessful</span><span class="params">(Call call, String data)</span> &#123;</span><br><span class="line">        <span class="comment">//接口正常返回的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;onSuccessful&quot;</span>+data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, String errorMsg)</span> &#123;</span><br><span class="line">        <span class="comment">//接口错误返回的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;onFailure&quot;</span>+errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 发送异步请求</span><br><span class="line"></span><br><span class="line">OkHttpUtils.builder().url(<span class="string">&quot;http://localhost:9100/user/all&quot;</span>)</span><br><span class="line">    .addHeader(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;xxxxxxx&quot;</span>)</span><br><span class="line">    .addParam(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xxx&quot;</span>).addParam(<span class="string">&quot;pass&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    .post(<span class="literal">true</span>)</span><br><span class="line">    .async(<span class="keyword">new</span> <span class="title class_">AsyncHttpServiceImpl</span>());</span><br></pre></td></tr></table></figure><h2 id="4-spring-retry"><a href="#4-spring-retry" class="headerlink" title="4. spring-retry"></a>4. spring-retry</h2><p><a href="https://github.com/spring-projects/spring-retry">spring retry </a>提供了<strong>注解</strong> 和 <strong>编程</strong> 两种支持,通过异常失败是否需要重试。提供了 RetryTemplate 支持，类似RestTemplate，使用非常的简单方便。</p><p>使用spring-retry实现重试，由于使用的是AOP，所以必须由AOP容器调用，否则会失败，和@transactional注解一样，本类调用是不行的。</p><p><strong>引入坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-1-注解使用"><a href="#4-1-注解使用" class="headerlink" title="4.1 注解使用"></a>4.1 注解使用</h3><p><strong>开启重试功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CommonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解：</strong></p><p>@EnableRetry 开启重试功能</p><p>@Retryable注解的方法在发生异常时会重试，参数说明：<br>1、value：当指定异常发生时会进行重试 ,HttpClientErrorException是RestClientException的子类。<br>2、include：和value一样，默认空。如果 exclude也为空时，所有异常都重试<br>3、exclude：指定异常不重试，默认空。如果 include也为空时，所有异常都重试<br>4、maxAttemps：最大重试次数，默认3<br>5、backoff：重试等待策略，默认空<br>6、@Backoff注解为重试等待的策略，参数说明：<br>7、delay：指定重试的延时时间，默认为1000毫秒<br>8、multiplier：指定延迟的倍数，比如设置delay&#x3D;5000，multiplier&#x3D;2时，第一次重试为5秒后，第二次为10(5x2)秒，第三次为20(10x2)秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retryable(maxAttempts = 2, backoff = @Backoff(delay = 2000L,multiplier = 1),value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sendRequest</span><span class="params">(String url, Long num)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求开始&quot;</span>+ LocalDateTime.now());</span><br><span class="line">        <span class="type">Long</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(url+<span class="string">&quot;?num=&quot;</span>+num, Long.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;请求结束&quot;</span>+ LocalDateTime.now());</span><br><span class="line">        <span class="keyword">return</span> forObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义回调,注意异常类型和方法返回值类型要与重试方法一致</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Recover</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">recover2</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Remote RPC Call fail&quot;</span>,e);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-编程使用"><a href="#4-2-编程使用" class="headerlink" title="4.2 编程使用"></a>4.2 编程使用</h3><h4 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1. 基本信息"></a>1. 基本信息</h4><p><strong>什么时候使用RetryTemplate？</strong></p><ul><li>不使用spring容器的时候，使用了@Retryable，@CircuitBreaker的方法不能在本类被调用，不然重试机制不会生效。也就是要标记为@Service，然后在其它类使用@Autowired注入或者@Bean去实例才能生效。</li><li>需要使用复杂策略机制和异常场景时</li><li>使用有状态重试,且需要全局模式时建议使用</li><li>需要使用监听器Listener的场景</li><li>需要使用Retry统计分析</li></ul><p><strong>RetryPolicy 重试策略</strong></p><ul><li><strong>NeverRetryPolicy</strong>：只允许调用RetryCallback一次，不允许重试；</li><li><strong>AlwaysRetryPolicy</strong>：允许无限重试，直到成功，此方式逻辑不当会导致死循环；</li><li><strong>SimpleRetryPolicy</strong>：固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略；</li><li><strong>TimeoutRetryPolicy</strong>：超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试；</li><li><strong>CircuitBreakerRetryPolicy</strong>：有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate，稍后详细介绍该策略；</li><li><strong>CompositeRetryPolicy</strong>：组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即可以，但不管哪种组合方式，组合中的每一个策略都会执行。</li></ul><p><strong>BackOffPolicy 退避策略</strong></p><ul><li><strong>NoBackOffPolicy</strong>：无退避算法策略，即当重试时是立即重试；</li><li><strong>FixedBackOffPolicy</strong>：固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒；</li><li><strong>UniformRandomBackOffPolicy</strong>：随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod，该策略在[minBackOffPeriod,maxBackOffPeriod之间取一个随机休眠时间，minBackOffPeriod默认500毫秒，maxBackOffPeriod默认1500毫秒；</li><li><strong>ExponentialBackOffPolicy</strong>：指数退避策略，需设置参数sleeper、initialInterval、maxInterval和multiplier，initialInterval指定初始休眠时间，默认100毫秒，maxInterval指定最大休眠时间，默认30秒，multiplier指定乘数，即下一次休眠时间为当前休眠时间*multiplier；</li><li><strong>ExponentialRandomBackOffPolicy</strong>：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致DDos，使用随机休眠时间来避免这种情况。</li></ul><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRetryConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//简单的，常用</span></span><br><span class="line">    <span class="meta">@Bean(&quot;retryTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RetryTemplate <span class="title function_">retryTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义简易重试策略，最大重试次数为3次,重试间隔为3s</span></span><br><span class="line">        <span class="keyword">return</span> RetryTemplate.builder()</span><br><span class="line">                .maxAttempts(<span class="number">3</span>)</span><br><span class="line">                .fixedBackoff(<span class="number">3000</span>)</span><br><span class="line">                .retryOn(RuntimeException.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//详细的，少用</span></span><br><span class="line"><span class="meta">@Bean(&quot;retryTemplateDemo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RetryTemplate <span class="title function_">retryTemplateDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.重试策略</span></span><br><span class="line">    <span class="comment">// 不重试</span></span><br><span class="line">    <span class="type">NeverRetryPolicy</span> <span class="variable">neverRetryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NeverRetryPolicy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无限重试</span></span><br><span class="line">    <span class="type">AlwaysRetryPolicy</span> <span class="variable">alwaysRetryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlwaysRetryPolicy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置不同异常的重试策略，类似组合重试策略，区别在于这里只区分不同异常的重试</span></span><br><span class="line">    <span class="type">ExceptionClassifierRetryPolicy</span> <span class="variable">exceptionClassifierRetryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionClassifierRetryPolicy</span>();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;, RetryPolicy&gt; policyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    policyMap.put(IOException.class, alwaysRetryPolicy);</span><br><span class="line">    policyMap.put(InterruptedIOException.class, neverRetryPolicy);</span><br><span class="line">    policyMap.put(UnknownHostException.class, neverRetryPolicy);</span><br><span class="line">    exceptionClassifierRetryPolicy.setPolicyMap(policyMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定次数重试，默认最大重试次数为5次，RetryTemplate默认重试策略</span></span><br><span class="line">    <span class="type">SimpleRetryPolicy</span> <span class="variable">simpleRetryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRetryPolicy</span>();</span><br><span class="line">    simpleRetryPolicy.setMaxAttempts(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时时间重试，默认超时时间为1秒，在指定的超时时间内重试</span></span><br><span class="line">    <span class="type">TimeoutRetryPolicy</span> <span class="variable">timeoutRetryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimeoutRetryPolicy</span>();</span><br><span class="line">    timeoutRetryPolicy.setTimeout(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 组合重试策略，有两种组合方式：</span></span><br><span class="line"><span class="comment">     *  1.悲观默认重试，有不重试的策略则不重试。</span></span><br><span class="line"><span class="comment">     *  2.乐观默认不重试，有需要重试的策略则重试。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">CompositeRetryPolicy</span> <span class="variable">compositeRetryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositeRetryPolicy</span>();</span><br><span class="line">    compositeRetryPolicy.setOptimistic(<span class="literal">true</span>);</span><br><span class="line">    compositeRetryPolicy.setPolicies(<span class="keyword">new</span> <span class="title class_">RetryPolicy</span>[]&#123;simpleRetryPolicy, timeoutRetryPolicy&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有熔断功能的重试</span></span><br><span class="line">    <span class="type">CircuitBreakerRetryPolicy</span> <span class="variable">circuitBreakerRetryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircuitBreakerRetryPolicy</span>(compositeRetryPolicy);</span><br><span class="line">    <span class="comment">// 5s内失败10次，则开启熔断</span></span><br><span class="line">    circuitBreakerRetryPolicy.setOpenTimeout(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">// 10s之后熔断恢复</span></span><br><span class="line">    circuitBreakerRetryPolicy.setResetTimeout(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.退避策略（上一次执行失败之后，间隔多久进行下一次重试）</span></span><br><span class="line">    <span class="comment">// 立即重试</span></span><br><span class="line">    <span class="type">NoBackOffPolicy</span> <span class="variable">noBackOffPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoBackOffPolicy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定时间后重试，默认1s</span></span><br><span class="line">    <span class="type">FixedBackOffPolicy</span> <span class="variable">fixedBackOffPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOffPolicy</span>();</span><br><span class="line">    fixedBackOffPolicy.setBackOffPeriod(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机时间后重试（如下：从500ms到1500ms内取一个随机时间后进行重试）</span></span><br><span class="line">    <span class="type">UniformRandomBackOffPolicy</span> <span class="variable">uniformRandomBackOffPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UniformRandomBackOffPolicy</span>();</span><br><span class="line">    uniformRandomBackOffPolicy.setMinBackOffPeriod(<span class="number">500</span>);</span><br><span class="line">    uniformRandomBackOffPolicy.setMaxBackOffPeriod(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指数退避策略（如下：初始休眠时间100ms，最大休眠时间30s，下一次休眠时间为当前休眠时间*2）</span></span><br><span class="line">    <span class="type">ExponentialBackOffPolicy</span> <span class="variable">exponentialBackOffPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackOffPolicy</span>();</span><br><span class="line">    exponentialBackOffPolicy.setInitialInterval(<span class="number">100</span>);</span><br><span class="line">    exponentialBackOffPolicy.setMaxInterval(<span class="number">30000</span>);</span><br><span class="line">    exponentialBackOffPolicy.setMultiplier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机指数退避策略</span></span><br><span class="line">    <span class="type">ExponentialRandomBackOffPolicy</span> <span class="variable">exponentialRandomBackOffPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialRandomBackOffPolicy</span>();</span><br><span class="line">    exponentialRandomBackOffPolicy.setInitialInterval(<span class="number">100</span>);</span><br><span class="line">    exponentialRandomBackOffPolicy.setMaxInterval(<span class="number">30000</span>);</span><br><span class="line">    exponentialRandomBackOffPolicy.setMultiplier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.return</span></span><br><span class="line">    <span class="type">RetryTemplate</span> <span class="variable">retryTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryTemplate</span>();</span><br><span class="line">    retryTemplate.setRetryPolicy(circuitBreakerRetryPolicy);</span><br><span class="line">    <span class="keyword">return</span> retryTemplate;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-代码调用"><a href="#3-代码调用" class="headerlink" title="3. 代码调用"></a>3. 代码调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入RetryTemplate</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RetryTemplate retryTemplateFixed;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> retryTemplateFixed.execute(</span><br><span class="line">                <span class="comment">// 重试回调</span></span><br><span class="line">                retryContext -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> RetryTask.retryTask(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;调用的结果:&#123;&#125;&quot;</span>, b);</span><br><span class="line">                    <span class="keyword">return</span> b;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 恢复回调（达到最大重试次数，或者抛出不满足重试条件的异常）</span></span><br><span class="line">                retryContext -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;已达到最大重试次数或抛出了不重试的异常~~~&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;执行结果:&#123;&#125;&quot;</span>,execute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-监听重试"><a href="#4-监听重试" class="headerlink" title="4. 监听重试"></a>4. 监听重试</h4><p>通过实现RetryListener接口，重写open、close、onError这三个方法，既可以完成对重试过程的追踪，也可以添加额外的处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryListenerTemplate</span> <span class="keyword">implements</span> <span class="title class_">RetryListener</span> &#123;</span><br><span class="line">    <span class="comment">// 进入重试前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, E <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="type">boolean</span> <span class="title function_">open</span><span class="params">(RetryContext retryContext, RetryCallback&lt;T, E&gt; retryCallback)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--------------------------进入重试方法--------------------------&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试结束后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, E <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(RetryContext retryContext, RetryCallback&lt;T, E&gt; retryCallback, Throwable throwable)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;--------------------------重试方法结束--------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获到异常时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, E <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(RetryContext retryContext, RetryCallback&lt;T, E&gt; retryCallback, Throwable throwable)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--------------------------第&quot;</span> + retryContext.getRetryCount() + <span class="string">&quot;次重试--------------------------&quot;</span>);</span><br><span class="line">        log.error(throwable.getMessage(), throwable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，通过继承RetryListenerSupport，也可以从open、close、onError这三个方法中，选择性的重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryListener4Open</span> <span class="keyword">extends</span> <span class="title class_">RetryListenerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, E <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="type">boolean</span> <span class="title function_">open</span><span class="params">(RetryContext context, RetryCallback&lt;T, E&gt; callback)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.open(context, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例化RetryTemplate时，配置上该RetryListener实例即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retryTemplate.setListeners(<span class="keyword">new</span> <span class="title class_">RetryListener</span>[] &#123;retryListenerTemplate&#125;);</span><br></pre></td></tr></table></figure><h1 id="摘抄的OKhttp"><a href="#摘抄的OKhttp" class="headerlink" title="摘抄的OKhttp"></a>摘抄的OKhttp</h1><h2 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1. GET请求"></a>1. GET请求</h2><p>为了从服务器上获得我们的待办事项列表，我们需要执行一个GET HTTP请求。OkHttp通过<code>Request.Builder</code> ，提供了一个不错的API来构建请求。</p><h3 id="同步的GET"><a href="#同步的GET" class="headerlink" title="同步的GET"></a>同步的GET</h3><p>做一个GET请求就像这样简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://mytodoserver.com/todolist&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(getRequest).execute();</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，这是一个用OkHttp执行请求的<strong>同步</strong>方式。(你应该在一个非UI线程上运行，否则，在你的应用程序中会有性能问题，而且Android会抛出一个<a href="https://link.juejin.cn/?target=https://developer.android.com/reference/android/os/NetworkOnMainThreadException">错误</a>)。</p><h3 id="异步GET"><a href="#异步GET" class="headerlink" title="异步GET"></a>异步GET</h3><p>这个请求的<strong>异步</strong>版本为你提供了一个回调，当响应被取走或发生错误时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://mytodoserver.com/todolist&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">client.newCall(getRequest).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(response.body().string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<em>从现在开始，我将只展示同步版本的调用，以避免使用大量的模板代码。只要有可能，我也会尝试使用标准的Java APIs，以使代码在非Android环境中可重复使用。</em></p><h3 id="OkHttp中的查询参数"><a href="#OkHttp中的查询参数" class="headerlink" title="OkHttp中的查询参数"></a>OkHttp中的查询参数</h3><p>你可以向你的请求传递查询参数，比如在服务器端实现对已完成或未完成的待办事项进行过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line">HttpUrl.<span class="type">Builder</span> <span class="variable">queryUrlBuilder</span> <span class="operator">=</span> HttpUrl.get(<span class="string">&quot;https://server.com/todolist&quot;</span>).newBuilder();</span><br><span class="line">queryUrlBuilder.addQueryParameter(<span class="string">&quot;filter&quot;</span>, <span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(queryUrlBuilder.build())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpUrl.Builder</code> 将生成带有查询参数的适当URL。 <code>[https://mytodoserver.com/todolist?filter=done](https://mytodoserver.com/todolist?filter=done)</code>.</p><p>你可能会理所当然地问：”为什么不直接使用手动创建的URL本身呢？”你可以。但是一旦你的URL构建逻辑变得更加复杂（更多的查询参数），那么这个类就会派上用场。该库的开发者有<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/4.x/okhttp/okhttp3/-http-url/%23why-another-url-model">额外的理由来使用HttpUrl</a>。</p><h2 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h2><p>现在我们已经从我们的服务器上下载了所有的待办事项。但是如何创建新的to-dos或将一个to-dos标记为完成？用一个简单的POST请求。</p><h3 id="简单的POST请求"><a href="#简单的POST请求" class="headerlink" title="简单的POST请求"></a>简单的POST请求</h3><p>让我们向我们的端点发送POST请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder()</span><br><span class="line">        .add(<span class="string">&quot;new&quot;</span>, <span class="string">&quot;This is my new TODO&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">postRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://mytodoserver.com/new&quot;</span>)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(postRequest).execute();</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，POST请求的主体是一个<code>application/x-www-form-urlencoded</code> key-value pair数据。但我们可以发送任何我们想要的类型。下面是一个以JSON为主体的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">jsonObject.put(<span class="string">&quot;todo_id&quot;</span>, <span class="number">123</span>);</span><br><span class="line">jsonObject.put(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">requestJsonBody</span> <span class="operator">=</span> RequestBody.create(</span><br><span class="line">        jsonObject.toString(),</span><br><span class="line">        MediaType.parse(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">postRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://mytodoserver.com/modify&quot;</span>)</span><br><span class="line">        .post(requestJsonBody)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(postRequest).execute();</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>我们也有可能想给我们的新待办事项附上一个文件（如图片）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipartBody</span>.Builder()</span><br><span class="line">        .addFormDataPart(<span class="string">&quot;new&quot;</span>, <span class="string">&quot;This is my new TODO&quot;</span>)</span><br><span class="line">        .addFormDataPart(<span class="string">&quot;image&quot;</span>, <span class="string">&quot;attachment.png&quot;</span>,</span><br><span class="line">                RequestBody.create(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/of/attachment.png&quot;</span>), MediaType.parse(<span class="string">&quot;image/png&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        .setType(MultipartBody.FORM)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">postRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://mytodoserver.com/new&quot;</span>)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(postRequest).execute();</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前类似，我们执行一个多部分的HTTP请求，在那里我们可以附加所需的文件。</p><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><p>在保存待办事项时，有可能不小心选择了错误的附件，所以与其等到上传结束，不如确保请求可以随时取消，并在以后用正确的值重新启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCancelSysnc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">api</span> <span class="operator">=</span> <span class="string">&quot;/api/files/1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s%s&quot;</span>, BASE_URL, api);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .get()  </span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> client.newCall(request);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call.execute();</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//测试连接的取消</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="comment">//1分钟获取不到结果就取消请求</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - start &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            call.cancel();</span><br><span class="line">            System.out.println(<span class="string">&quot;task canceled&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们拥有了在我们的应用程序中实现基本功能所需的所有知识。我们可以检查我们的待办事项列表，我们可以添加新的待办事项，我们也可以改变它们的状态。</p><p>让我们来看看我们应用程序的安全方面。</p><h2 id="3-OkHttp中的安全和授权"><a href="#3-OkHttp中的安全和授权" class="headerlink" title="3.OkHttp中的安全和授权"></a>3.OkHttp中的安全和授权</h2><h3 id="在一个请求上设置一个HTTP头"><a href="#在一个请求上设置一个HTTP头" class="headerlink" title="在一个请求上设置一个HTTP头"></a>在一个请求上设置一个HTTP头</h3><p>我们的后端已经实现了一个基本的基于用户名&#x2F;密码的认证，以避免看到和修改对方的待办事项。</p><p>现在访问我们的数据需要在我们的请求上设置一个<code>Authorization</code> 头。没有这个，请求可能会以<code>401 Unauthorized</code> 响应而失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://mytodoserver.com/todolist&quot;</span>)</span><br><span class="line">        .addHeader(<span class="string">&quot;Authorization&quot;</span>, Credentials.basic(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Request.Builder</code> 上的<code>addHeader()</code> 方法将让我们指定任意多的自定义<a href="https://link.juejin.cn/?target=https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">头信息</a>。</p><p>现在，只有当有人知道我们的用户名和密码时，我们的敏感数据才能被访问。但是，如果有人在网络上监听，并试图用中间人攻击和伪造的证书劫持我们的请求怎么办？</p><p>OkHttp为你提供了一个简单的方法，通过使用证书平移器只信任你自己的证书。</p><h3 id="在OkHttp中设置证书平移器"><a href="#在OkHttp中设置证书平移器" class="headerlink" title="在OkHttp中设置证书平移器"></a>在OkHttp中设置证书平移器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient.<span class="type">Builder</span> <span class="variable">clientBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder();</span><br><span class="line">clientBuilder.certificatePinner(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CertificatePinner</span>.Builder().add(</span><br><span class="line">                <span class="string">&quot;mytodoserver.com&quot;</span>,<span class="string">&quot;sha256/public_key_hash_of_my_certification&quot;</span></span><br><span class="line">        ).build()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> clientBuilder.build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里，我们使用<code>OkHttpClient.Builder</code> 来建立一个自定义的OkHttp客户端（后面会有更多的介绍）。然后，通过<code>CertificatePinner</code> ，我们选择哪些特定域名的证书被信任。</p><p>关于<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/">证书锁定</a>和一般安全的更多信息，请访问<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/https/">相关的OkHttp文档页面</a>。</p><h2 id="4-用OkHttp进行调试"><a href="#4-用OkHttp进行调试" class="headerlink" title="4.用OkHttp进行调试"></a>4.用OkHttp进行调试</h2><p>如果在发出请求时发生了问题，我们必须深入挖掘它发生的原因。OkHttp有自己的<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/debug_logging/">内部API来启用调试日志</a>，这可以帮助我们。但是我们也可以利用OkHttp的<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/interceptors/">拦截器</a>API来使我们的生活更轻松。</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器可以监控、重写和重试调用。我们可以利用它们在请求发出之前对其进行修改，在响应到达我们的逻辑之前对其进行预处理，或者简单地打印出一些关于请求的细节。</p><p>OkHttp有自己的预制日志拦截器，我们可以通过Gradle导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.squareup.okhttp3:logging-interceptor:4.9.1&quot;</span>)</span><br></pre></td></tr></table></figure><p>并使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpLoggingInterceptor</span> <span class="variable">loggingInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpLoggingInterceptor</span>();</span><br><span class="line">loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);</span><br><span class="line"></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .addInterceptor(loggingInterceptor)</span><br><span class="line">        .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者我们可以实现我们自己的自定义拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BasicLoggingInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Sending request %s on %s%n%s&quot;</span>,</span><br><span class="line">                request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(request);</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Received response for %s %n%s&quot;</span>,</span><br><span class="line">                response.request().url(), response.headers()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// usage later on</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .addInterceptor(<span class="keyword">new</span> <span class="title class_">BasicLoggingInterceptor</span>())</span><br><span class="line">        .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们也可以根据我们的需要，在应用和网络层面上声明我们的拦截器。你可以<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/interceptors/%23choosing-between-application-and-network-interceptors">在这里</a>阅读更多关于这方面的内容。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>有时候，操作我们后端API的响应是很有用的。我们可以通过操作服务器端的代码来实现这个目的，但是通过代理服务器会更有效率。</p><p>我们可以在设备本身使用一个系统范围内的代理配置，或者指示我们的OkHttp客户端在内部使用一个代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Proxy</span> <span class="variable">proxyServerOnLocalNetwork</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">        Proxy.Type.HTTP,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.1.100&quot;</span>, <span class="number">8080</span>) <span class="comment">// the local proxy</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .proxy(proxyServerOnLocalNetwork)</span><br><span class="line">        .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-OkHttp中的缓存"><a href="#5-OkHttp中的缓存" class="headerlink" title="5.OkHttp中的缓存"></a>5.OkHttp中的缓存</h2><p>在我们调试了我们的应用程序之后，你可能已经注意到，我们完成了很多不必要的请求，给我们的服务器带来了额外的负载。如果后台没有变化，就没有必要再去获取待办事项列表。</p><p>在OkHttp中有一个<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/caching/">默认的缓存实现</a>，我们只需要指定缓存位置和它的大小，像这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">      .cache(<span class="keyword">new</span> <span class="title class_">Cache</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/local/cacheDirectory&quot;</span>), <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>)) <span class="comment">//10 MB</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但如果你想<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache/">自定义行为</a>，你可以对它进行疯狂的操作。</p><p>如果你有自定义的缓存逻辑，你也可以实现你自己的缓存方式。例如，你可以先向你的服务器执行一个<code>HEAD</code> 请求，然后检查缓存指示头，如果有变化，就向同一个URL执行一个<code>GET</code> 请求来获取内容。</p><h2 id="6-OkHttp配置"><a href="#6-OkHttp配置" class="headerlink" title="6.OkHttp配置"></a>6.OkHttp配置</h2><p>我们已经介绍了<code>OkHttpClient.Builder</code> 的一些用法。如果我们想改变默认的OkHttp客户端行为，这个类是很有用的。</p><p>有一些参数值得一提。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .cache(cache) <span class="comment">// configure cache, see above</span></span><br><span class="line">        .proxy(proxy) <span class="comment">// configure proxy, see above</span></span><br><span class="line">        .certificatePinner(certificatePinner) <span class="comment">// certificate pinning, see above</span></span><br><span class="line">        .addInterceptor(interceptor) <span class="comment">// app level interceptor, see above</span></span><br><span class="line">        .addNetworkInterceptor(interceptor) <span class="comment">// network level interceptor, see above</span></span><br><span class="line">        .authenticator(authenticator) <span class="comment">// authenticator for requests (it supports similar use-cases as &quot;Authorization header&quot; earlier</span></span><br><span class="line">        .callTimeout(<span class="number">10000</span>) <span class="comment">// default timeout for complete calls</span></span><br><span class="line">        .readTimeout(<span class="number">10000</span>) <span class="comment">// default read timeout for new connections</span></span><br><span class="line">        .writeTimeout(<span class="number">10000</span>) <span class="comment">// default write timeout for new connections</span></span><br><span class="line">        .dns(dns) <span class="comment">// DNS service used to lookup IP addresses for hostnames</span></span><br><span class="line">        .followRedirects(<span class="literal">true</span>) <span class="comment">// follow requests redirects</span></span><br><span class="line">        .followSslRedirects(<span class="literal">true</span>) <span class="comment">// follow HTTP tp HTTPS redirects</span></span><br><span class="line">        .connectionPool(connectionPool) <span class="comment">// connection pool used to recycle HTTP and HTTPS connections</span></span><br><span class="line">        .retryOnConnectionFailure(<span class="literal">true</span>) <span class="comment">// retry or not when a connectivity problem is encountered</span></span><br><span class="line">        .cookieJar(cookieJar) <span class="comment">// cookie manager</span></span><br><span class="line">        .dispatcher(dispatcher) <span class="comment">// dispatcher used to set policy and execute asynchronous requests</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .retryOnConnectionFailure(<span class="literal">true</span>)</span><br><span class="line">                .connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS) <span class="comment">//连接超时</span></span><br><span class="line">                .readTimeout(READ_TIMEOUT, TimeUnit.SECONDS) <span class="comment">//读取超时</span></span><br><span class="line">                .writeTimeout(WRITE_TIMEOUT, TimeUnit.SECONDS) <span class="comment">//写超时</span></span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> <span class="title class_">CommonHeaderInterceptor</span>())</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>())</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> <span class="title class_">HttpLoggerInterceptor</span>())</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> <span class="title class_">EncryptInterceptor</span>())</span><br><span class="line">                .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整的列表，请访问<a href="https://link.juejin.cn/?target=https://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/-builder/">文档</a>。</p><h2 id="7-WebSocket"><a href="#7-WebSocket" class="headerlink" title="7.WebSocket"></a>7.WebSocket</h2><p>想到了一个合作的待办事项列表？或者一旦有新的待办事项加入就通知用户？在一个待办事项上进行实时聊天如何？OkHttp在这里也为你提供了帮助。</p><p>如果你已经完成了WebSocket服务器端的实现，你可以连接到该端点，并从OkHttp客户端获得实时信息传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">socketServerUrl</span> <span class="operator">=</span> <span class="string">&quot;ws://mytodoserver.com/realtime&quot;</span>;</span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(socketServerUrl).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// connecting to a socket and receiving messages</span></span><br><span class="line">client.newWebSocket(request, <span class="keyword">new</span> <span class="title class_">WebSocketListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosed</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="type">int</span> code, <span class="meta">@NotNull</span> String reason)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onClosed(webSocket, code, reason);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> implement your own event handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosing</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="type">int</span> code, <span class="meta">@NotNull</span> String reason)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onClosing(webSocket, code, reason);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> implement your own event handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> Throwable t, <span class="meta">@Nullable</span> Response response)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onFailure(webSocket, t, response);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> implement your own event handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> String text)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onMessage(webSocket, text);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> implement your own event handling for incoming messages</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> ByteString bytes)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onMessage(webSocket, bytes);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> implement your own event handling for incoming messages</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(<span class="meta">@NotNull</span> WebSocket webSocket, <span class="meta">@NotNull</span> Response response)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onOpen(webSocket, response);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> implement your own event handling</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sending message</span></span><br><span class="line">webSocket.send(<span class="string">&quot;new_todo_added&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> RestTemplate </tag>
            
            <tag> OkHttp </tag>
            
            <tag> IO流 </tag>
            
            <tag> Spring Retry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven镜像仓库配置</title>
      <link href="/2022/06/22/41.maven%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/06/22/41.maven%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="maven相关知识"><a href="#maven相关知识" class="headerlink" title="maven相关知识"></a>maven相关知识</h1><h2 id="1-scope依赖范围"><a href="#1-scope依赖范围" class="headerlink" title="1. scope依赖范围"></a>1. scope依赖范围</h2><table><thead><tr><th align="left">scope取值</th><th align="left">有效范围（compile, runtime, test）</th><th align="left">依赖传递</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left"><strong>compile</strong></td><td align="left">all</td><td align="left">是</td><td align="left">spring-core</td></tr><tr><td align="left"><strong>provided</strong></td><td align="left">compile, test</td><td align="left"><strong>否</strong></td><td align="left">servlet-api</td></tr><tr><td align="left"><strong>runtime</strong></td><td align="left">runtime, test</td><td align="left">是</td><td align="left">JDBC驱动</td></tr><tr><td align="left"><strong>test</strong></td><td align="left">test</td><td align="left"><strong>否</strong></td><td align="left">JUnit</td></tr><tr><td align="left"><strong>system</strong></td><td align="left">compile, test</td><td align="left">是</td><td align="left"></td></tr></tbody></table><p>正如上表所示，</p><p><strong>compile</strong> ：为<strong>默认的</strong>依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。</p><p><strong>provided</strong> ：在编译、测试时有效，但是在运行时无效。</p><p>provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。</p><p>事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。</p><p>例如：servlet-api，运行项目时，容器已经提供，就不需要Maven重复地引入一遍了。</p><p><strong>runtime</strong> ：在运行、测试时有效，但是在编译代码时无效。</p><p>说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。</p><p>例如：JDBC驱动实现，项目代码编译只需要JDK提供的JDBC接口，只有在测试或运行项目时才需要实现上述接口的具体JDBC驱动。</p><p>另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。</p><p><strong>test</strong> ：只在测试时有效，包括测试代码的编译，执行。例如：JUnit。</p><p>PS: test表示只能在src下的test文件夹下面才可以使用，你如果在a项目中引入了这个依赖，在b项目引入了a项目作为依赖，在b项目中这个注解不会生效，因为scope为test时无法传递依赖。</p><p><strong>system</strong> ：在编译、测试时有效，但是在<strong>运行时无效</strong>。</p><p>和provided的区别是，使用system范围的依赖时必须通过<strong>systemPath元素显式地指定依赖文件的路径</strong>。由于此类依赖<strong>不是通过Maven仓库解析的，而且往往与本机系统绑定</strong>，可能造成构建的不可移植，因此应该谨慎使用。</p><p>systemPath元素可以引用环境变量。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>scope的依赖传递</p><p>A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？</p><p>答案是：</p><p>当C是test或者provided时，C直接被丢弃，A不依赖C； 否则A依赖C，C的scope继承于B的scope。</p><h2 id="2-两者效果一样"><a href="#2-两者效果一样" class="headerlink" title="2. 两者效果一样"></a>2. 两者效果一样</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot的依赖配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-lt-relativePath-gt-标签"><a href="#3-lt-relativePath-gt-标签" class="headerlink" title="3. &lt;relativePath&gt;标签"></a>3. <code>&lt;relativePath&gt;</code>标签</h2><p><code>&lt;parent&gt;下面的&lt;relativePath&gt;属性是什么意思</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.itxw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是parent的路径，具体来说就是你引用这个parent项目，那parent项目的pom在哪里？</p><ol><li><p>默认值：<strong>默认我们不用写<code>&lt;relativePath&gt;</code>，那默认值就是 ..&#x2F;pom.xml</strong>，会从本地路径中获取parent的pom，我们建多模块的项目就是这个情况</p></li><li><p><code>&lt;relativePath/&gt;</code>：这样写，也就是说我指定了relativePath，但值是空的，设定一个空值将始终从仓库中获取，不从本地路径获取，很常见的场景就是使用springboot的时候</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-常用的镜像地址"><a href="#4-常用的镜像地址" class="headerlink" title="4. 常用的镜像地址"></a>4. 常用的镜像地址</h2><p>阿里云仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>华为云</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">id</span>&gt;</span>huaweicloud<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>华为云 maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://mirrors.huaweicloud.com/repository/maven/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>腾讯云</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-tencentyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus tencentyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mirrors.cloud.tencent.com/nexus/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统任务栏图标变成白色如何恢复</title>
      <link href="/2022/06/14/27.Windows%E7%B3%BB%E7%BB%9F%E5%9B%BE%E6%A0%87%E5%8F%98%E7%99%BD%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
      <url>/2022/06/14/27.Windows%E7%B3%BB%E7%BB%9F%E5%9B%BE%E6%A0%87%E5%8F%98%E7%99%BD%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Windows系统 的桌面图标或者任务栏的图标会变成白色的文件，无法判断是什么软件了，找了个方法记录下</p></blockquote><ol><li><p>首先，随便打开一个文件夹点击【查看】菜单，然后勾选【隐藏的项目】；</p></li><li><p>同时按下快捷键【Win】+【R】，在打开的【运行】窗口中输入%localappdata%；</p></li><li><p>在打开的文件夹中，找到【Iconcache.db】，将其删除；</p></li><li><p>在任务栏上右击鼠标，在弹出的菜单中点击【任务管理器】；</p></li><li><p>在任务管理器中找到【Windows资源管理器】，右击鼠标，选择【重新启动】即可重建图标缓存。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>释放下牢骚而已，正经人谁写日记啊</title>
      <link href="/2022/06/12/%E4%B8%AA%E4%BA%BA%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2022/06/12/%E4%B8%AA%E4%BA%BA%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最理想的生活状态其实是这样：在大城市奋斗，在小城市生活。奋斗不要奋斗到老眼昏花，要懂得适可而止，地位、金钱和欲望是永远没有尽头的，而生活却要在合适的时候及时全心去体会，因为生命只有一次，不要浪费了。</p><p>Never expect. Never assume. And never demand. Just let it be. If it’s meant to be, it will happen.</p></blockquote><ul><li><p>2022&#x2F;09&#x2F;19</p><ul><li>脸皮的厚度与心情成正比。</li></ul></li><li><p>2022&#x2F;09&#x2F;14</p><ul><li>为啥情歌那么多，缺啥唱啥。</li></ul></li><li><p>2022&#x2F;09&#x2F;08</p><ul><li>人很难去定义自己，所以标榜这个词让我觉得挺恶心的。希望是因为喜欢而去成为自己。</li><li>很喜欢一句话：做什么都是因为喜欢。</li></ul></li><li><p>2022&#x2F;09&#x2F;03</p><ul><li>总有些事情过时不候，好好生活，努力赚钱。</li></ul></li><li><p>2020&#x2F;09&#x2F;01</p><ul><li>不会摸鱼的人怕是要猝死在职场。</li></ul></li><li><p>2022&#x2F;07&#x2F;05</p><ul><li>脑子不能空着，装点屎也可以。</li></ul></li><li><p>2022&#x2F;07&#x2F;03</p><ul><li>以前不知道酒那么难喝为什么还有人喜欢喝，烟那么难闻为什么还有那么多人喜欢抽，可能只是年纪没到吧，虽然现在也喝酒也抽烟，但是实际并不是喜欢，是无聊。</li><li>以前买过kindle，尝试去看书，买了卖，卖了买，直到最近才懂得为什么书籍是人类进步的阶梯，文字的表达，传播，信息，远胜音频，图像。</li><li>时常回味初中时期看小说能在脑海中构建一副画像的感觉，现在不太能了，可能和书的复杂程度以及文笔有关。</li><li>真的很反感智能推送，前段时间把知乎卸载了； 哈哈哈9月份我又下载下来了。</li></ul></li><li><p>2022&#x2F;07&#x2F;01</p><ul><li>遇事先规划，再行动，像无头苍蝇一样真的很搞笑。</li></ul></li><li><p>2022&#x2F;06&#x2F;30</p><ul><li>勿忘初心：2018-2020。</li></ul></li><li><p>2022&#x2F;06&#x2F;25</p><ul><li>快乐是比较出来的。</li></ul></li><li><p>2022&#x2F;06&#x2F;18 </p><ul><li><p>我对生活的态度是悲观的。</p></li><li><p>从我这20多年的学习经历回想，我觉得学习的流程有问题，先概念，后实操，由于不太聪明，就导致学概念靠死记硬背，而且还记不住，然后勉强学会实操，等我实操大体掌握才能回过头来理解当初的概念；所以为什么不先实操，然后再定义概念？或许就是要的这种效果吧，也许是我不太聪明吧。</p></li><li><p>想到一个词：猪脑过载，哈哈哈哈哈哈。</p></li></ul></li><li><p>2022&#x2F;06&#x2F;16</p><ul><li><p>有的人前30年一直都在补全自己。</p></li><li><p>社会教会了我很多：待人友善；装腔作势；苦劳不重要；结果比过程重要；会哭的孩子有奶吃；有个榜样很重要；别怕丢脸；利益是自己爭取的；可以说谎但不要太多。</p></li><li><p>睡好觉很重要，特别是年纪大了，要睡8个小时至少。</p></li><li><p>Fake it until you make it。</p></li><li><p>人就像老旧软件系统一样，偶尔打个补丁就行，想大改是不可能的了。</p></li><li><p>少些宏伟的叙事，更多的精力放在自身上。</p></li></ul></li><li><p>2022&#x2F;06&#x2F;12 </p><ul><li><p>一直不太懂追星的行为逻辑，如果一个明星的业务能力强，那就追作品就好了，不太懂为什么会变成崇拜。</p></li><li><p>如果把自己的视角放到与自己无关的一个人或者动物身上，看待生活的种种，会有不同的感觉。</p></li><li><p>你不关心路上的行人，他们也不在意你。</p></li></ul></li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 6.生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis中XML转义字符</title>
      <link href="/2022/06/11/26.XML%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/2022/06/11/26.XML%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们需要通过xml格式处理sql语句时，经常会用到&lt; ，&lt;&#x3D;，&gt;，&gt;&#x3D;等符号，<strong>严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的</strong>，但是很容易引起xml格式的错误，这样会导致后台将xml字符串转换为xml文档时报错，从而导致程序错误。</p></blockquote><p>这样的问题在MyBatis中或者自定义的xml处理sql的程序中遇到，可以使用以下2种方式处理：</p><p><strong>方法一：</strong></p><table><thead><tr><th>原符号</th><th>&lt;</th><th>&lt;&#x3D;</th><th>&gt;</th><th>&gt;&#x3D;</th><th>&amp;</th><th>‘</th><th>“</th></tr></thead><tbody><tr><td>替换符号</td><td><code>&amp;lt;</code></td><td><code>&amp;lt;=</code></td><td><code>&amp;gt;</code></td><td><code>&amp;gt;=</code></td><td><code>&amp;amp;</code></td><td><code>&amp;apos;</code></td><td><code>&amp;quot;</code></td></tr></tbody></table><p><strong>方法二：</strong> </p><p>使用<code>&lt;![CDATA[]]&gt;</code>处理，举栗子<code>&gt;=</code>可以写成<code>&lt;![CDATA[</code>&gt;&#x3D;<code>]]&gt;</code>，其他的可同样处理。</p><br>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础命令</title>
      <link href="/2022/06/11/25.mysql%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/11/25.mysql%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li><p>SQL：Structure Query Language结构化查询语言</p></li><li><p>DDL:数据定义语言，定义数据库、数据表它们的结构：create(创建) drop(删除) alter(修改)</p></li><li><p>DML:数据操作语言，主要是用来操作数据insert(插入) update(修改) delete(删除)</p></li><li><p>DCL:数据控制语言，定义访问权限，取消访问权限，安全设置grant</p></li><li><p>DQL:数据查询语言，select(查询) from字句 where字句</p></li></ul><h2 id="1-操作数据库"><a href="#1-操作数据库" class="headerlink" title="1. 操作数据库"></a>1. 操作数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.首先要登陆数据库服务器</span></span><br><span class="line">    mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br><span class="line"><span class="comment">--2.数据库的创建 : </span></span><br><span class="line">    <span class="keyword">create</span> database 数据库的名 <span class="type">character</span> <span class="keyword">set</span> 字符集  <span class="keyword">collate</span> 校对规则</span><br><span class="line">    <span class="keyword">create</span> database demodb <span class="type">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_bin;</span><br><span class="line">    <span class="comment">--创建数据库，判断不存在，再创建：</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名称;</span><br><span class="line"><span class="comment">--创建数据库，并指定字符集</span></span><br><span class="line"><span class="keyword">create</span> database 数据库名称 <span class="type">character</span> <span class="keyword">set</span> 字符集名;</span><br><span class="line"><span class="comment">--3.数据库的查询:  </span></span><br><span class="line">    <span class="keyword">show</span> databases;</span><br><span class="line">    <span class="keyword">select</span> database();    <span class="operator">/</span><span class="operator">/</span>正在使用的</span><br><span class="line">    <span class="keyword">show</span> <span class="keyword">create</span> database 数据库的名字;</span><br><span class="line"><span class="comment">--4.数据库的修改: </span></span><br><span class="line">    <span class="keyword">alter</span> database 数据库 <span class="type">character</span> <span class="keyword">set</span> 字符集(utf8);</span><br><span class="line"><span class="comment">--5.数据库的删除: </span></span><br><span class="line">    <span class="keyword">drop</span> database if <span class="keyword">exists</span> 数据库名</span><br><span class="line"><span class="comment">--6.切换数据库 :</span></span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line">    use 数据库的名字;</span><br></pre></td></tr></table></figure><h2 id="2-操作表"><a href="#2-操作表" class="headerlink" title="2. 操作表"></a>2. 操作表</h2><h3 id="（1）创建表"><a href="#（1）创建表" class="headerlink" title="（1）创建表"></a>（1）创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名（</span><br><span class="line">    列名 列的类型(长度) 约束，</span><br><span class="line">    sid <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,  </span><br><span class="line">    sname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    sex <span class="type">int</span>,</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">）;</span><br><span class="line"></span><br><span class="line"><span class="comment">--列的类型：</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">    <span class="type">char</span>（固定长度）<span class="operator">/</span><span class="type">varchar</span>（可变长度），长度代表的是字符的个数</span><br><span class="line">    <span class="keyword">double</span></span><br><span class="line">    <span class="type">date</span>:YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD</span><br><span class="line">    <span class="type">time</span>:hh:mm:ss    默认值是<span class="keyword">null</span></span><br><span class="line">    <span class="type">timestamp</span>:YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD hh:mm:ss默认使用当前时间   </span><br><span class="line">    text:主要是存放文本</span><br><span class="line">    <span class="type">blob</span>:存放的是二进制</span><br><span class="line">                </span><br><span class="line"><span class="comment">--列的约束：</span></span><br><span class="line">    主键约束：<span class="keyword">primary</span> key</span><br><span class="line">    唯一约束：<span class="keyword">unique</span></span><br><span class="line">    非空约束：<span class="keyword">not</span> <span class="keyword">null</span>  </span><br><span class="line">    自动增长: auto_increment</span><br></pre></td></tr></table></figure><h3 id="（2）查看表"><a href="#（2）查看表" class="headerlink" title="（2）查看表"></a>（2）查看表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看所有的表</span></span><br><span class="line">    <span class="keyword">show</span> tables;</span><br><span class="line"><span class="comment">--查看表的定义</span></span><br><span class="line">    <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="comment">--查看表结构</span></span><br><span class="line">    <span class="keyword">desc</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="（3）修改表"><a href="#（3）修改表" class="headerlink" title="（3）修改表"></a>（3）修改表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--修改表名和字符集</span></span><br><span class="line">    rename <span class="keyword">table</span> 旧表名 <span class="keyword">to</span> 新表名;</span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="type">character</span> <span class="keyword">set</span> gbk;</span><br><span class="line"><span class="comment">--修改列</span></span><br><span class="line">    添加列: <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 列的类型 列的约束(<span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line">    删除列: <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> chengji;</span><br><span class="line">    改类型: <span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 新的类型 新的约束(<span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line">    改列名: <span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 旧列名 新列名 <span class="type">varchar</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="（4）删除表"><a href="#（4）删除表" class="headerlink" title="（4）删除表"></a>（4）删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span>  if <span class="keyword">exists</span> 表名 ;</span><br></pre></td></tr></table></figure><h2 id="3-操作数据"><a href="#3-操作数据" class="headerlink" title="3. 操作数据"></a>3. 操作数据</h2><h3 id="（1）增删改数据"><a href="#（1）增删改数据" class="headerlink" title="（1）增删改数据"></a>（1）增删改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.插入数据</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>),(值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>); <span class="operator">/</span><span class="operator">/</span>全插入时列名可以省略</span><br><span class="line">    <span class="comment">--中文乱码问题</span></span><br><span class="line">        暂停mysql服务,在mysql安装路径中找到my.ini配置文件，将<span class="number">57</span>行改成gbk，重启mysql.</span><br><span class="line"><span class="comment">--2.删除记录</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> demodb <span class="keyword">where</span> sid <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="comment">--delete和truncate 删除数据有什么差别</span></span><br><span class="line">        <span class="keyword">delete</span>: DML一条一条删除表中的数据，适合数据少，高效</span><br><span class="line">        <span class="keyword">truncate</span>:DDL 先删除表再重建表，适合数据比较多</span><br><span class="line"><span class="comment">--查看表中的数据</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> allidea;</span><br><span class="line"><span class="comment">--3.更新表记录</span></span><br><span class="line">    <span class="keyword">update</span> 表名 <span class="keyword">set</span> 列名<span class="number">1</span><span class="operator">=</span>列的值<span class="number">1</span>，列名<span class="number">2</span><span class="operator">=</span>列的值<span class="number">2</span> <span class="keyword">where</span> 条件;</span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> sname<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span> <span class="keyword">where</span> sid<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="comment">--4.增加外键 (一般不用)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> product <span class="keyword">add</span> <span class="keyword">foreign</span> key(cno) <span class="keyword">references</span> category(cid);</span><br></pre></td></tr></table></figure><h3 id="（2）单表查询"><a href="#（2）单表查询" class="headerlink" title="（2）单表查询"></a>（2）单表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--商品分类（栏目）</span></span><br><span class="line"><span class="number">1.</span>分类的id  </span><br><span class="line"><span class="number">2.</span>分类名称  </span><br><span class="line"><span class="number">3.</span>分类描述    </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> category(      </span><br><span class="line">    cid <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,      </span><br><span class="line">    cname <span class="type">varchar</span>(<span class="number">12</span>),      </span><br><span class="line">    cdesc <span class="type">varchar</span>(<span class="number">31</span>)</span><br><span class="line">);    </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;手机数码&#x27;</span>,<span class="string">&#x27;中国制造&#x27;</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;皮鞋箱包&#x27;</span>,<span class="string">&#x27;意大利&#x27;</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;服装内衣&#x27;</span>,<span class="string">&#x27;中国制造&#x27;</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> category <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;烟酒食品&#x27;</span>,<span class="string">&#x27;中国制造&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">--所有商品（货品）</span></span><br><span class="line"><span class="number">1.</span>商品ID</span><br><span class="line"><span class="number">2.</span>商品名称</span><br><span class="line"><span class="number">3.</span>商品价格</span><br><span class="line"><span class="number">4.</span>生产日期</span><br><span class="line"><span class="number">5.</span>商品分类ID</span><br><span class="line"></span><br><span class="line"><span class="comment">--商品和商品分类：所属关系</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">    pid <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    pname <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    price <span class="keyword">double</span>,</span><br><span class="line">    pdate <span class="type">timestamp</span>,</span><br><span class="line">    cno <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;小米手机&#x27;</span>,<span class="number">998</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;华为手机&#x27;</span>,<span class="number">2888</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;贵人鸟&#x27;</span>,<span class="number">399</span>,<span class="keyword">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;杰克琼斯&#x27;</span>,<span class="number">500</span>,<span class="keyword">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;海澜之家&#x27;</span>,<span class="number">500</span>,<span class="keyword">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;茅台酒&#x27;</span>,<span class="number">388</span>,<span class="keyword">null</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;西凤酒&#x27;</span>,<span class="number">128</span>,<span class="keyword">null</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;饼干&#x27;</span>,<span class="number">5</span>,<span class="keyword">null</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--运算符</span></span><br><span class="line"><span class="operator">*</span> <span class="operator">&gt;</span> 、<span class="operator">&lt;</span> 、<span class="operator">&lt;=</span> 、<span class="operator">&gt;=</span> 、<span class="operator">=</span> 、<span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="operator">*</span> BETWEEN...AND  </span><br><span class="line"><span class="operator">*</span> <span class="keyword">IN</span>( 集合) </span><br><span class="line"><span class="operator">*</span> <span class="keyword">LIKE</span>：模糊查询</span><br><span class="line"><span class="operator">*</span> 占位符：</span><br><span class="line"><span class="operator">*</span> _:单个任意字符</span><br><span class="line"><span class="operator">*</span> <span class="operator">%</span>：多个任意字符</span><br><span class="line"><span class="operator">*</span> <span class="keyword">IS</span> <span class="keyword">NULL</span>  </span><br><span class="line"><span class="operator">*</span> <span class="keyword">and</span>  或 <span class="operator">&amp;&amp;</span></span><br><span class="line"><span class="operator">*</span> <span class="keyword">or</span>  或 <span class="operator">||</span> </span><br><span class="line"><span class="operator">*</span> <span class="keyword">not</span>  或 <span class="operator">!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询所有的商品</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product;</span><br><span class="line">    </span><br><span class="line"><span class="comment">--查询商品名称和商品价格</span></span><br><span class="line">    <span class="keyword">select</span> pname,price <span class="keyword">from</span> product;</span><br><span class="line">    </span><br><span class="line"><span class="comment">--别名查询. as的关键字，as 关键字是可以省略</span></span><br><span class="line">    <span class="comment">--表别名(主要是用在多表查询);</span></span><br><span class="line">        <span class="keyword">select</span> p.pname,p.price <span class="keyword">from</span> product <span class="keyword">as</span> p;</span><br><span class="line">    <span class="comment">--列别名;</span></span><br><span class="line">        <span class="keyword">select</span> pname 名称,price 价格 <span class="keyword">from</span> product;</span><br><span class="line">        </span><br><span class="line"><span class="comment">--去掉重复的值 distinct</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> price <span class="keyword">from</span> product;</span><br><span class="line">    </span><br><span class="line"><span class="comment">--select运算查询(仅仅在查询结果上做了运算)</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span>,price<span class="operator">*</span><span class="number">0.5</span> 折后价格 <span class="keyword">from</span> product;</span><br><span class="line">    </span><br><span class="line"><span class="comment">--where关键字</span></span><br><span class="line">    <span class="comment">--关系运算符:&gt; &gt;= &lt; &lt;= != &lt;&gt;(标准sql语法)</span></span><br><span class="line">    <span class="comment">--判断某一列是否为空: is null,is not null</span></span><br><span class="line">    <span class="comment">--逻辑运算: and , or , not</span></span><br><span class="line">    <span class="comment">--between ... and ...在某一区间</span></span><br><span class="line">    <span class="comment">--like:模糊查询</span></span><br><span class="line">        _ :代表的是一个字符</span><br><span class="line">        <span class="operator">%</span> :代表的是多个字符</span><br><span class="line">    <span class="comment">--in 在某个范围中获得值     </span></span><br><span class="line">    <span class="comment">--查询商品价格&gt;60的所有商品信息</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--查询商品价格在10到100之间</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">and</span> price <span class="operator">&lt;</span> <span class="number">100</span>;</span><br><span class="line">        between...add...</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="keyword">between</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">--查询商品价格小于 100 或者商品价格大于 999</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">or</span> price <span class="operator">&gt;</span> <span class="number">999</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">--查询出名字中带有 米 的商品</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;%米%&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--查询第二个名字是熊的所有商品</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;_便%&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--查询商品分类ID在1,4,5里面所有的商品</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> cno <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">--排序查询: order by 关键字</span></span><br><span class="line">    <span class="keyword">asc</span> : ascend 升序(默认的排序方式)</span><br><span class="line">    <span class="keyword">desc</span> : descend 降序</span><br><span class="line">    <span class="comment">--1.查询所有商品,按照价格进行排序</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price;</span><br><span class="line">    <span class="comment">--2.查询所有商品,按照价格进行降序</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br><span class="line">    <span class="comment">--3.查询名称有 小 的商品,按照价格降序排序</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;%面%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">--聚合函数: select 函数(列名) from 表名;</span></span><br><span class="line">    <span class="built_in">sum</span>() : 求和</span><br><span class="line">    <span class="built_in">avg</span>() : 求平均值</span><br><span class="line">    <span class="built_in">count</span>() : 统计数量</span><br><span class="line">    <span class="built_in">max</span>() : 最大值</span><br><span class="line">    <span class="built_in">min</span>() : 最小值</span><br><span class="line">    <span class="comment">--1.获得所有商品价格的总和</span></span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">sum</span>(price) <span class="keyword">from</span> product;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">--2.获得所有商品的个数</span></span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">--注意:where条件后面不能接聚合函数</span></span><br><span class="line">    <span class="comment">--查出商品价格 大于 平均价格 的所有商品</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(price) <span class="keyword">from</span> product);</span><br><span class="line"><span class="comment">--分组: group by</span></span><br><span class="line">    <span class="comment">--having 分组之后条件过滤关键字,可以接聚合函数,出现在分组之后</span></span><br><span class="line">    <span class="comment">--1.根据cno字段分组,分组后统计商品的个数</span></span><br><span class="line">        <span class="keyword">select</span> cno,<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">        <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> cno;</span><br><span class="line">    <span class="comment">--2.根据con分组,分组统计每组商品的平均价格,并且商品平均价格 &gt; 60</span></span><br><span class="line">        <span class="keyword">select</span> cno,<span class="built_in">avg</span>(price)</span><br><span class="line">        <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> cno</span><br><span class="line">        <span class="keyword">having</span> <span class="built_in">avg</span>(price) <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">--编写顺序</span></span><br><span class="line">    <span class="keyword">select</span> .. <span class="keyword">from</span> .. <span class="keyword">where</span> .. <span class="keyword">group</span> <span class="keyword">by</span> .. <span class="keyword">having</span> .. <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">--执行顺序</span></span><br><span class="line">    <span class="keyword">from</span> .. <span class="keyword">where</span> .. <span class="keyword">group</span> <span class="keyword">by</span> .. <span class="keyword">having</span> .. <span class="keyword">select</span> .. <span class="keyword">order</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure><h3 id="（3）多表查询"><a href="#（3）多表查询" class="headerlink" title="（3）多表查询"></a>（3）多表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 笛卡尔积,查出来的是两张表的乘积</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product,category;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤出有意义的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product,category <span class="keyword">where</span> cno <span class="operator">=</span> cid;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product p,category c <span class="keyword">where</span> p.cno <span class="operator">=</span> c.cid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内连接查询</span></span><br><span class="line"><span class="comment">-- 隐式内连接: 在查询结果上做的where条件过滤</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product p,category c <span class="keyword">where</span> p.cno <span class="operator">=</span> c.cid;</span><br><span class="line"><span class="comment">-- 显式内连接: 带着条件查结果,执行效率高</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product p <span class="keyword">inner</span> <span class="keyword">join</span> category c <span class="keyword">on</span> p.cno <span class="operator">=</span> c.cid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 左外连接:会将左表中的所有数据都查询出来,如果右表中没有对应的数据,用null代替</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product p <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> category c <span class="keyword">on</span> p.cno <span class="operator">=</span> c.cid;</span><br><span class="line"><span class="comment">-- 右外连接:</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product p <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> category c <span class="keyword">on</span> p.cno <span class="operator">=</span> c.cid;</span><br></pre></td></tr></table></figure><h3 id="（4）分页查询"><a href="#（4）分页查询" class="headerlink" title="（4）分页查询"></a>（4）分页查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 起始索引: startIndex  = (index-1)*3</span></span><br><span class="line"><span class="comment">-- 第一个参数是索引,第二个参数显示的个数</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product limit <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product limit <span class="number">3</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="（5）子查询"><a href="#（5）子查询" class="headerlink" title="（5）子查询"></a>（5）子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询出(商品名称,商品分类名称)信息</span></span><br><span class="line">    <span class="comment">-- 左连接</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product p <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> category c <span class="keyword">on</span> p.cno <span class="operator">=</span> c.cid;</span><br><span class="line"><span class="comment">-- 查询分类名称为手机数码的所有商品</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> cno <span class="operator">=</span> (<span class="keyword">select</span> cid <span class="keyword">from</span> category <span class="keyword">where</span> cname <span class="operator">=</span><span class="string">&#x27;手机数码&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="（6）约束"><a href="#（6）约束" class="headerlink" title="（6）约束"></a>（6）约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">分类：</span><br><span class="line">1. 主键约束：primary key</span><br><span class="line">2. 非空约束：not null</span><br><span class="line">3. 唯一约束：unique</span><br><span class="line">4. 外键约束：foreign key</span><br><span class="line"></span><br><span class="line">* 非空约束：not null，值不能为null</span><br><span class="line">1. 创建表时添加约束</span><br><span class="line">CREATE TABLE stu(</span><br><span class="line">id INT,</span><br><span class="line">NAME VARCHAR(20) NOT NULL -- name为非空</span><br><span class="line">);</span><br><span class="line">2. 创建表完后，添加非空约束</span><br><span class="line">ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</span><br><span class="line"></span><br><span class="line">3. 删除name的非空约束</span><br><span class="line">ALTER TABLE stu MODIFY NAME VARCHAR(20);</span><br><span class="line">* 唯一约束：unique，值不能重复</span><br><span class="line">1. 创建表时，添加唯一约束</span><br><span class="line">CREATE TABLE stu(</span><br><span class="line">    id INT,</span><br><span class="line">    phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束</span><br><span class="line">);</span><br><span class="line">注意mysql中，唯一约束限定的列的值可以有多个null</span><br><span class="line"></span><br><span class="line">2. 删除唯一约束</span><br><span class="line"></span><br><span class="line">ALTER TABLE stu DROP INDEX phone_number;</span><br><span class="line"></span><br><span class="line">3. 在创建表后，添加唯一约束</span><br><span class="line">ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</span><br><span class="line"></span><br><span class="line">* 主键约束：primary key。</span><br><span class="line">1. 注意：</span><br><span class="line">1. 含义：非空且唯一</span><br><span class="line">2. 一张表只能有一个字段为主键</span><br><span class="line">3. 主键就是表中记录的唯一标识</span><br><span class="line"></span><br><span class="line">2. 在创建表时，添加主键约束</span><br><span class="line">create table stu(</span><br><span class="line">id int primary key,-- 给id添加主键约束</span><br><span class="line">name varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">3. 删除主键</span><br><span class="line">-- 错误 alter table stu modify id int ;</span><br><span class="line">ALTER TABLE stu DROP PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">4. 创建完表后，添加主键</span><br><span class="line">ALTER TABLE stu MODIFY id INT PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">5. 自动增长：</span><br><span class="line">1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</span><br><span class="line"></span><br><span class="line">2. 在创建表时，添加主键约束，并且完成主键自增长</span><br><span class="line">create table stu(</span><br><span class="line">id int primary key auto_increment,-- 给id添加主键约束</span><br><span class="line">name varchar(20)</span><br><span class="line">);</span><br><span class="line">3. 删除自动增长</span><br><span class="line">ALTER TABLE stu MODIFY id INT;</span><br><span class="line">4. 添加自动增长</span><br><span class="line">ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line">* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。</span><br><span class="line">1. 在创建表时，可以添加外键</span><br><span class="line">* 语法：</span><br><span class="line">create table 表名(</span><br><span class="line">....</span><br><span class="line">外键列</span><br><span class="line">constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">2. 删除外键</span><br><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br><span class="line"></span><br><span class="line">3. 创建表之后，添加外键</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</span><br></pre></td></tr></table></figure><h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 事务的四大特征：</span><br><span class="line">1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</span><br><span class="line">2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。</span><br><span class="line">3. 隔离性：多个事务之间。相互独立。</span><br><span class="line">4. 一致性：事务操作前后，数据总量不变</span><br><span class="line">2. 事务的隔离级别（了解）</span><br><span class="line">* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</span><br><span class="line">* 存在问题：</span><br><span class="line">1. 脏读：一个事务，读取到另一个事务中没有提交的数据</span><br><span class="line">2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。</span><br><span class="line">3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</span><br><span class="line">* 隔离级别：</span><br><span class="line">1. read uncommitted：读未提交</span><br><span class="line">* 产生的问题：脏读、不可重复读、幻读</span><br><span class="line">2. read committed：读已提交 （Oracle）</span><br><span class="line">* 产生的问题：不可重复读、幻读</span><br><span class="line">3. repeatable read：可重复读 （MySQL默认）</span><br><span class="line">* 产生的问题：幻读</span><br><span class="line">4. serializable：串行化</span><br><span class="line">* 可以解决所有的问题</span><br><span class="line"></span><br><span class="line">* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低</span><br><span class="line">* 数据库查询隔离级别：</span><br><span class="line">* select @@tx_isolation;</span><br><span class="line">* 数据库设置隔离级别：</span><br><span class="line">* set global transaction isolation level  级别字符串;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware中给CentOS磁盘扩容</title>
      <link href="/2022/06/11/24.VMware%E4%B8%AD%E7%BB%99CentOS%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
      <url>/2022/06/11/24.VMware%E4%B8%AD%E7%BB%99CentOS%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>当VMware中的CentOS磁盘空间不足时就需要进行磁盘扩容，具体步骤如下：</p><h2 id="步骤一：虚拟机扩展磁盘容量"><a href="#步骤一：虚拟机扩展磁盘容量" class="headerlink" title="步骤一：虚拟机扩展磁盘容量"></a>步骤一：虚拟机扩展磁盘容量</h2><p>1、首先，打开已经安装好的虚拟机，选择需要扩展磁盘的虚拟机，点击设备中的“硬盘”。如图：</p><p> 2、接着，进入虚拟机设置界面，在界面的右侧选择“扩展”。如图：</p><p> 3、接着，在弹出的扩展磁盘容量中，输入需要扩展磁盘的大小，完成后点击“确定”。如图：</p><p> 4、接着，等待系统自动扩展完成，在弹出的对话框中选择“确定”，这样虚拟机的磁盘就扩展完成了。</p><p> 5、接着，回到虚拟机设置界面，点击下方的“确定”保存刚设置的参数。如图：</p><p> 这样，虚拟机扩展磁盘容量就完成了，接下来进入centos扩展磁盘容量。</p><h2 id="步骤二：在centos-7-系统中挂载磁盘"><a href="#步骤二：在centos-7-系统中挂载磁盘" class="headerlink" title="步骤二：在centos 7 系统中挂载磁盘"></a>步骤二：在centos 7 系统中挂载磁盘</h2><p>1、首先，开机启动虚拟机，进入centos 7系统中，打开终端，在终端界面中输入“# df -h”命令，并回车，在终端界面中可以看到原本30G的磁盘，并未扩容。如图：</p><p> 2、接着，在终端界面中输入“# fdisk -l”命令，查看新磁盘的分区信息。如图：</p><p> 3、接着，在终端界面中输入“# fdisk &#x2F;dev&#x2F;sda”命令，对新加的磁盘进行分区操作（选择新增的磁盘），并回车。如图：</p><p> 4、接着，在终端命令中，输入“p”命令，回车，查看已分区的数量。如图：</p><p> 5、接着，在终端命令中，输入“n”命令，回车，新增一个分区。如图：</p><p> 6、接着，在终端命令窗口中输入“p”命令,回车，在打开的分区号命中使用默认的分区号，并回车。如图：</p><p> 7、接着，在显示的起始扇区直接敲回车键，在弹出的Last后面中，直接敲回车键即可进入下一步（在如图画框位置直接使用回车即可进入下一步）。如图：</p><p> 8、接着，继续在终端命令窗口中输入“p”回车，查看当前分区的信息，在显示的信息中就可以看到已经多了一个新的分区了，大小就是刚设置的大小。如图：</p><p> 9、接着，在终端命令中输入“w”命令，回车，写入磁盘信息并保存。如图：</p><p> 10、接着，在终端命令窗口中，输入“# reboot”回车，重启虚拟机格式化新建分区。如图：</p><p> 11、接着，等待系统自动重启完成后，打开终端命令，在命令窗口中输入“# vgdisplay”，查看磁盘卷组名。如图：</p><p> 12、接着，在终端命令窗口中输入“# pvcreate &#x2F;dev&#x2F;sda3”命令并回车，初始化刚建立的分区。如图：</p><p> 13、接着，在终端命令窗口中输入“# vgextend centos &#x2F;dev&#x2F;sda3”命令并回车，把刚初始化的分区加入到虚拟卷组名中（命令：# vgextend 虚拟卷组名 新增的分区）。如图：</p><p> 14、接着，继续在终端命令窗口中输入“# vgdisplay”命令，查看卷组的详细信息，在详细信息中可以看到刚增加的10G空间还是处于空闲的状态。如图：</p><p> 15、接着，继续在终端命令窗口中输入“# df -h”命令并回车，查看并记下需要扩展的文件系统名（查看到的系统名是：&#x2F;dev&#x2F;mapper&#x2F;centos-root，不同版本查看到的应该有所区别，大家应该注意区分）。如图：</p><p> 16、接着，继续在终端命令窗口中输入“# lvextend -L +9G &#x2F;dev&#x2F;mapper&#x2F;centos-root”命令并回车，扩容已有的卷组容量（注意：如果您扩容的是10G，这里10G就不能全部扩展，只能扩展比10G小的容量，不然系统会报错导致扩容失败，小编这里只扩容9G。命令：# lvextend -L +需要扩展的容量 需要扩展的文件系统名，<strong>需要注意命令中区分字母的大小写</strong>）。如图：</p><p> 17、接着，继续在终端命令窗口中输入“# pvdisplay”命令并回车，查看当前的卷组，在显示的信息中卷组已经扩容成功了，接下来需要将文件系统也扩容。如图：</p><p>18、接着，继续在终端命令窗口中输入“# cat &#x2F;etc&#x2F;fstab | grep centos-root”命令并回车，查看文件系统的格式。如图：</p><p> 19、接着，在上一步已经看到了文件系统的格式了，就需要使用相应的命令来扩展磁盘空间，在终端命令中输入“# xfs_growfs &#x2F;dev&#x2F;mapper&#x2F;centos-root”命令并回车（命令：# xfs_growfs 文件系统名，不同的文件系统要用不同的命令，不然会导致报错）。如图：</p><p> 20、接着，等待系统自动扩容完成，完成后，在终端命令窗口中输入“# df -h”命令并回车，查看磁盘大小是否扩容成功，在显示的磁盘信息中，可以看到磁盘扩容成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看日志命令</title>
      <link href="/2022/06/11/23.%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/11/23.%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-tail-amp-head"><a href="#1-tail-amp-head" class="headerlink" title="1. tail &amp; head"></a>1. tail &amp; head</h2><ul><li>tail是查看后多少行日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]</span><br></pre></td></tr></table></figure><ul><li>head是查看前多少行日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p>[ -f ]  循环读取</p></li><li><p>[ -q ] 不显示处理信息 </p></li><li><p>[ -v ] 显示详细的处理信息 </p></li><li><p>[ -c 数目]  显示的字节数 </p></li><li><p>[ -n 行数]  显示行数 （相当于nl命令） </p></li><li><p>[ –pid&#x3D;PID ] 与-f合用,表示在进程ID,PID死掉之后结束</p></li><li><p>[ q ] –quiet, –silent 从不输出给出文件名的首部</p></li><li><p>[ -s ]  –sleep-interval&#x3D;S 与-f合用,表示在每次反复的间隔休眠S秒</p></li><li><p>[ -m Number ]  从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定-c参数，可能导致截断，但使用-m则会避免该问题 </p></li><li><p>[ -b Number ]  从 Number 表示的512字节块位置读取指定文件。</p></li><li><p>[ -k Number ]  从 Number 表示的1KB块位置读取指定文件。</p></li></ul><p>上述命令中，都涉及到number，假设不指定，默认显示10行。Number前面可使用正负号，表示该偏移从顶部还是从尾部開始计算。</p><ol><li>循环实时查看最后100行记录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -fn 100 test.log</span><br></pre></td></tr></table></figure><ol start="2"><li><p>查询10行之后的所有日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n +10 test.log</span><br></pre></td></tr></table></figure></li><li><p>查询日志文件中的前10行日志</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 10 test.log</span><br></pre></td></tr></table></figure><ol start="4"><li>查询日志文件除了最后10行的其他所有日志<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n -10 test.log</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-cat"><a href="#2-cat" class="headerlink" title="2. cat"></a>2. cat</h2><p><strong>参数：</strong> </p><ul><li><p>一次显示整个文件。 cat filename</p></li><li><p>创建一个文件。 cat &gt; filename</p></li><li><p>将几个文件合并为一个文件。 cat file1 file2 &gt; file</p></li><li><p>[ -n ] 由1开始对所有输出的行数编号</p></li><li><p>[ -b ]  和-n相似，只不过对于空白行不编号</p></li><li><p>[ -s ] 当遇到有连续两行以上的空白行，就代换为一行的空白行 </p></li><li><p>[ -c&lt;数目&gt; ]  显示的字节数 </p></li><li><p>[ -n&lt;行数&gt; ] 显示行数</p></li></ul><ol><li><p>查询关键字的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n test.log |grep &quot;关键字1&quot;</span><br></pre></td></tr></table></figure></li><li><p>查询两个关键字同时出现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.log | grep &quot;关键字1&quot; | grep &quot;关键字2&quot;</span><br></pre></td></tr></table></figure></li><li><p>从第3000行开始，显示1000行。即显示3000~3999行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename | tail -n  3000 | head -n 1000</span><br></pre></td></tr></table></figure></li><li><p>把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2 </span><br></pre></td></tr></table></figure></li><li><p>显示前后n行日志 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat error.log | grep -C 5 ‘nick’ 显示file文件里匹配foo字串那行以及上下5行</span><br><span class="line">cat error.log | grep -B 5 ‘nick’ 显示foo及前5行</span><br><span class="line">cat error.log | grep -A 5 ‘nick’ 显示foo及后5行</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-grep"><a href="#3-grep" class="headerlink" title="3. grep"></a>3. grep</h2><p>主要参数:  </p><p>－c：只输出匹配行的计数。   </p><p>－I：不区分大 小写(只适用于单字符)。   </p><p>－h：查询多文件时不显示文件名。   </p><p>－l：查询多文件时只输出包含匹配字符的文件名。   </p><p>－n：显示匹配行及 行号。   </p><p>－s：不显示不存在或无匹配文本的错误信息。   </p><p>－v：显示不包含匹配文本的所有行。  </p><p>0、在当前文件夹内查询所有log</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;Message&#x27; *.log</span><br></pre></td></tr></table></figure><p>1、查询最近多少条日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 100 default.log</span><br></pre></td></tr></table></figure><p>2、根据关键字查询日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n default.log |grep &#x27;Message&#x27;</span><br></pre></td></tr></table></figure><p>3、根据关键字查出后多少行的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 100 file.log | grep &quot;关键字&quot;</span><br></pre></td></tr></table></figure><p>4、根据关键字查出后100行中包含关键字的行和该行的后10行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 100 file.log | grep &quot;关键字&quot; -A10      </span><br></pre></td></tr></table></figure><p>5、根据关键字查出后100行中包含关键字的行和该行的前10行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 100 file.log | grep &quot;关键字&quot; -B10   </span><br></pre></td></tr></table></figure><p>6、根据关键字查出后100行中包含关键字的行和该行的前后10行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 100 file.log | grep &quot;关键字&quot; -B10 -A10</span><br></pre></td></tr></table></figure><p>7、根据时间段查询日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/2022-03-18 10:12/,/2022-03-18 12:15/p&#x27;  xxx.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年的计划&amp;总结</title>
      <link href="/2022/06/07/2022%E5%B9%B4%E8%AE%A1%E5%88%92&amp;%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/07/2022%E5%B9%B4%E8%AE%A1%E5%88%92&amp;%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="2022年计划"><a href="#2022年计划" class="headerlink" title="2022年计划"></a>2022年计划</h1><blockquote><p>今天是2022年6月7号，虽然2022年已经过完一半，但还是要做个后续计划（<del>只是今天才决定要做计划总结</del>）</p><p>说到做计划，以前在大学里上那种大课，老师抽人提问各个同学的计划，我大言不惭，说要一年看100本书，哈哈哈哈哈哈，现在想起来，鞋底抠穿，庆幸，当初的自己是纯憨憨，也不会觉得不好意思。</p><p>回想起来，我以前在大学里做了好多现在看起来很憨的事情，无所谓了，反正这些事情也只是残留在我一个人的脑海里。</p></blockquote><ul><li>学习Python，至少得入门吧；</li><li>整理完Java知识结构，查漏补缺；</li><li>考摩托车驾照，C照的实习到期时间是2022年12月31号</li><li>其他的暂时没想到，再补充吧。。。</li></ul><hr><h1 id="2022年总结"><a href="#2022年总结" class="headerlink" title="2022年总结"></a>2022年总结</h1><ul><li>待更。。。</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 1.计划总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划&amp;总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pom中Maven插件的用法</title>
      <link href="/2022/06/07/22.maven%E6%8F%92%E4%BB%B6%E7%94%A8%E6%B3%95/"/>
      <url>/2022/06/07/22.maven%E6%8F%92%E4%BB%B6%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Maven前置知识"><a href="#1-Maven前置知识" class="headerlink" title="1. Maven前置知识"></a>1. Maven前置知识</h2><ul><li>构建Maven项目的时候，如果没有进行特殊的配置，Maven会按照标准的目录结构查找和处理各种类型文件。</li><li><code>src/main/java和src/test/java</code> 这两个目录中的所有*.java文件会分别在comile和test-comiple阶段被编译，编译结果分别放到了target&#x2F;classes和targe&#x2F;test-classes目录中，但是这两个目录中的其他文件都会被忽略掉。</li><li><code>src/main/resouces和src/test/resources</code> 这两个目录中的文件也会分别被复制到target&#x2F;classes和 target&#x2F;test-classes目录中</li><li>打包插件默认会把这个目录<code>target/classes</code>中的所有内容打入到jar包或者war包中。</li></ul><h2 id="2-Maven标准目录结构"><a href="#2-Maven标准目录结构" class="headerlink" title="2. Maven标准目录结构"></a>2. Maven标准目录结构</h2><ul><li>src<ul><li>main<ul><li>java     源文件 </li><li>resources   资源文件</li><li>filters  资源过滤文件</li><li>config  配置文件</li><li>scripts  脚本文件</li><li>webapp  web应用文件</li></ul></li><li>test<ul><li>java   测试源文件</li><li>resources   测试资源文件</li><li>filters   测试资源过滤文件</li></ul></li><li>it    集成测试</li><li>assembly   assembly descriptors</li><li>site   Site</li></ul></li><li>target<ul><li>generated-sources</li><li>classes</li><li>generated-test-sources</li><li>test-classes</li><li>xxx.jar</li></ul></li><li>pom.xml</li><li>LICENSE.txt</li><li>NOTICE.txt</li><li>README.txt</li></ul><h2 id="3-同时打包xml和-java文件"><a href="#3-同时打包xml和-java文件" class="headerlink" title="3. 同时打包xml和.java文件"></a>3. 同时打包xml和.java文件</h2><ul><li>有时候，比如mybatis的mapper.xml文件，如果把它和Mapper.java放一起，都在src&#x2F;main&#x2F;java下面，这样利用maven打包时，就需要修改pom.xml文件，来把mapper.xml文件一起打包进jar或者war里了，否则，这些文件不会被打包的。(maven认为src&#x2F;main&#x2F;java只是java的源代码路径)</li><li>默认情况下，在POM.XML目录下执行: mvn clean package 打包命令在target\classes目录下不会把UserMapper.xml打包到下mapper目录下</li><li>而resources目录下的文件始终都会打包进jar包或war包</li></ul><p><strong>下图不会打包进去：</strong><br><img src="https://img-blog.csdn.net/20180113180018014"></p><h3 id="方式一：配置POM-XML的resource"><a href="#方式一：配置POM-XML的resource" class="headerlink" title="方式一：配置POM.XML的resource"></a>方式一：配置POM.XML的resource</h3><blockquote><p>默认情况下，如果没有指定resources，目前认为自动会将classpath下的src&#x2F;main&#x2F;java下的.class文件和src&#x2F;main&#x2F;resources下的.xml文件放到target里头的classes文件夹下的package下的文件夹里。如果设定了resources，那么默认的就会失效，就会以指定的includes和excludes为准。例如，为了使打包的jar包里头包含.java源文件。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 资源目录 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span> </span><br><span class="line">      <span class="comment">&lt;!-- 设定主资源目录  --&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，只处理如下配置中包含的资源类型 --&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，不处理如下配置中包含的资源类型（剔除下如下配置中包含的资源类型）--&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">excludes</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.yaml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，指定处理后的资源文件输出目录，默认是$&#123;build.outputDirectory&#125;指定的目录--&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!--&lt;targetPath&gt;$&#123;build.outputDirectory&#125;&lt;/targetPath&gt; --&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，是否对主资源目录开启资源过滤 --&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方式二：-maven-resources-plugin"><a href="#方式二：-maven-resources-plugin" class="headerlink" title="方式二： maven-resources-plugin"></a>方式二： maven-resources-plugin</h3><ul><li><p>为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。</p></li><li><p>默认的主资源文件目录是src&#x2F;main&#x2F;resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- maven打包时，有些资源文件被编译后会与原文件不同，导致文件不可用</span></span><br><span class="line"><span class="comment">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span></span><br><span class="line"><span class="comment">        &lt;nonFilteredFileExtensions&gt;</span></span><br><span class="line"><span class="comment">            &lt;!-- 不需要编译的资源文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>pdf<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>swf<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一个execution就是一个目标输入位置，如果想把各种资源拆开放的话，</span></span><br><span class="line"><span class="comment">就可以创建多个execution，一个资源文件可以被拷贝多份 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 需要在其他阶段拷贝资源文件，可以使用插件目标copy-resources --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 资源文件的输出目录 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;basedir&#125;/target/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 资源文件的原始目录，有多个的话就多配几个 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 原始目录 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 是否使用过滤器，如果是的话，需要配置一下才行</span></span><br><span class="line"><span class="comment">                                    这个后续再研究，这边没有使用到 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 包含哪些文件以及去除调哪些文件等等 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.json<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】SpringBoot读取Resource目录下的资源文件</title>
      <link href="/2022/06/05/21.SpringBoot%E8%AF%BB%E5%8F%96Resource%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
      <url>/2022/06/05/21.SpringBoot%E8%AF%BB%E5%8F%96Resource%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用ResourceUtils获取"><a href="#1-使用ResourceUtils获取" class="headerlink" title="1. 使用ResourceUtils获取"></a>1. 使用ResourceUtils获取</h2><blockquote><p>导包：import org.springframework.util.ResourceUtils;</p></blockquote><h3 id="1-1-获取文件绝对路径"><a href="#1-1-获取文件绝对路径" class="headerlink" title="1.1 获取文件绝对路径"></a>1.1 获取文件绝对路径</h3><ul><li>先获取绝对路径地址，然后通过地址生成File文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> ResourceUtils.getURL(ResourceUtils.CLASSPATH_URL_PREFIX+<span class="string">&quot;logback.xml&quot;</span>).getPath();</span><br><span class="line">System.out.println(<span class="string">&quot;文件绝对路径=&quot;</span>+path); <span class="comment">// D:/ideaProject/treasure-chest/wshoto/target/classes/logback.xml</span></span><br><span class="line"></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">inputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br></pre></td></tr></table></figure><h3 id="1-2-直接获取文件"><a href="#1-2-直接获取文件" class="headerlink" title="1.2 直接获取文件"></a>1.2 直接获取文件</h3></li><li>1.1的简略版本，省去了获取绝对路径<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> ResourceUtils.getFile(ResourceUtils.CLASSPATH_URL_PREFIX+<span class="string">&quot;logback.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-类加载器获取"><a href="#2-类加载器获取" class="headerlink" title="2. 类加载器获取"></a>2. 类加载器获取</h2><h3 id="2-1-类加载器种类"><a href="#2-1-类加载器种类" class="headerlink" title="2.1 类加载器种类"></a>2.1 类加载器种类</h3><ol><li><strong>引导类加载器(Bootstrap CLassLoader)</strong><br>它是由本地代码(c&#x2F;c++)实现的，你根本拿不到他的引用，但是他实际存在，并且加载一些重要的类，它加载(%JAVA_HOME%\jre\lib),如rt.jar(runtime)、i18n.jar等，这些是Java的核心类。 他是用原生代码来实现的，并不继承自 java.lang.ClassLoader。</li><li><strong>扩展类加载器(Extension CLassLoader)</strong><br>虽说能拿到，但是我们在实践中很少用到它，它主要加载扩展目录下的jar包， %JAVA_HOME%\lib\ext</li><li><strong>系统类加载器(System CLassLoader)</strong><br>它主要加载我们应用程序中的类，如Test,或者用到的第三方包,如jdbc驱动包等。<br>这里的父类加载器与类中继承概念要区分，它们在class定义上是没有父子关系的。</li></ol><h3 id="2-2-获取类加载器："><a href="#2-2-获取类加载器：" class="headerlink" title="2.2 获取类加载器："></a>2.2 获取类加载器：</h3><ol><li>获取加载当前类的类加载器，可能是”启动类加载器”、“拓展类加载器”、”系统类加载器”等，取决于当前类是由哪个加载器加载的；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前类的加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Test.class.getClassLoader();</span><br></pre></td></tr></table></figure></li><li>获取当前线程上下文的类加载器，用户可以自己设置，java se环境下一般是AppClassLoader、java ee环境下一般是WebappClassLoader<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前线程上下文类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>获取系统类加载器 System CLassLoader<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统类加载器 System CLassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure></li><li>获取当前线程的ClassLoader<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">contextClassLoader1</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-通过类加载器获取资源"><a href="#2-3-通过类加载器获取资源" class="headerlink" title="2.3 通过类加载器获取资源"></a>2.3 通过类加载器获取资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream2</span> <span class="operator">=</span> loader.getResourceAsStream(<span class="string">&quot;logback.xml&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="3-ClassPathResource获取文件-推荐"><a href="#3-ClassPathResource获取文件-推荐" class="headerlink" title="3. ClassPathResource获取文件(推荐)"></a>3. ClassPathResource获取文件(推荐)</h2><ul><li>读取classPaths路径下的文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;logback.xml&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> resource2.getFile();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> CLassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】LocalDateTime相关使用</title>
      <link href="/2022/06/05/20.localDateTime/"/>
      <url>/2022/06/05/20.localDateTime/</url>
      
        <content type="html"><![CDATA[<p>Java处理日期、日历和时间的不足之处：将 java.util.Date 设定为可变类型，以及 SimpleDateFormat 的非线程安全使其应用非常受限。然后就在 java8 上面增加新的特性。</p><p>全新API的众多好处之一就是，明确了日期时间概念，例如：<code>瞬时（instant）</code>、 <code>长短（duration）</code>、<code>日期</code>、<code>时间</code>、<code>时区</code>和<code>周期</code>。</p><p>同时继承了Joda 库按人类语言和计算机各自解析的时间处理方式。不同于老版本，新API基于ISO标准日历系统，java.time包下的所有类都是不可变类型而且线程安全。</p><h2 id="1-关键类"><a href="#1-关键类" class="headerlink" title="1. 关键类"></a>1. 关键类</h2><ul><li>Instant：瞬时实例。</li><li>LocalDate：本地日期，不包含具体时间 例如：2014-01-14 可以用来记录生日、纪念日、加盟日等。</li><li>LocalTime：本地时间，不包含日期。</li><li>LocalDateTime：组合了日期和时间，但不包含时差和时区信息。</li><li>ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。</li></ul><p>新API还引入了 ZoneOffSet 和 ZoneId 类，使得解决时区问题更为简便。解析、格式化时间的 DateTimeFormatter 类也全部重新设计。</p><h2 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>时间戳转LocalDateTime,时间戳如果是字符串则先转为<span class="type">long</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.ofEpochSecond(System.currentTimeMillis()/<span class="number">1000</span>, <span class="number">0</span>, ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line"><span class="number">2.</span>日期字符串转LocalDate</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDate.parse(“<span class="number">2020</span>-<span class="number">05</span>-<span class="number">13</span>”);</span><br><span class="line"><span class="number">3.</span>LocalDateTime转LocalDate</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDateTime.now().toLocalDate();</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Date转LocalDate</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> date.toInstant().atZone(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">或使用系统默认时区</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line"><span class="number">5.</span>时间戳转Date</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis());</span><br><span class="line">或</span><br><span class="line">date.setTime(System.currentTimeMillis());</span><br><span class="line"><span class="number">6.</span>Date转LocalDateTime</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.ofInstant(<span class="keyword">new</span> <span class="title class_">Date</span>().toInstant(), ZoneId.systemDefault());</span><br><span class="line"><span class="number">7.</span>LocalDateTime转Date</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> Date.from(LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line"><span class="number">8.</span>LocalDate转Date</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> LocalDate.now().atStartOfDay(ZoneId.systemDefault());</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(zonedDateTime.toInstant());</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>获取前一天<span class="number">0</span>和<span class="number">24</span>点时间戳</span><br><span class="line">秒：</span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> LocalDateTime.of(LocalDate.now().minusDays(<span class="number">1</span>), LocalTime.MIN).toEpochSecond(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>));</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(LocalDate.now().minusDays(<span class="number">1</span>), LocalTime.MAX).toEpochSecond(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>));</span><br><span class="line">毫秒：</span><br><span class="line"><span class="type">long</span> <span class="variable">startTimeMill</span> <span class="operator">=</span> LocalDateTime.of(LocalDate.now().minusDays(<span class="number">1</span>), LocalTime.MIN).toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line"><span class="type">long</span> <span class="variable">endTimeMill</span> <span class="operator">=</span> LocalDateTime.of(LocalDate.now().minusDays(<span class="number">1</span>), LocalTime.MAX).toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line"><span class="number">10.</span>时间格式</span><br><span class="line"><span class="comment">//时间格式</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”);</span><br><span class="line">System.out.println(<span class="string">&quot;formate: &quot;</span>+ now.format(formatter));</span><br><span class="line"><span class="number">11.</span>获取时间差</span><br><span class="line">startTime和endTime为LocalDateTime，获取相差多少天如下：</span><br><span class="line"><span class="type">long</span> <span class="variable">days</span> <span class="operator">=</span> startTime.until(endTime,ChronoUnit.DAYS);</span><br></pre></td></tr></table></figure><h2 id="3-时间戳与LocalDateTime互转"><a href="#3-时间戳与LocalDateTime互转" class="headerlink" title="3. 时间戳与LocalDateTime互转"></a>3. 时间戳与LocalDateTime互转</h2><h3 id="3-1-LocalDateTime-转-时间戳"><a href="#3-1-LocalDateTime-转-时间戳" class="headerlink" title="3.1 LocalDateTime 转 时间戳"></a>3.1 LocalDateTime 转 时间戳</h3><p>方式一</p><p>这边值得一提的是在中国的时区偏移是8小时，本次示例转的时间戳是秒级别，得到的值是一个long值；知识追寻者这边是当前时间，故读者得到的结果与知识追寻者得到的结果不一致；读者可以使用站长工具进行测试校验</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localTimeTest1</span>()</span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 将当前时间转为时间戳</span></span><br><span class="line">    <span class="built_in">long</span> second = localDateTime.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    <span class="comment">// 1580706475</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(second);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二</p><p>此方法执行的结果与之前一致，也是秒级别</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localTimeTest2</span>()</span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 将当前时间转为时间戳</span></span><br><span class="line">    <span class="built_in">long</span> second = localDateTime.toInstant(ZoneOffset.ofHours(<span class="number">8</span>)).getEpochSecond();</span><br><span class="line">    <span class="comment">// 1580707001</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(second);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三</p><p>此方式转的将是毫秒级别，直接用于站长工具是测试不出来，读者应该将其除1000取商获得正确的秒级时间戳；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localTimeTest3</span>()</span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前时间</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 将当前时间转为时间戳</span></span><br><span class="line">    <span class="built_in">long</span> milliseconds =          localDateTime.toInstant(ZoneOffset.ofHours(<span class="number">8</span>)).toEpochMilli();</span><br><span class="line">    <span class="comment">// 1580707268</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(milliseconds/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-时间戳-转LocalDateTime"><a href="#3-2-时间戳-转LocalDateTime" class="headerlink" title="3.2 时间戳 转LocalDateTime"></a>3.2 时间戳 转LocalDateTime</h3><p>以下几种获取的LocalDateTime方式按读者需求进行获取，不同的精确值，将获取不同的结果；</p><p>方式一</p><p>先获取时间戳为秒级别，然后通过转换为LocalDateTime</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localTimeTest4</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//获得时间戳</span></span><br><span class="line">    <span class="built_in">long</span> second = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).getEpochSecond();</span><br><span class="line">    <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(second, <span class="number">0</span>, ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    <span class="comment">// 2020-02-03T13:30:44</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(localDateTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二</p><p>本次获取的时间搓将是毫秒级别故要除以1000</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localTimeTest5</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//获得时间戳</span></span><br><span class="line">    <span class="built_in">long</span> milliseconds = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">    <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(milliseconds/<span class="number">1000</span>, <span class="number">0</span>, ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    <span class="comment">// 2020-02-03T13:35:53</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(localDateTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三</p><p>本方式精确值是毫秒级别，故得到的结果会存在三位小数点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localTimeTest6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获得时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">milliseconds</span> <span class="operator">=</span> LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">    <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> Instant.ofEpochMilli(milliseconds).atZone(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">    <span class="comment">// 2020-02-03T13:38:35.799</span></span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-时间戳与LocalDate互转"><a href="#4-时间戳与LocalDate互转" class="headerlink" title="4. 时间戳与LocalDate互转"></a>4. 时间戳与LocalDate互转</h2><p>学会时间戳与LocalDate互转，同理就可以推出时间戳与LocalTime 互转，不过知识追寻者相信几乎没人会用到这个，故这边就不做示例；</p><h3 id="4-1-时间戳转LocalDate"><a href="#4-1-时间戳转LocalDate" class="headerlink" title="4.1 时间戳转LocalDate"></a>4.1 时间戳转LocalDate</h3><p>方式一</p><p>注意这边是毫秒级的时间戳；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateTest1</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//获得时间戳</span></span><br><span class="line">    <span class="built_in">long</span> milliseconds = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">    <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">    LocalDate localDate = Instant.ofEpochMilli(milliseconds).atZone(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">    <span class="comment">// 2020-02-03</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(localDate);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二</p><p>注意这边是秒级时间戳</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateTest2</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//获得时间戳</span></span><br><span class="line">    <span class="built_in">long</span> seconds = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).getEpochSecond();</span><br><span class="line">    <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">    LocalDate localDate = Instant.ofEpochSecond(seconds).atZone(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">    <span class="comment">// 2020-02-03</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(localDate);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-LocalDate-转-时间戳"><a href="#4-2-LocalDate-转-时间戳" class="headerlink" title="4.2 LocalDate 转 时间戳"></a>4.2 LocalDate 转 时间戳</h3><p>方式一</p><p>注意妙计时间戳</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateTest3</span>()</span>&#123;</span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    <span class="comment">//获得时间戳</span></span><br><span class="line">    <span class="built_in">long</span> seconds = localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant().getEpochSecond();</span><br><span class="line">    <span class="comment">// 1580659200</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(seconds);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二</p><p>注意毫秒级时间戳</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateTest4</span>()</span>&#123;</span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    <span class="comment">//获得时间戳</span></span><br><span class="line">    <span class="built_in">long</span> seconds = localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant().toEpochMilli();</span><br><span class="line">    <span class="comment">// 1580659200000</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(seconds);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-LocalDateTime与Date互转"><a href="#5-LocalDateTime与Date互转" class="headerlink" title="5.LocalDateTime与Date互转"></a>5.LocalDateTime与Date互转</h2><h3 id="5-1-Date转LocalDateTime"><a href="#5-1-Date转LocalDateTime" class="headerlink" title="5.1 Date转LocalDateTime"></a>5.1 Date转LocalDateTime</h3><p>方式一</p><p>得出结果是有小数点，毫秒级精确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DateTest1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 将时间转为 LocalDateTime</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">    <span class="comment">// 2020-02-03T14:07:49.833</span></span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二</p><p>秒级精确；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DateTest2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 将时间转为 秒级时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">second</span> <span class="operator">=</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toEpochSecond();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.ofEpochSecond(second, <span class="number">0</span>, ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    <span class="comment">// 2020-02-03T14:11:39</span></span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-LocalDateTime-转-Date"><a href="#5-2-LocalDateTime-转-Date" class="headerlink" title="5.2 LocalDateTime 转 Date"></a>5.2 LocalDateTime 转 Date</h3><p>方式一</p><p>秒级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DateTest3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//当前时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 获得 Instant</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.ofEpochSecond(localDateTime.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">    <span class="comment">// 获得 Date</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">    <span class="comment">// Mon Feb 03 14:16:27 CST 2020</span></span><br><span class="line">    System.out.println(date);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DateTest4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//当前时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 获得 Instant</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> localDateTime.atZone(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant();</span><br><span class="line">    <span class="comment">// 获得 Date</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">    <span class="comment">// Mon Feb 03 14:20:32 CST 2020</span></span><br><span class="line">    System.out.println(date);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-LocalDate与Date互转"><a href="#6-LocalDate与Date互转" class="headerlink" title="6. LocalDate与Date互转"></a>6. LocalDate与Date互转</h2><h3 id="6-1-LocalDate-转-Date"><a href="#6-1-LocalDate-转-Date" class="headerlink" title="6.1 LocalDate 转 Date"></a>6.1 LocalDate 转 Date</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DateTest5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//当前时间</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="comment">// 获得 Instant</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant();</span><br><span class="line">    <span class="comment">// 获得 Date</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">    <span class="comment">// Mon Feb 03 00:00:00 CST 2020</span></span><br><span class="line">    System.out.println(date);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-Date-转LocalDate"><a href="#6-2-Date-转LocalDate" class="headerlink" title="6.2 Date 转LocalDate"></a>6.2 Date 转LocalDate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DateTest6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 获得 date</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 获得  LocalDate</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">    <span class="comment">// 2020-02-03</span></span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-LocalDateTime格式化"><a href="#7-LocalDateTime格式化" class="headerlink" title="7. LocalDateTime格式化"></a>7. LocalDateTime格式化</h2><p>最后再说下格式化；知识追寻者这边就不提 LocalDateTime， LocalDate , LocalTime 互转问题，原因是前言那篇文章已经提到过；</p><h3 id="7-1-LocalDateTime-转字符串"><a href="#7-1-LocalDateTime-转字符串" class="headerlink" title="7.1 LocalDateTime 转字符串"></a>7.1 LocalDateTime 转字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 获得 localDateTime</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 指定模式</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH/mm/ss&quot;</span>);</span><br><span class="line">    <span class="comment">// 将 LocalDateTime 格式化为字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> localDateTime.format(dateTimeFormatter);</span><br><span class="line">    <span class="comment">// 2020/02/03 14/38/54</span></span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-字符串-转LocalDateTime"><a href="#7-2-字符串-转LocalDateTime" class="headerlink" title="7.2 字符串 转LocalDateTime"></a>7.2 字符串 转LocalDateTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2020/02/03 14/38/54&quot;</span>;</span><br><span class="line">    <span class="comment">// 指定模式</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH/mm/ss&quot;</span>);</span><br><span class="line">    <span class="comment">// 将字符串格式化为 LocalDateTime</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.parse(time, dateTimeFormatter);</span><br><span class="line">    <span class="comment">// 2020-02-03T14:38:54</span></span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-API用法"><a href="#8-API用法" class="headerlink" title="8. API用法"></a>8. API用法</h2><p>在教程中我们将通过一些简单的实例来学习如何使用新API，因为只有在实际的项目中用到，才是学习新知识以及新技术最快的方式。</p><h3 id="1-获取当前的日期"><a href="#1-获取当前的日期" class="headerlink" title="1. 获取当前的日期"></a>1. 获取当前的日期</h3><p>Java 8 中的 <code>LocalDate</code> 用于表示当天日期。和 java.util.Date不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取今天的日期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCurrentDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;LocalDate: &quot;</span> + today);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;LocalDateTime: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;Date: &quot;</span> +date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了当天的日期，不含时间信息。打印出的日期格式非常友好，不像 Date类 打印出一堆没有格式化的信息。</p><h3 id="2-获取年、月、日信息"><a href="#2-获取年、月、日信息" class="headerlink" title="2. 获取年、月、日信息"></a>2. 获取年、月、日信息</h3><p><code>LocalDate</code> 提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息，不用像以前一样需要依赖java.util.Calendar类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取年、月、日信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getDetailDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> today.getYear();</span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> today.getMonthValue();</span><br><span class="line">    <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> today.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">    System.out.printf(<span class="string">&quot;Year : %d  Month : %d  day : %d t %n&quot;</span>, year, month, day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理特定日期"><a href="#3-处理特定日期" class="headerlink" title="3.处理特定日期"></a>3.处理特定日期</h3><p>在第一个例子里，我们通过静态工厂方法now()非常容易地创建了当天日期。我们还可以调用另一个有用的工厂方法 <code>LocalDate.of()</code> 创建任意日期， 该方法需要传入年、月、日做参数，返回对应的LocalDate实例。这个方法的好处是没再犯老API的设计错误，比如年度起始于1900，月份是从 <code>0</code> 开始等等。日期所见即所得，就像下面这个例子表示了1月21日，直接明了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理特定日期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleSpecilDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">dateOfBirth</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">01</span>, <span class="number">21</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The specil date is : &quot;</span> + dateOfBirth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-判断两个日期是否相等"><a href="#4-判断两个日期是否相等" class="headerlink" title="4.判断两个日期是否相等"></a>4.判断两个日期是否相等</h3><p>现实生活中有一类时间处理就是判断两个日期是否相等。在项目开发的时候总会遇到这样子的问题。下面这个例子会帮助你用Java 8的方式去解决，<code>LocalDate</code> 重载了equal方法。注意，如果比较的日期是字符型的，需要先解析成日期对象再作判断。</p><p>请看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断两个日期是否相等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compareDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">01</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(date1.equals(today))&#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;TODAY %s and DATE1 %s are same date %n&quot;</span>, today, date1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-检查像生日这种周期性事件"><a href="#5-检查像生日这种周期性事件" class="headerlink" title="5.检查像生日这种周期性事件"></a>5.检查像生日这种周期性事件</h3><p>Java 中另一个日期时间的处理就是检查类似生日、纪念日、法定假日（国庆以及春节）、或者每个月固定时间发送邮件给客户 这些周期性事件。Java中如何检查这些节日或其它周期性事件呢？答案就是<code>MonthDay</code>类。这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。和这个类相似的还有一个<code>YearMonth</code>类。这些类也都是不可变并且线程安全的值类型。下面我们通过 <code>MonthDay</code>来检查周期性事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理周期性的日期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cycleDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">dateOfBirth</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">01</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">MonthDay</span> <span class="variable">birthday</span> <span class="operator">=</span> MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());</span><br><span class="line">    <span class="type">MonthDay</span> <span class="variable">currentMonthDay</span> <span class="operator">=</span> MonthDay.from(today);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Many Many happy returns of the day !!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Sorry, today is not your birthday&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-获取当前时间"><a href="#6-获取当前时间" class="headerlink" title="6.获取当前时间"></a>6.获取当前时间</h3><p>与 获取日期 例子很像，获取时间使用的是 <code>LocalTime</code> 类，一个只有时间没有日期的LocalDate近亲。可以调用静态工厂方法now()来获取当前时间。默认的格式是<code>hh:mm:ss:nnn</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCurrentTime</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;local time now : &quot;</span> + time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-在现有的时间上增加小时"><a href="#7-在现有的时间上增加小时" class="headerlink" title="7.在现有的时间上增加小时"></a>7.在现有的时间上增加小时</h3><p>Java 8 提供了更好的 plusHours() 方法替换 add() ，并且是兼容的。注意，这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加小时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">plusHours</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">newTime</span> <span class="operator">=</span> time.plusHours(<span class="number">2</span>); <span class="comment">// 增加两小时</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Time after 2 hours : &quot;</span> +  newTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-如何计算一个星期之后的日期"><a href="#8-如何计算一个星期之后的日期" class="headerlink" title="8.如何计算一个星期之后的日期"></a>8.如何计算一个星期之后的日期</h3><p>和上个例子计算两小时以后的时间类似，这个例子会计算一周后的日期。LocalDate日期不包含时间信息，它的plus()方法用来增加天、周、月，ChronoUnit类声明了这些时间单位。由于LocalDate也是不变类型，返回后一定要用变量赋值。</p><p>可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看Java 8 API中的ChronoUnit类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何计算一周后的日期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nextWeek</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nextWeek</span> <span class="operator">=</span> today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);    <span class="comment">//使用变量赋值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Today is : &quot;</span> + today);</span><br><span class="line">    System.out.println(<span class="string">&quot;Date after 1 week : &quot;</span> + nextWeek);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-计算一年前或一年后的日期"><a href="#9-计算一年前或一年后的日期" class="headerlink" title="9.计算一年前或一年后的日期"></a>9.计算一年前或一年后的日期</h3><p>接着上面的例子中我们通过 <code>LocalDate</code> 的 <code>plus()</code> 方法增加天数、周数或月数，这个例子我们利用 <code>minus()</code> 方法计算一年前的日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算一年前或一年后的日期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minusDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">previousYear</span> <span class="operator">=</span> today.minus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">    System.out.println(<span class="string">&quot;Date before 1 year : &quot;</span> + previousYear);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nextYear</span> <span class="operator">=</span> today.plus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">    System.out.println(<span class="string">&quot;Date after 1 year : &quot;</span> + nextYear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-使用Java-8的Clock时钟类"><a href="#10-使用Java-8的Clock时钟类" class="headerlink" title="10.使用Java 8的Clock时钟类"></a>10.使用Java 8的Clock时钟类</h3><p>Java 8增加了一个 Clock 时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis() 和 TimeZone.getDefault() 的地方都可用Clock替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 根据系统时间返回当前时间并设置为UTC。</span></span><br><span class="line">    <span class="type">Clock</span> <span class="variable">clock</span> <span class="operator">=</span> Clock.systemUTC();</span><br><span class="line">    System.out.println(<span class="string">&quot;Clock : &quot;</span> + clock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据系统时钟区域返回时间</span></span><br><span class="line">    <span class="type">Clock</span> <span class="variable">defaultClock</span> <span class="operator">=</span> Clock.systemDefaultZone();</span><br><span class="line">    System.out.println(<span class="string">&quot;Clock : &quot;</span> + clock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-判断日期是早于还是晚于另一个日期"><a href="#11-判断日期是早于还是晚于另一个日期" class="headerlink" title="11.判断日期是早于还是晚于另一个日期"></a>11.判断日期是早于还是晚于另一个日期</h3><p>LocalDate 类有两类方法 <code>isBefore()</code> 和 <code>isAfter()</code> 用于比较日期。调用 <code>isBefore()</code> 方法时，如果给定日期小于当前日期则返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何用Java判断日期是早于还是晚于另一个日期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isBeforeOrIsAfter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">tomorrow</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">29</span>);</span><br><span class="line">    <span class="keyword">if</span>(tomorrow.isAfter(today))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tomorrow comes after today&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减去一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">yesterday</span> <span class="operator">=</span> today.minus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(yesterday.isBefore(today))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Yesterday is day before today&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-处理时区"><a href="#12-处理时区" class="headerlink" title="12.处理时区"></a>12.处理时区</h3><p>Java 8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如 ZoneId 来处理特定时区，ZoneDateTime 类来表示某时区下的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取特定时区下面的时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getZoneTime</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">america</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localtDateAndTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">dateAndTimeInNewYork</span>  <span class="operator">=</span> ZonedDateTime.of(localtDateAndTime, america );</span><br><span class="line">    System.out.println(<span class="string">&quot;现在的日期和时间在特定的时区 : &quot;</span> + dateAndTimeInNewYork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-如何体现出固定日期"><a href="#13-如何体现出固定日期" class="headerlink" title="13.如何体现出固定日期"></a>13.如何体现出固定日期</h3><p>例如：表示信用卡到期这类固定日期。与 MonthDay 检查重复事件的例子相似，<code>YearMonth</code> 是另一个组合类，用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到 当月共有多少天，YearMonth 实例的 <code>lengthOfMonth()</code> 方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 YearMonth类处理特定的日期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkCardExpiry</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">YearMonth</span> <span class="variable">currentYearMonth</span> <span class="operator">=</span> YearMonth.now();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Days in month year %s: %d%n&quot;</span>, currentYearMonth, currentYearMonth.lengthOfMonth());</span><br><span class="line"></span><br><span class="line">    <span class="type">YearMonth</span> <span class="variable">creditCardExpiry</span> <span class="operator">=</span> YearMonth.of(<span class="number">2028</span>, Month.FEBRUARY);</span><br><span class="line">    System.out.printf(<span class="string">&quot;Your credit card expires on %s %n&quot;</span>, creditCardExpiry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-检查闰年"><a href="#14-检查闰年" class="headerlink" title="14.检查闰年"></a>14.检查闰年</h3><p>LocalDate类有一个很实用的方法 <code>isLeapYear()</code> 判断该实例是否是一个闰年，如果你还是想重新发明轮子，这有一个代码示例，纯Java逻辑编写的判断闰年的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查闰年</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isLeapYear</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="keyword">if</span>(today.isLeapYear())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This year is Leap year&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2018 is not a Leap year&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-计算两个日期之间的天数和月数"><a href="#15-计算两个日期之间的天数和月数" class="headerlink" title="15.计算两个日期之间的天数和月数"></a>15.计算两个日期之间的天数和月数</h3><p>有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java 8中可以用java.time.Period类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。下面的例子：现在是一月份，距离到五月份，中间相隔3月</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算两个日期之间的天数和月数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calcDateDays</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">java8Release</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, Month.MAY, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Period</span> <span class="variable">periodToNextJavaRelease</span> <span class="operator">=</span> Period.between(today, java8Release);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Months left between today and Java 8 release : &quot;</span></span><br><span class="line">                                           + periodToNextJavaRelease.getMonths() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-包含时差信息的日期和时间"><a href="#16-包含时差信息的日期和时间" class="headerlink" title="16.包含时差信息的日期和时间"></a>16.包含时差信息的日期和时间</h3><p>ZoneOffset类用来表示时区，举例来说印度与GMT或UTC标准时区相差+05:30，可以通过ZoneOffset.of()静态方法来 获取对应的时区。一旦得到了时差就可以通过传入LocalDateTime和ZoneOffset来创建一个OffSetDateTime对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZoneOffset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">datetime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2018</span>, Month.FEBRUARY, <span class="number">14</span>, <span class="number">19</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="type">ZoneOffset</span> <span class="variable">offset</span> <span class="operator">=</span> ZoneOffset.of(<span class="string">&quot;+05:30&quot;</span>);</span><br><span class="line">    <span class="type">OffsetDateTime</span> <span class="variable">date</span> <span class="operator">=</span> OffsetDateTime.of(datetime, offset);</span><br><span class="line">    System.out.println(<span class="string">&quot;Date and Time with timezone offset in Java : &quot;</span> + date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-获取当前的时间戳"><a href="#17-获取当前的时间戳" class="headerlink" title="17.获取当前的时间戳"></a>17.获取当前的时间戳</h3><p>Instant类有一个静态工厂方法now()会返回当前的时间戳，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getTimestamp</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Instant</span> <span class="variable">timestamp</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;What is value of this instant &quot;</span> + timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-使用预定义的格式化工具去解析或格式化日期"><a href="#18-使用预定义的格式化工具去解析或格式化日期" class="headerlink" title="18.使用预定义的格式化工具去解析或格式化日期"></a>18.使用预定义的格式化工具去解析或格式化日期</h3><p>Java 8引入了全新的日期时间格式工具，线程安全而且使用方便。它自带了一些常用的内置格式化工具。下面这个例子使用了BASIC_ISO_DATE格式化工具将2018年2月10日格式化成20180210。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用预定义的格式化工具去解析或格式化日期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">formateDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dayAfterTommorrow</span> <span class="operator">=</span> <span class="string">&quot;20180210&quot;</span>;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">formatted</span> <span class="operator">=</span> LocalDate.parse(dayAfterTommorrow, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">    System.out.printf(<span class="string">&quot;Date generated from String %s is %s %n&quot;</span>, dayAfterTommorrow, formatted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后附上全部代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wq.study.java8.date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Clock;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"><span class="keyword">import</span> java.time.MonthDay;</span><br><span class="line"><span class="keyword">import</span> java.time.OffsetDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"><span class="keyword">import</span> java.time.YearMonth;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取今天的日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCurrentDate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;LocalDate: &quot;</span> + today);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;LocalDateTime: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Date: &quot;</span> +date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年、月、日信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getDetailDate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> today.getYear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> today.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> today.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;Year : %d  Month : %d  day : %d t %n&quot;</span>, year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理特定日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleSpecilDate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">dateOfBirth</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">01</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;The specil date is : &quot;</span> + dateOfBirth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两个日期是否相等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compareDate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">01</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(date1.equals(today))&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;TODAY %s and DATE1 %s are same date %n&quot;</span>, today, date1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理周期性的日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cycleDate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">dateOfBirth</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">01</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">MonthDay</span> <span class="variable">birthday</span> <span class="operator">=</span> MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());</span><br><span class="line">        <span class="type">MonthDay</span> <span class="variable">currentMonthDay</span> <span class="operator">=</span> MonthDay.from(today);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Many Many happy returns of the day !!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Sorry, today is not your birthday&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCurrentTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;local time now : &quot;</span> + time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加小时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">plusHours</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">newTime</span> <span class="operator">=</span> time.plusHours(<span class="number">2</span>); <span class="comment">// 增加两小时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Time after 2 hours : &quot;</span> +  newTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何计算一周后的日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nextWeek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">nextWeek</span> <span class="operator">=</span> today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line">        System.out.println(<span class="string">&quot;Today is : &quot;</span> + today);</span><br><span class="line">        System.out.println(<span class="string">&quot;Date after 1 week : &quot;</span> + nextWeek);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算一年前或一年后的日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minusDate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">previousYear</span> <span class="operator">=</span> today.minus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">        System.out.println(<span class="string">&quot;Date before 1 year : &quot;</span> + previousYear);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">nextYear</span> <span class="operator">=</span> today.plus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">        System.out.println(<span class="string">&quot;Date after 1 year : &quot;</span> + nextYear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 根据系统时间返回当前时间并设置为UTC。</span></span><br><span class="line">        <span class="type">Clock</span> <span class="variable">clock</span> <span class="operator">=</span> Clock.systemUTC();</span><br><span class="line">        System.out.println(<span class="string">&quot;Clock : &quot;</span> + clock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据系统时钟区域返回时间</span></span><br><span class="line">        <span class="type">Clock</span> <span class="variable">defaultClock</span> <span class="operator">=</span> Clock.systemDefaultZone();</span><br><span class="line">        System.out.println(<span class="string">&quot;Clock : &quot;</span> + clock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何用Java判断日期是早于还是晚于另一个日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isBeforeOrIsAfter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">tomorrow</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">29</span>);</span><br><span class="line">        <span class="keyword">if</span>(tomorrow.isAfter(today))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Tomorrow comes after today&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">yesterday</span> <span class="operator">=</span> today.minus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(yesterday.isBefore(today))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yesterday is day before today&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时区处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getZoneTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置时区</span></span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">america</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localtDateAndTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">dateAndTimeInNewYork</span>  <span class="operator">=</span> ZonedDateTime.of(localtDateAndTime, america );</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的日期和时间在特定的时区 : &quot;</span> + dateAndTimeInNewYork);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 YearMonth类处理特定的日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkCardExpiry</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">YearMonth</span> <span class="variable">currentYearMonth</span> <span class="operator">=</span> YearMonth.now();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Days in month year %s: %d%n&quot;</span>, currentYearMonth, currentYearMonth.lengthOfMonth());</span><br><span class="line"></span><br><span class="line">        <span class="type">YearMonth</span> <span class="variable">creditCardExpiry</span> <span class="operator">=</span> YearMonth.of(<span class="number">2028</span>, Month.FEBRUARY);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Your credit card expires on %s %n&quot;</span>, creditCardExpiry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查闰年</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isLeapYear</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="keyword">if</span>(today.isLeapYear())&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;This year is Leap year&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2018 is not a Leap year&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算两个日期之间的天数和月数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calcDateDays</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">java8Release</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, Month.MAY, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Period</span> <span class="variable">periodToNextJavaRelease</span> <span class="operator">=</span> Period.between(today, java8Release);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Months left between today and Java 8 release : &quot;</span></span><br><span class="line">                                           + periodToNextJavaRelease.getMonths() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含时差信息的日期和时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZoneOffset</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">datetime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2018</span>, Month.FEBRUARY, <span class="number">14</span>, <span class="number">19</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">ZoneOffset</span> <span class="variable">offset</span> <span class="operator">=</span> ZoneOffset.of(<span class="string">&quot;+05:30&quot;</span>);</span><br><span class="line">        <span class="type">OffsetDateTime</span> <span class="variable">date</span> <span class="operator">=</span> OffsetDateTime.of(datetime, offset);</span><br><span class="line">        System.out.println(<span class="string">&quot;Date and Time with timezone offset in Java : &quot;</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时间戳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getTimestamp</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">timestamp</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;What is value of this instant &quot;</span> + timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用预定义的格式化工具去解析或格式化日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">formateDate</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">dayAfterTommorrow</span> <span class="operator">=</span> <span class="string">&quot;20180210&quot;</span>;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">formatted</span> <span class="operator">=</span> LocalDate.parse(dayAfterTommorrow, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Date generated from String %s is %s %n&quot;</span>, dayAfterTommorrow, formatted);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateTime</span> <span class="operator">=</span> <span class="string">&quot;2018/02/10 12:33:59&quot;</span>;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(dateTime, formatter);</span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>+parse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateTest</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTest</span>();</span><br><span class="line"></span><br><span class="line">        dt.formateDate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java <span class="number">8</span>日期时间API的重点</span><br><span class="line"><span class="number">1</span>）提供了javax.time.ZoneId 获取时区。</span><br><span class="line"><span class="number">2</span>）提供了LocalDate和LocalTime类。</span><br><span class="line"><span class="number">3</span>）Java <span class="number">8</span> 的所有日期和时间API都是不可变类并且线程安全，而现有的Date和Calendar API中的java.util.Date和SimpleDateFormat是非线程安全的。</span><br><span class="line"><span class="number">4</span>）主包是 java.time,包含了表示日期、时间、时间间隔的一些类。里面有两个子包java.time.format用于格式化， java.time.temporal用于更底层的操作。</span><br><span class="line"><span class="number">5</span>）时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LocalDateTime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kkndme天涯帖子</title>
      <link href="/2022/06/04/0.kkndme/"/>
      <url>/2022/06/04/0.kkndme/</url>
      
        <content type="html"><![CDATA[<h1 id="kkndme-tianya（持续更新中…）"><a href="#kkndme-tianya（持续更新中…）" class="headerlink" title="kkndme_tianya（持续更新中…）"></a>kkndme_tianya（持续更新中…）</h1><blockquote><p>天涯神贴<a href="http://bbs.tianya.cn/post-house-252774-1.shtml">「2010年的房地产调控，我们收获了什么？写在房价暴涨前」</a>脱水版，内容时间顺序和原贴一致，原贴中的优质非楼主写的内容，添加了引用格式便于区分。</p><p>除标题外，所有内容均来自原贴，标题是我简单加的，目的是为了做目录，便于查看。</p><p><strong>帖子里的内容还没有整理完，待全部整理完：</strong></p><ul><li>对 <strong>kkndme</strong> 的观点有了完整的认识后，我会在公众号<code>沈正方</code>上写写我对这个帖子内容的思考</li><li>其次，我会把本仓库的内容做成PDF，通过公众号<code>沈正方</code>发出去，欢迎关注一起讨论！</li></ul><p><strong>微信交流群</strong>：</p><ul><li>鉴于很多人关注公众号后，咨询有没有微信讨论群可以加，之前没有，现在有了</li><li>加微信（微信搜索<code>shenshuyolo</code>或 扫下方二维码），免费拉你进 <strong>kkndme</strong> 交流群<br><img src="/shenshuyolo.JPG" alt="微信号:shenshuyolo"></li></ul></blockquote><ul><li><a href="#%E8%B0%83%E6%8E%A7%E9%99%8D%E6%88%BF%E4%BB%B7%E6%98%AF%E5%88%9A%E9%9C%80%E7%9A%84%E4%B8%80%E5%8E%A2%E6%83%85%E6%84%BF">调控降房价是刚需的一厢情愿</a><ul><li><a href="#1%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%9C%89%E5%B1%85%E4%BD%8F%E6%9D%83%E6%88%BF%E5%AD%90%E6%98%AF%E7%94%A8%E6%9D%A5%E4%BD%8F%E7%9A%84%E4%B8%8D%E6%98%AF%E7%94%A8%E6%9D%A5%E7%82%92%E7%9A%84">1、人人都有居住权。房子是用来住的，不是用来炒的。</a></li><li><a href="#2%E6%88%BF%E5%AD%90%E5%A4%AA%E8%B4%B5%E4%BA%86%E7%A7%9F%E5%94%AE%E6%AF%94%E4%B8%A5%E9%87%8D%E4%B8%8D%E5%90%88%E7%90%86%E7%A9%BA%E7%BD%AE%E7%8E%87%E5%A4%AA%E9%AB%98%E4%BA%BA%E5%9D%87%E6%94%B6%E5%85%A5%E5%A4%AA%E4%BD%8E%E6%97%A9%E6%99%9A%E8%A6%81%E5%B4%A9%E7%9B%98">2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。</a></li><li><a href="#3%E6%88%BF%E4%BB%B7%E4%B8%8A%E6%B6%A8%E9%80%A0%E6%88%90%E7%89%A9%E4%BB%B7%E4%B8%8A%E6%B6%A8%E4%BA%BA%E6%B0%91%E7%94%9F%E6%B4%BB%E5%8F%98%E5%BE%97%E5%9B%B0%E9%9A%BE">3、房价上涨造成物价上涨，人民生活变得困难</a></li></ul></li><li><a href="#%E8%B0%83%E6%8E%A7%E7%9A%84%E7%9C%9F%E6%AD%A3%E7%9B%AE%E7%9A%84%E9%98%B2%E8%8C%83%E9%87%91%E8%9E%8D%E9%A3%8E%E9%99%A9--%E9%80%9A%E8%BF%87%E5%9E%84%E6%96%AD%E5%AE%9E%E7%8E%B0gj%E5%88%A9%E7%9B%8A%E6%9C%80%E5%A4%A7%E5%8C%96">调控的真正目的：防范金融风险 &amp; 通过垄断实现gj利益最大化</a></li><li><a href="#%E5%AE%98%E6%96%B9%E5%85%AC%E5%B8%83%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%8F%AA%E8%A6%81%E5%85%B3%E7%B3%BB%E5%88%B0%E6%9F%90%E4%B8%AA%E7%BE%A4%E4%BD%93%E7%9A%84%E5%88%A9%E7%9B%8A%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E4%BF%AE%E9%A5%B0%E5%AF%BC%E8%87%B4%E5%A4%B1%E7%9C%9F">官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真</a></li><li><a href="#%E7%A8%8E%E6%94%B6%E4%BB%8E%E6%9D%A5%E9%83%BD%E6%98%AF%E5%90%91%E4%B8%8B%E6%B8%B8%E8%BD%AC%E5%AB%81%E7%9A%84--%E6%88%BF%E4%BA%A7%E7%A8%8E%E8%BF%9F%E8%BF%9F%E4%B8%8D%E5%87%BA%E5%8F%B0%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%8E%9F%E5%9B%A0">税收从来都是向下游转嫁的 &amp; 房产税迟迟不出台的真正原因</a></li><li><a href="#%E6%88%BF%E5%9C%B0%E4%BA%A7%E7%9A%84%E7%8E%B0%E7%8A%B6">房地产的现状</a></li><li><a href="#%E6%88%BF%E4%BB%B7%E6%8C%81%E7%BB%AD%E4%B8%8A%E6%B6%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E7%A8%80%E7%BC%BA%E6%80%A7%E8%AE%A9%E5%A5%BD%E6%88%BF%E5%AD%90%E6%88%90%E4%B8%BA%E8%B5%84%E9%87%91%E6%9C%80%E5%A5%BD%E7%9A%84%E5%8E%BB%E5%A4%84">房价持续上涨的本质是稀缺性让好房子成为资金最好的去处</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E5%9E%84%E6%96%AD">关于垄断</a><ul><li><a href="#1%E5%9E%84%E6%96%AD%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E6%B2%A1%E6%9C%89%E9%A3%8E%E9%99%A9">1、垄断的好处是没有风险</a></li><li><a href="#2%E5%9E%84%E6%96%AD%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E7%A4%BE%E4%BC%9A%E7%A8%B3%E5%AE%9A">2、垄断可以解决社会稳定</a></li><li><a href="#3%E6%88%BF%E5%B1%8B%E5%9E%84%E6%96%AD%E5%8F%AA%E4%BC%9A%E6%84%88%E6%BC%94%E6%84%88%E7%83%88%E5%BA%95%E5%B1%82%E4%BA%BA%E6%B0%91%E6%83%B3%E8%A6%81%E6%8B%A5%E6%9C%89%E4%B8%80%E5%A5%97%E6%88%BF%E5%AD%90%E7%9A%84%E9%9A%BE%E5%BA%A6%E5%8F%AA%E4%BC%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%9A%BE">3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难</a></li></ul></li><li><a href="#%E6%B0%91%E7%94%9F%E9%97%AE%E9%A2%98">民生问题</a></li><li><a href="#%E6%88%BF%E4%BA%A7%E7%A8%8E%E7%9A%84%E5%88%B6%E5%AE%9A%E5%8E%9F%E5%88%99">房产税的制定原则</a></li><li><a href="#%E7%BB%B4%E7%A8%B3%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BA%BA%E6%B0%91%E8%83%BD%E5%90%83%E9%A5%B1%E9%A5%AD">维稳的本质是人民能吃饱饭</a></li><li><a href="#%E5%85%AC%E7%A7%9F%E6%88%BF%E6%98%AF%E4%B8%BA%E4%BD%93%E5%88%B6%E5%86%85%E6%9C%8D%E5%8A%A1%E7%9A%84">公租房是为体制内服务的</a></li><li><a href="#%E6%88%BF%E4%BA%A7%E7%A8%8E%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%BD%AC%E5%AB%81%E7%BB%99%E7%A7%9F%E6%88%BF%E4%BA%BA">房产税一定会转嫁给租房人</a></li><li><a href="#%E5%B7%A8%E5%A4%A7%E7%9A%84%E7%A8%8E%E6%94%B6%E6%B6%88%E8%80%97%E4%B9%9F%E5%86%B3%E5%AE%9A%E4%BA%86GDP%E5%BF%85%E9%A1%BB%E5%BF%AB%E9%80%9F%E5%A2%9E%E9%95%BF">巨大的税收消耗也决定了GDP必须快速增长</a></li><li><a href="#%E8%B0%83%E6%8E%A7%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E8%AE%A9zf%E5%88%A9%E7%9B%8A%E6%9C%80%E5%A4%A7%E5%8C%96&%E9%98%B2%E8%8C%83%E9%87%91%E8%9E%8D%E9%A3%8E%E9%99%A9">调控的好处是让zf利益最大化&amp;防范金融风险</a></li><li><a href="#%E5%9E%84%E6%96%AD%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E4%BB%B7%E6%A0%BC%E7%BB%B4%E6%8C%81%E7%A8%B3%E5%AE%9A">垄断可以控制价格，维持稳定</a></li><li><a href="#%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%84%E4%BD%8F%E6%88%BF%E9%97%AE%E9%A2%98%E6%9C%89%E5%9B%BD%E5%AE%B6%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA">体制内的住房问题有国家保驾护航</a></li><li><a href="#%E4%BE%9D%E9%9D%A0%E4%BD%86%E5%8F%88%E4%B8%8D%E8%83%BD%E5%AE%8C%E5%85%A8%E4%BE%9D%E9%9D%A0%E5%BC%80%E5%8F%91%E5%95%86%E5%BB%BA%E5%85%AC%E7%A7%9F%E6%88%BF">依靠但又不能完全依靠开发商建公租房</a></li><li><a href="#%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%84%E4%BD%8F%E6%88%BF%E9%97%AE%E9%A2%98%E4%B8%8D%E9%9A%BE%E8%A7%A3%E5%86%B3">体制内的住房问题不难解决</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E4%BD%93%E5%88%B6%E5%A4%96%E7%9A%84%E4%BD%8F%E6%88%BF%E9%97%AE%E9%A2%98%E5%9B%BD%E5%AE%B6%E5%9E%84%E6%96%AD%E7%BB%86%E6%B0%B4%E9%95%BF%E6%B5%81%E6%94%B6%E7%A7%9F">解决体制外的住房问题：国家垄断，细水长流收租</a></li><li><a href="#%E6%99%AE%E9%80%9A%E4%BA%BA%E4%B9%B0%E5%BE%97%E8%B5%B7%E4%BC%98%E8%B4%A8%E5%95%86%E5%93%81%E6%88%BF%E5%B0%B1%E5%B0%BD%E6%97%A9%E4%B9%B0%E6%8A%8A">普通人买得起「优质商品房」就尽早买把</a></li><li><a href="#%E5%95%86%E5%93%81%E6%88%BF%E5%92%8C%E5%85%AC%E7%A7%9F%E6%88%BF%E7%9A%84%E5%8C%BA%E5%88%AB">商品房和公租房的区别</a></li><li><a href="#%E6%8F%90%E8%AE%AE%E9%80%9A%E8%BF%87%E5%BE%81%E6%99%AE%E7%A8%8E%E8%B0%83%E8%8A%82%E8%B4%AB%E5%AF%8C%E5%B7%AE%E8%B7%9D%E4%B8%8D%E6%98%AF%E5%82%BB%E5%B0%B1%E6%98%AF%E5%9D%8F%E5%88%B6%E5%AE%9A%E6%94%BF%E7%AD%96%E7%9A%84%E4%BA%BA%E4%B8%8D%E4%BC%9A%E8%AE%A9%E6%94%BF%E7%AD%96%E9%92%88%E5%AF%B9%E8%87%AA%E5%B7%B1%E9%82%A3%E4%B9%88%E6%94%BF%E7%AD%96%E9%83%BD%E6%98%AF%E8%B0%81%E5%88%B6%E5%AE%9A%E7%9A%84%E5%91%A2">提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）</a></li><li><a href="#%E8%B0%83%E6%8E%A7%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D">调控带来的影响</a></li><li><a href="#%E5%86%9C%E4%BA%A7%E5%93%81%E7%9A%84%E4%BB%B7%E6%A0%BC%E5%85%B3%E7%B3%BB%E5%88%B0%E5%BD%B1%E5%93%8D%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98">农产品的价格关系到影响稳定的吃饭问题</a></li><li><a href="#%E5%86%9C%E4%BA%A7%E5%93%81%E4%BB%B7%E6%A0%BC%E7%9A%84%E6%8A%AC%E5%A4%B4%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%89%A9%E4%BB%B7%E5%85%A8%E9%9D%A2%E4%B8%8A%E6%B6%A8%EF%BC%8C%E4%BD%86%E5%9B%BD%E5%AE%B6%E4%B8%8D%E4%BC%9A%E5%9D%90%E8%A7%86%E4%B8%8D%E7%AE%A1%E4%B8%94%E6%9C%89%E8%83%BD%E5%8A%9B%E7%AE%A1">农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管</a></li><li><a href="#%E8%B5%84%E9%87%91%E4%BC%9A%E5%9C%A8%E4%BC%98%E8%B4%A8%E8%B5%84%E4%BA%A7%E4%B9%8B%E9%97%B4%E6%B5%81%E5%8A%A8%EF%BC%8C%E8%80%8C%E5%86%B3%E5%AE%9A%E4%BC%98%E8%B4%A8%E8%B5%84%E4%BA%A7%E4%BB%B7%E6%A0%BC%E7%9A%84%E6%98%AF%E7%B2%BE%E8%8B%B1%E9%98%B6%E5%B1%82%E7%9A%84%E8%B4%AD%E4%B9%B0%E5%8A%9B">资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力</a></li><li><a href="#%E8%B5%84%E9%87%91%E6%B5%81%E5%90%91%E8%A7%84%E5%BE%8B%E5%86%B3%E5%AE%9A%E4%BA%86%E5%86%9C%E4%BA%A7%E5%93%81%E5%92%8C%E8%B5%84%E4%BA%A7%E4%BB%B7%E6%A0%BC%E6%80%BB%E6%9C%89%E4%B8%80%E4%B8%AA%E8%A6%81%E6%B6%A8%E4%BA%BA%E4%B8%BA%E5%8E%8B%E5%88%B6%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%8C%89%E4%B8%8B%E8%91%AB%E8%8A%A6%E6%B5%AE%E8%B5%B7%E7%93%A2">资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢</a></li><li><a href="#%E8%B5%84%E9%87%91%E6%B5%81%E5%90%91%E8%A7%84%E5%BE%8B%E5%86%B3%E5%AE%9A%E4%BA%86%E6%B4%BC%E5%9C%B0%E4%B8%8D%E4%BC%9A%E4%B8%80%E7%9B%B4%E6%98%AF%E6%B4%BC%E5%9C%B0">资金流向规律决定了洼地不会一直是洼地</a></li><li><a href="#%E5%A4%A7%E5%9F%8E%E5%B8%82%E5%AF%B9%E8%BF%91%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%B0%8F%E5%9F%8E%E5%B8%82%E6%9C%89%E8%99%B9%E5%90%B8%E6%95%88%E5%BA%94">大城市对近距离的小城市有虹吸效应</a></li><li><a href="#%E5%86%B3%E5%AE%9A%E6%88%BF%E4%BB%B7%E7%9A%84%E5%9B%A0%E7%B4%A0%E6%9C%89%E5%BE%88%E5%A4%9A%EF%BC%8C%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90">决定房价的因素有很多，具体情况具体分析</a></li><li><a href="#%E6%88%BF%E4%BB%B7%E6%9A%B4%E6%B6%A8%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E9%92%B1%E8%80%8C%E8%A8%80%E7%9A%84%E4%B8%8D%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%AE%9E%E9%99%85%E8%B4%AD%E4%B9%B0%E5%8A%9B%E8%80%8C%E8%A8%80%E7%9A%84">房价暴涨是相对于钱而言的，不是相对于实际购买力而言的</a></li><li><a href="#%E5%9C%9F%E5%9C%B0%E4%B8%8D%E7%A8%80%E7%BC%BA%E4%BC%98%E8%B4%A8%E5%9C%9F%E5%9C%B0%E7%A8%80%E7%BC%BA">土地不稀缺，优质土地稀缺</a></li><li><a href="#%E9%9B%86%E4%B8%AD%E5%8F%91%E5%B1%95%E5%A4%A7%E5%9F%8E%E5%B8%82%E6%98%AF%E5%AF%BC%E8%87%B4%E4%BC%98%E8%B4%A8%E5%9C%9F%E5%9C%B0%E7%A8%80%E7%BC%BA%E7%9A%84%E5%8E%9F%E5%9B%A0">集中发展大城市是导致优质土地稀缺的原因</a></li><li><a href="#%E4%B8%BA%E4%BA%BA%E6%B0%91%E6%9C%8D%E5%8A%A1%E6%98%AF%E8%AF%B4%E7%BB%99%E4%BA%BA%E6%B0%91%E5%90%AC%E7%9A%84">为人民服务是说给人民听的</a></li><li><a href="#%E5%8E%86%E5%8F%B2%E6%98%AF%E4%B8%80%E9%9D%A2%E9%95%9C%E5%AD%90%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9B%BD%E6%83%85%E5%86%B3%E5%AE%9A%E4%BA%86%E9%87%87%E5%8F%96%E5%90%8C%E6%A0%B7%E7%9A%84%E6%94%BF%E7%AD%96%E7%BB%93%E6%9E%9C%E5%8F%AF%E8%83%BD%E6%98%AF%E5%8D%97%E8%BE%95%E5%8C%97%E8%BE%99">历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙</a></li><li><a href="#zf%E9%99%90%E5%88%B6%E6%94%BF%E7%AD%96%E6%88%BF%E7%9A%84%E5%88%A9%E6%B6%A6%E9%82%A3kfs%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%81%B7%E5%B7%A5%E5%87%8F%E6%96%99">zf限制政策房的利润，那kfs就一定会偷工减料</a></li><li><a href="#%E5%B1%81%E8%82%A1%E5%86%B3%E5%AE%9A%E8%84%91%E8%A2%8B%E4%BA%BA%E6%B0%91%E4%B8%8D%E7%9F%A5%E5%8E%89%E5%AE%B3%E5%85%B3%E7%B3%BB%E9%80%89%E6%88%BF%E5%AD%90zf%E9%80%89%E5%86%9C%E4%BA%A7%E5%93%81">屁股决定脑袋，人民不知厉害关系选房子，zf选农产品</a></li><li><a href="#%E5%90%84%E4%B8%AA%E9%98%B6%E5%B1%82%E7%9A%84%E4%BD%8F%E6%88%BF%E9%97%AE%E9%A2%98%E9%83%BD%E5%AE%89%E6%8E%92%E7%9A%84%E5%A6%A5%E5%A6%A5%E7%9A%84">各个阶层的住房问题都安排的妥妥的</a></li><li><a href="#%E9%A1%B6%E5%B1%82%E7%9A%84%E5%B2%81%E6%9C%88%E9%9D%99%E5%A5%BD%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%BA%95%E5%B1%82%E7%9A%84%E8%B4%9F%E9%87%8D%E5%89%8D%E8%A1%8C">顶层的岁月静好来自于底层的负重前行</a></li><li><a href="#%E5%BA%95%E5%B1%82%E6%8C%87%E7%9A%84%E6%98%AF%E4%BD%93%E5%88%B6%E5%A4%96%E5%BA%95%E8%96%AA%E7%99%BD%E9%A2%86">底层指的是体制外底薪白领</a></li><li><a href="#%E8%B5%84%E9%87%91%E7%BB%88%E4%BC%9A%E6%B5%81%E5%90%91%E5%85%B7%E6%9C%89%E7%A8%80%E7%BC%BA%E6%80%A7%E7%9A%84%E8%B5%84%E4%BA%A7">资金终会流向具有稀缺性的资产</a></li><li><a href="#%E5%9C%9F%E5%9C%B0%E7%9A%84%E7%A8%80%E7%BC%BA%E5%86%B3%E5%AE%9A%E4%BA%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E6%B0%B8%E8%BF%9C%E4%B9%B0%E4%B8%8D%E8%B5%B7%E6%83%B3%E4%B9%B0%E7%9A%84%E6%88%BF%E5%AD%90">土地的稀缺决定了大多数人永远买不起想买的房子</a></li><li><a href="#%E4%B8%8D%E5%90%8C%E9%98%B6%E5%B1%82%E7%9A%84%E4%BA%BA%E5%AF%B9%E6%94%B6%E5%85%A5%E9%AB%98%E4%BD%8E%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E7%90%86%E8%A7%A3">不同阶层的人对收入高低有不同的理解</a></li><li><a href="#%E4%B8%80%E4%BA%8C%E7%BA%BF%E4%B9%B0%E6%88%BF%E5%8F%AA%E4%BC%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%9A%BE%EF%BC%8C%E6%9C%80%E7%BB%88%E7%A7%9F%E6%88%BF%E4%BC%9A%E6%88%90%E4%B8%BA%E4%B8%BB%E6%B5%81">一二线买房只会越来越难，最终租房会成为主流</a></li><li><a href="#%E4%BA%BA%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%AE%89%E8%BA%AB%E4%B9%8B%E6%89%80%E8%83%BD%E4%B9%B0%E6%97%A9%E4%B9%B0%E6%AF%94%E6%99%9A%E4%B9%B0%E5%A5%BD">人需要一个安身之所，能买早买比晚买好</a></li><li><a href="#%E8%82%A1%E5%B8%82">股市</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E6%88%BF%E4%BB%B7%E4%B8%8D%E6%B6%A8%E9%82%A3%E5%85%B6%E4%BB%96%E4%BA%A7%E5%93%81%E4%BC%9A%E6%80%8E%E4%B9%88%E6%B6%A8">如果房价不涨，那其他产品会怎么涨</a></li><li><a href="#zf%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%85%AC%E7%A7%9F%E6%88%BF%E6%8E%A7%E5%88%B6%E7%A7%9F%E6%88%BF%E5%B8%82%E5%9C%BA">zf如何利用公租房控制租房市场</a></li><li><a href="#%E5%9F%8E%E4%B8%AD%E6%9D%91%E4%B8%8D%E4%BC%9A%E9%95%BF%E6%9C%9F%E5%AD%98%E5%9C%A8">城中村不会长期存在</a></li><li><a href="#%E4%B8%89%E5%9B%9B%E7%BA%BF%E5%9F%8E%E5%B8%82%E7%9A%84%E6%9C%AA%E6%9D%A5">三四线城市的未来</a></li><li><a href="#%E6%88%BF%E7%A7%9F%E4%BB%B7%E6%A0%BC%E6%B6%A8%E4%B8%8D%E4%B8%8A%E5%8E%BB%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%B9%B0%E6%88%BF%E8%BF%98%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9C%89%E5%B8%8C%E6%9C%9B">房租价格涨不上去，本质是买房还看起来有希望</a></li><li><a href="#%E7%A8%80%E7%BC%BA%E6%88%BF%E7%9A%84%E4%BB%B7%E6%A0%BC%E6%B0%B8%E8%BF%9C%E6%B6%A8">稀缺房的价格永远涨</a></li><li><a href="#%E7%B2%AE%E9%A3%9F%E5%92%8C%E6%88%BF%E5%AD%90%E7%9A%84%E4%B8%8D%E5%90%8C%E6%98%AF%E6%88%BF%E5%AD%90%E6%97%A0%E6%B3%95%E5%92%8C%E5%9C%9F%E5%9C%B0%E5%89%A5%E7%A6%BB">粮食和房子的不同是，房子无法和土地剥离</a></li><li><a href="#%E8%B4%AD%E4%B9%B0%E6%88%BF%E4%BB%B7%E5%9F%BA%E6%95%B0%E4%BD%8E%E7%9A%84%E7%9C%81%E4%BC%9A%E5%9F%8E%E5%B8%82%E6%80%8E%E4%B9%88%E9%83%BD%E4%B8%8D%E4%BC%9A%E4%BA%8F%E7%9A%84">购买房价基数低的省会城市，怎么都不会亏的</a></li><li><a href="#%E6%88%BF%E5%9C%B0%E4%BA%A7%E6%98%AF%E8%B5%84%E6%9C%AC%E5%B8%82%E5%9C%BA%E8%BF%98%E6%98%AF%E5%AE%9E%E4%BD%93%E7%BB%8F%E6%B5%8E">房地产是资本市场还是实体经济？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%82%BB%E7%A9%BA">什么是傻空</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E4%B9%B0%E4%B8%8D%E8%B5%B7%E6%88%BF">什么是真买不起房</a></li><li><a href="#%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90%E5%A6%82%E6%9E%9C%E7%9C%8B%E4%B8%8D%E6%87%82%E4%B8%80%E5%AE%9A%E6%98%AF%E6%B2%A1%E6%9C%89%E6%8A%93%E4%BD%8F%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8">具体情况具体分析，如果看不懂，一定是没有抓住问题本质</a></li><li><a href="#%E6%A1%82%E6%9E%97-vs-%E5%8D%97%E5%AE%81">桂林 vs 南宁</a></li><li><a href="#%E5%85%AC%E7%A7%9F%E6%88%BF%E7%9A%84%E9%87%8F%E7%BA%A7%E4%B8%8D%E4%BC%9A%E5%86%B2%E5%87%BB%E5%88%B0%E5%95%86%E5%93%81%E6%88%BF%E5%B8%82%E5%9C%BA">公租房的量级不会冲击到商品房市场</a></li><li><a href="#%E8%B4%B5%E9%98%B3%E8%B5%84%E6%BA%90%E7%9A%84%E7%A8%80%E7%BC%BA%E5%AF%BC%E8%87%B4%E6%9D%83%E8%B4%B5%E6%9B%B4%E5%AE%B9%E6%98%93%E5%9E%84%E6%96%AD%E9%80%9A%E8%BF%87%E4%BD%8E%E6%94%B6%E5%85%A5%E9%AB%98%E7%89%A9%E4%BB%B7%E7%9A%84%E6%96%B9%E5%BC%8F%E5%89%A5%E5%89%8A%E5%BA%95%E5%B1%82%E7%BE%A4%E4%BD%93">贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体</a></li><li><a href="#%E9%87%8D%E5%BA%86%E9%AB%98%E5%B1%82%E5%92%8C%E5%88%AB%E5%A2%85%E6%80%8E%E4%B9%88%E9%80%89">重庆：高层和别墅怎么选？</a></li><li><a href="#%E8%B4%A7%E5%B8%81%E8%B4%AC%E5%80%BC">货币贬值</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BE%8E%E5%9B%BD%E4%BA%BA%E5%B7%A5%E9%AB%98%E4%BA%8E%E4%B8%AD%E5%9B%BD%E4%BD%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%95%86%E5%93%81%E7%9A%84%E7%89%A9%E4%BB%B7%E5%8D%B4%E4%BD%8E%E4%BA%8E%E4%B8%AD%E5%9B%BD">为什么美国人工高于中国，但大多数商品的物价却低于中国</a></li><li><a href="#%E8%BF%98%E8%83%BD%E4%B8%8A%E8%BD%A6%E7%9A%84%E8%B5%B6%E7%B4%A7%E4%B8%8A%E8%BD%A6">还能上车的赶紧上车</a></li><li><a href="#%E6%AD%A6%E6%B1%89%E5%9F%8E%E5%B8%82%E5%8F%91%E5%B1%95%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%BE%80%E5%BE%80%E5%92%8C%E6%88%BF%E4%BB%B7%E7%9A%84%E5%8D%87%E5%80%BC%E7%A9%BA%E9%97%B4%E6%88%90%E6%AD%A3%E6%AF%94">武汉：城市发展空间的大小，往往和房价的升值空间成正比</a></li><li><a href="#%E6%9D%83%E5%88%A9%E8%AE%A9%E9%9D%A9%E6%97%8F%E6%88%90%E4%B8%BA%E8%8B%97%E6%97%8F%E7%9A%84%E4%B8%80%E6%94%AF">权利让革族成为苗族的一支</a></li><li><a href="#%E6%88%BF%E4%BB%B7%E6%98%AF%E5%90%A6%E4%BC%9A%E8%B7%8C%E5%A6%82%E6%9E%9C%E4%BC%9A%E4%BC%9A%E6%80%8E%E4%B9%88%E8%B7%8C">房价是否会跌，如果会，会怎么跌</a></li><li><a href="#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E6%98%AF%E5%87%8F%E7%BC%93%E7%81%AD%E4%BA%A1%E6%9C%80%E5%A5%BD%E7%9A%84%E8%89%AF%E8%8D%AF">通货膨胀是减缓灭亡最好的良药</a></li><li><a href="#%E8%B4%A7%E5%B8%81%E4%BE%9B%E5%BA%94%E4%B8%8D%E8%B6%B3%E6%98%AF%E6%98%8E%E6%9C%9D%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%8E%9F%E5%9B%A0">货币供应不足是明朝的真正原因</a></li><li><a href="#%E7%BB%8F%E6%B5%8E%E9%97%AE%E9%A2%98%E6%98%AF%E5%AF%BC%E8%87%B4%E6%B8%85%E6%9C%9D%E7%81%AD%E4%BA%A1">经济问题是导致清朝灭亡</a></li><li><a href="#%E6%88%BF%E4%BA%A7%E6%8A%95%E8%B5%84%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE">房产投资的几点建议</a></li><li><a href="#%E4%BA%BA%E6%B0%91%E5%B8%81%E5%AF%B9%E5%A4%96%E5%8D%87%E5%80%BC%E5%AF%B9%E5%86%85%E8%B4%AC%E5%80%BC">人民币对外升值，对内贬值</a></li><li><a href="#%E5%8D%97%E5%AE%81%E4%B9%B0%E6%88%BF%E5%BB%BA%E8%AE%AE">南宁买房建议</a></li><li><a href="#%E7%BB%8F%E6%B5%8E%E9%80%82%E7%94%A8%E6%88%BF%E9%83%BD%E6%98%AF%E5%86%85%E9%83%A8%E5%88%86%E9%85%8D%E7%9A%84">经济适用房都是内部分配的</a></li><li><a href="#%E6%99%AE%E9%80%9A%E4%BA%BA%E6%80%8E%E4%B9%88%E5%8A%9E%E5%B0%BD%E6%97%A9%E4%B9%B0%E6%88%BF%E5%8A%AA%E5%8A%9B%E6%8C%A3%E9%92%B1%E6%8A%B5%E5%BE%A1%E9%80%9A%E8%83%80">普通人怎么办：尽早买房，努力挣钱抵御通胀</a></li><li><a href="#%E6%88%BF%E4%BB%B7%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%BE%88%E5%A4%9A%E4%B8%8A%E4%B8%8B%E6%B3%A2%E5%8A%A8">房价会出现很多上下波动</a></li><li><a href="#%E4%B9%B0%E6%88%BF%E6%97%B6%E6%9C%BA%E7%9A%84%E9%80%89%E6%8B%A9%E7%9C%9FTM%E5%8E%89%E5%AE%B3%E8%BF%99%E7%AB%9F%E7%84%B6%E6%98%AF2010%E5%B9%B4%E7%9A%84%E5%BB%BA%E8%AE%AE%E5%8F%AF%E6%81%A8%E7%9A%84%E6%98%AF2020%E5%B9%B4%E6%89%8D%E7%9C%8B%E5%88%B0">买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）</a></li><li><a href="#%E6%94%B6%E5%85%A5%E5%88%86%E9%85%8D%E6%94%B9%E9%9D%A9%E8%B7%9F%E4%BD%93%E5%88%B6%E5%A4%96%E7%9A%84%E4%BA%BA%E6%B2%A1%E5%85%B3%E7%B3%BB">收入分配改革跟体制外的人没关系</a></li><li><a href="#%E4%BD%93%E5%88%B6%E5%A4%96%E7%9A%84%E4%BA%BA%E8%A6%81%E6%97%A9%E6%97%A9%E8%80%83%E8%99%91%E5%85%BB%E8%80%81%E9%97%AE%E9%A2%98">体制外的人要早早考虑养老问题</a></li><li><a href="#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%92%8C%E7%99%BD%E7%97%B4%E4%BA%89%E8%BE%A9%E5%9B%A0%E4%B8%BA%E4%BB%96%E4%BC%9A%E6%8A%8A%E4%BD%A0%E7%9A%84%E6%99%BA%E5%95%86%E6%8B%89%E5%88%B0%E5%92%8C%E4%BB%96%E5%90%8C%E4%B8%80%E6%B0%B4%E5%B9%B3%E7%84%B6%E5%90%8E%E7%94%A8%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%89%93%E8%B4%A5%E4%BD%A0">永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你</a></li><li><a href="#%E5%BD%93%E4%B8%AA%E5%86%9C%E6%B0%91%E4%B9%9F%E8%A6%81%E6%87%82%E6%94%BF%E7%AD%96%E8%A6%81%E9%A1%BA%E6%94%BF%E7%AD%96%E8%80%8C%E4%B8%BA">当个农民也要懂政策，要顺政策而为</a></li><li><a href="#%E5%AD%98%E9%92%B1%E4%B8%8D%E5%A6%82%E5%AD%98%E8%B5%84%E4%BA%A7%E9%92%B1%E4%BC%9A%E8%B4%AC%E5%80%BC%E8%B5%84%E4%BA%A7%E4%BC%9A%E5%8D%87%E5%80%BC">存钱不如存资产，钱会贬值，资产会升值</a></li><li><a href="#%E6%88%BF%E5%AD%90%E8%B6%8A%E6%97%A9%E4%B9%B0%E8%B6%8A%E5%A5%BDzf%E6%83%B3%E9%92%B1%E6%83%B3%E7%96%AF%E4%BA%86">房子越早买越好，zf想钱想疯了</a></li><li><a href="#%E5%88%A9%E7%9B%8A%E6%89%8D%E6%98%AFzf%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%8C%87%E6%8C%A5%E6%A3%92">利益才是zf行为的指挥棒</a></li><li><a href="#%E5%BB%BA%E8%AE%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E5%BB%BA%E7%AB%8B%E5%9C%A8%E4%B8%A5%E8%82%83%E8%80%83%E5%AF%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A">建议一定是建立在严肃考察的基础上</a></li><li><a href="#%E7%9F%B3%E5%AE%B6%E5%BA%84">石家庄</a></li><li><a href="#%E6%8A%95%E8%B5%84%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E6%98%AF%E7%A8%80%E7%BC%BA%E6%80%A7%E4%B9%B0%E6%88%BF%E9%A6%96%E9%80%89%E5%85%AC%E5%8A%A1%E5%91%98%E5%B0%8F%E5%8C%BA">投资最重要的是稀缺性，买房首选公务员小区</a></li><li><a href="#%E8%BF%9C%E7%A6%BB%E5%9E%83%E5%9C%BE%E4%BA%BA">远离垃圾人</a></li><li><a href="#%E9%AB%98%E6%88%BF%E4%BB%B7%E6%88%96%E8%AE%B8%E6%9C%89%E5%A4%A9%E4%BC%9A%E5%B4%A9%E7%9B%98%E4%BD%86%E4%BD%A0%E7%AD%89%E4%B8%8D%E5%88%B0%E9%82%A3%E4%B8%80%E5%A4%A9">高房价或许有天会崩盘，但你等不到那一天</a></li><li><a href="#%E6%88%BF%E5%AD%90%E4%B8%8D%E4%BB%85%E8%A6%81%E6%97%A9%E4%B9%B0%E8%80%8C%E4%B8%94%E6%9C%89%E8%83%BD%E5%8A%9B%E7%9A%84%E8%AF%9D%E4%B8%8D%E8%A6%81%E6%80%95%E5%8E%8B%E5%8A%9B%E4%BA%89%E5%8F%96%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D">房子不仅要早买，而且有能力的话不要怕压力，争取一步到位</a></li><li><a href="#%E9%87%91%E8%9E%8D%E6%9D%A0%E6%9D%86%E6%98%AF%E7%82%92%E6%88%BF%E8%B5%9A%E9%92%B1%E7%9A%84%E6%94%BE%E5%A4%A7%E5%99%A8">金融杠杆是炒房赚钱的放大器</a></li><li><a href="#%E8%A6%81%E7%94%A8%E5%8F%91%E5%B1%95%E7%9A%84%E7%9C%BC%E5%85%89%E7%9C%8B%E9%97%AE%E9%A2%98%E5%8F%AA%E8%A6%81%E5%8A%AA%E5%8A%9B%E5%8F%AA%E4%BC%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A5%BD%E8%B6%8A%E6%9D%A5%E8%B6%8A%E8%BD%BB%E6%9D%BE">要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松</a></li><li><a href="#%E6%80%A7%E6%A0%BC%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90">性格决定命运</a></li><li><a href="#2012%E5%B9%B4%E4%B8%8D%E5%8F%96%E6%B6%88%E8%B0%83%E6%8E%A7%E8%BF%98%E6%9C%89%E6%88%BF%E4%BB%B7%E7%BB%B4%E7%A8%B3%E9%A1%BA%E5%88%A9%E6%8D%A2%E5%B1%8A%E8%80%83%E8%99%91">2012年不取消调控，还有房价维稳顺利换届考虑</a></li><li><a href="#%E6%B4%BC%E5%9C%B0%E6%9C%80%E7%BB%88%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%A1%AB%E5%B9%B3%E5%A4%9A%E6%95%B0%E5%9F%8E%E5%B8%82%E6%98%AF%E6%97%A9%E4%B9%B0%E8%83%9C%E4%BA%8E%E6%99%9A%E4%B9%B0">洼地最终都会被填平，多数城市是早买胜于晚买</a></li><li><a href="#%E8%A5%BF%E9%83%A8">西部</a></li><li><a href="#%E7%9F%AD%E6%9C%9F%E6%B3%A2%E5%8A%A8%E5%B1%9E%E4%BA%8E%E6%AD%A3%E5%B8%B8%E7%8E%B0%E8%B1%A1%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E9%95%BF%E6%9C%9F%E8%B6%8B%E5%8A%BF">短期波动属于正常现象，需要关注的是长期趋势</a></li><li><a href="#%E9%A2%86%E5%AF%BC%E4%BA%BA%E7%9A%84%E6%99%BA%E6%85%A7%E5%92%8C%E6%89%8D%E5%B9%B2%E5%86%B3%E5%AE%9A%E4%BA%86%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%91%BD%E8%BF%90%E7%BB%9F%E5%B8%85%E7%9A%84%E6%99%BA%E6%85%A7%E5%92%8C%E6%89%8D%E5%B9%B2%E5%86%B3%E5%AE%9A%E4%BA%86%E5%86%9B%E9%98%9F%E7%9A%84%E5%91%BD%E8%BF%90%E8%80%8C%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%99%BA%E6%85%A7%E5%92%8C%E6%89%8D%E5%B9%B2%E5%86%B3%E5%AE%9A%E4%BA%86%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%91%BD%E8%BF%90">领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运</a></li><li><a href="#%E5%AF%B9%E4%BA%8E%E5%85%B7%E5%A4%87%E6%8A%95%E8%B5%84%E5%B1%9E%E6%80%A7%E7%9A%84%E5%95%86%E5%93%81%E4%BE%9B%E6%B1%82%E5%85%B3%E7%B3%BB%E6%98%AF%E6%8C%87%E8%B4%A7%E5%B8%81%E4%B8%8E%E5%95%86%E5%93%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">对于具备投资属性的商品，供求关系是指货币与商品之间的关系</a></li><li><a href="#%E6%97%A9%E4%B9%B0%E7%9A%84%E9%A3%8E%E9%99%A9%E5%B0%8F%E4%BA%8E%E6%99%9A%E4%B9%B0">早买的风险小于晚买</a></li><li><a href="#%E5%B0%8F%E5%BC%80%E5%8F%91%E5%95%86%E7%9A%84%E6%88%BF%E5%AD%90%E8%83%BD%E4%B8%8D%E8%83%BD%E4%B9%B0">小开发商的房子能不能买？</a></li><li><a href="#%E5%A4%A7%E5%85%B4%E5%9C%9F%E6%9C%A8%E6%90%9E%E5%BB%BA%E8%AE%BE%E7%9A%84%E5%9F%8E%E5%B8%82%E6%88%BF%E4%BB%B7%E9%83%BD%E5%BA%95%E4%B8%8D%E4%BA%86">大兴土木搞建设的城市，房价都底不了</a></li><li><a href="#%E5%8C%97%E4%BA%AC%E8%80%81%E5%BC%8F%E7%A0%96%E6%B7%B7%E6%9D%BF%E6%A5%BC%E7%9A%84%E6%9C%80%E7%BB%88%E5%91%BD%E8%BF%90">北京老式砖混板楼的最终命运？</a></li><li><a href="#%E6%8A%8A%E6%88%BF%E4%B9%B0%E5%9C%A8zf%E8%BE%B9%E5%B7%AE%E4%B8%8D%E4%BA%86">把房买在zf边，差不了</a></li><li><a href="#%E5%A4%A9%E5%AD%90%E8%84%9A%E4%B8%8B%E4%BA%8C%E6%89%8B%E8%80%81%E6%88%BF%E4%B9%B0%E5%BE%97%E5%A5%BD%E6%8B%86%E8%BF%81%E8%A1%A5%E5%81%BF%E5%B0%91%E4%B8%8D%E4%BA%86">天子脚下：二手老房买得好，拆迁补偿少不了</a></li><li><a href="#3%E4%B8%87%E5%85%A5%E6%89%8B%E5%8C%97%E4%BA%AC%E5%9B%9B%E7%8E%AF%E4%BD%A0%E4%B9%9F%E6%98%AF%E5%B9%B8%E8%BF%90%E7%9A%84">3万入手北京四环，你也是幸运的</a></li><li><a href="#%E5%90%9B%E4%B8%BA%E8%B4%B5%E5%95%86%E4%BA%BA%E6%8A%80%E5%B7%A5%E6%AC%A1%E4%B9%8B%E5%86%9C%E6%B0%91%E4%B8%BA%E8%BD%BB%E6%89%93%E5%B7%A5%E4%BA%BA%E4%B8%BA%E5%BA%95">君为贵，商人、技工次之，农民为轻，打工人为底</a></li><li><a href="#10%E5%B9%B4%E7%9A%84%E8%B0%83%E6%8E%A7%E5%92%8C08%E5%B9%B4%E8%B0%83%E6%8E%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D%E6%9C%BA%E4%BC%9A">10年的调控和08年调控的区别、带来的影响、机会</a></li><li><a href="#%E5%8E%86%E5%8F%B2%E6%80%BB%E6%98%AF%E6%83%8A%E4%BA%BA%E7%9A%84%E7%9B%B8%E4%BC%BC">历史总是惊人的相似</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E6%88%BF%E8%B4%B7">关于房贷</a></li><li><a href="#%E4%B9%B0%E5%8D%96%E5%95%86%E5%93%81%E6%88%BF%E4%BC%9A%E9%80%90%E6%B8%90%E5%8F%98%E6%88%90%E5%AF%8C%E4%BA%BA%E7%9A%84%E6%B8%B8%E6%88%8F">买卖商品房会逐渐变成富人的游戏</a></li><li><a href="#zf%E8%BF%98%E6%98%AF%E6%9B%B4%E5%9C%A8%E6%84%8F%E5%86%9C%E6%B0%91%E9%97%AE%E9%A2%98">zf还是更在意农民问题</a></li><li><a href="#%E6%B2%BB%E5%9B%BD%E9%9C%80%E8%A6%81%E7%94%A8%E8%B4%AA%E5%AE%98%E5%8F%8D%E8%B4%AA%E5%AE%98">治国需要用贪官、反贪官</a></li><li><a href="#%E4%BA%8C%E7%BA%BF%E5%9F%8E%E5%B8%82%E5%85%B8%E5%9E%8B%E4%BB%A3%E8%A1%A8">二线城市典型代表</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E5%95%86%E9%93%BA%E5%92%8C%E4%BD%8F%E5%AE%85%E6%8A%95%E8%B5%84">关于商铺和住宅投资</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E6%88%BF%E4%BA%A7%E8%B0%83%E6%8E%A7">关于房产调控</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E6%88%BF%E4%BA%A7%E7%A8%8E">关于房产税</a></li><li><a href="#%E8%80%81%E5%85%AC%E6%88%BF%E7%9A%84%E6%8B%86%E8%BF%81%E9%97%AE%E9%A2%98">老公房的拆迁问题</a></li><li><a href="#%E6%8A%95%E8%B5%84%E6%96%B0%E6%88%BF%E8%BF%98%E6%98%AF%E8%80%81%E5%85%AC%E6%88%BF">投资新房还是老公房</a></li><li><a href="#%E9%AB%98%E7%AB%AF%E7%9B%98%E6%9C%89%E6%88%BF%E4%BB%B7%E5%B8%A6%E5%8A%A8%E4%BD%9C%E7%94%A8">高端盘有房价带动作用</a></li><li><a href="#%E4%B9%B0%E6%88%BF%E5%92%8C%E6%B2%A1%E4%B9%B0%E6%88%BF%E7%9A%84%E5%B7%AE%E8%B7%9D">买房和没买房的差距</a></li><li><a href="#%E6%88%BF%E4%BA%A7%E4%BA%A4%E6%98%93%E5%8E%86%E5%8F%B2">房产交易历史</a></li><li><a href="#%E5%A5%91%E7%A8%8E%E7%9A%84%E5%8E%86%E5%8F%B2">契税的历史</a></li><li><a href="#%E5%BB%89%E7%A7%9F%E6%88%BF%E7%9A%84%E5%8E%86%E5%8F%B2">廉租房的历史</a></li><li><a href="#%E5%8E%86%E5%8F%B2%E4%B8%8A%E4%B9%B0%E6%88%BF%E6%9C%80%E5%A5%BD%E7%9A%84%E6%9C%9D%E4%BB%A3">历史上买房最好的朝代</a></li><li><a href="#%E6%9C%AA%E6%9D%A5%E6%88%BF%E5%9C%B0%E4%BA%A7%E5%B8%82%E5%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95">未来房地产市场的发展</a></li><li><a href="#%E6%88%BF%E4%BA%A7%E5%88%B0%E6%9C%9F">房产到期</a></li><li><a href="#%E4%B9%B0%E5%AD%A6%E5%8C%BA%E6%88%BF%E9%97%AE%E9%A2%98">买学区房问题</a></li><li><a href="#%E5%8E%86%E5%8F%B2%E7%9A%84%E7%BB%93%E5%B1%80">历史的结局</a></li><li><a href="#%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5">人口普查</a></li><li><a href="#%E6%98%86%E5%B1%B1%E6%88%BF%E4%BB%B7%E5%88%86%E6%9E%90%E4%B8%8E%E4%B9%B0%E6%88%BF">昆山房价分析与买房</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E7%A7%9F%E5%94%AE%E6%AF%94%E8%BF%99%E4%B9%88%E4%BD%8E%E2%80%94%E5%90%8C%E5%B0%8F%E5%8C%BA%E4%B9%B0%E4%B8%80%E5%A5%97%E5%A4%A7%E8%BF%98%E6%98%AF%E4%B8%A4%E5%A5%97%E5%B0%8F">为什么现在租售比这么低 &amp; 同小区买一套大还是两套小</a></li><li><a href="#%E4%B9%B0%E6%88%BF%E9%9A%BE%E4%B9%8B%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%E4%B9%A1%E2%80%94%E6%8B%89%E7%BE%8E%E4%BA%BA%E8%BF%87%E5%BE%97%E6%AF%94%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E5%A5%BD">买房难之回不去的乡 &amp; 拉美人过得比你想象的好</a></li><li><a href="#%E7%A7%9F%E6%88%BF%E7%9A%84%E8%8B%A6">租房的苦</a></li><li><a href="#%E5%8C%97%E4%BA%AC%E8%A5%BF%E4%B8%89%E6%97%97">北京西三旗</a></li><li><a href="#%E4%B9%B0%E6%88%BF%E4%BA%89%E5%8F%96%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D">买房争取一步到位</a></li><li><a href="#%E6%94%B6%E5%85%A5%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%AE%B6%E5%BA%AD%E5%A6%82%E4%BD%95%E4%B9%B0%E6%88%BF">收入稳定的家庭如何买房</a></li><li><a href="#%E5%8C%97%E4%BA%AC%E5%9B%9E%E9%BE%99%E8%A7%82">北京回龙观</a></li><li><a href="#%E8%B4%B7%E6%AC%BE%E8%BF%98%E6%98%AF%E5%85%A8%E6%AC%BE">贷款还是全款</a></li><li><a href="#00%E5%90%8E%E7%9A%84%E4%B9%B0%E6%88%BF%E9%9C%80%E6%B1%82%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5">00后的买房需求从何而来</a></li><li><a href="#%E6%84%8F%E5%A4%A7%E5%88%A9%E7%9A%84%E4%BD%8F%E6%88%BF%E6%A8%A1%E5%BC%8F">意大利的住房模式</a></li><li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%AD%A6%E6%9C%AF">中国的学术</a></li><li><a href="#%E5%8C%97%E4%BA%AC%E8%BF%9C%E6%B4%8B%E5%B1%B1%E6%B0%B4">北京远洋山水</a></li><li><a href="#%E7%B2%BE%E8%8B%B1%E7%9A%84%E8%B5%84%E4%BA%A7">精英的资产</a></li><li><a href="#%E5%8C%97%E4%BA%AC%E4%B8%89%E7%8E%AF%E5%A1%94%E6%A5%BC">北京三环塔楼</a></li><li><a href="#%E6%99%AE%E9%80%9A%E4%BA%BA%E4%B9%B0%E6%88%BF%E7%9A%84%E6%9C%AA%E6%9D%A5">普通人买房的未来</a></li><li><a href="#%E5%8C%97%E4%BA%AC%E6%88%BF%E4%BB%B7%E8%B6%85%E9%A6%99%E6%B8%AF">北京房价超香港</a></li><li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%96%B0%E9%97%BB%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%B2%BE%E8%8B%B1%E7%9A%84%E6%9C%89%E9%92%B1%E6%98%AF%E4%BD%A0%E6%83%B3%E8%B1%A1%E4%B8%8D%E5%88%B0%E7%9A%84">中国的新闻不可信，精英的有钱是你想象不到的</a></li><li><a href="#40%E5%B9%B4%E7%9A%84%E5%95%86%E4%BD%8F%E6%88%BF%E6%B2%A1%E6%9C%8970%E5%B9%B4%E7%9A%84%E4%BD%8F%E5%AE%85%E6%9C%89%E6%8A%95%E8%B5%84%E4%BB%B7%E5%80%BC">40年的商住房没有70年的住宅有投资价值</a></li><li><a href="#%E9%99%90%E8%B4%B7%E5%AF%B9%E7%B2%BE%E8%8B%B1%E6%B2%A1%E7%94%A8">限贷对精英没用</a></li><li><a href="#%E5%A4%96%E6%B1%87%E7%AE%A1%E5%88%B6%E5%86%B3%E5%AE%9A%E4%BA%86%E5%A4%A7%E9%83%A8%E5%88%86%E6%9C%89%E9%92%B1%E4%BA%BA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%9B%BD%E5%86%85%E6%8A%95%E8%B5%84">外汇管制决定了大部分有钱人只能在国内投资</a></li><li><a href="#%E5%A4%96%E5%9B%BD%E5%9B%BD%E7%B1%8D%E5%9C%A8%E4%B8%AD%E5%9B%BD%E7%94%9F%E6%B4%BB%E6%98%AF%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%80%89%E6%8B%A9">外国国籍在中国生活是更好的选择</a></li><li><a href="#%E5%88%86%E6%9C%9F%E4%BB%98%E6%AC%BE%E4%B9%B0%E6%88%BF%E5%A6%82%E6%9E%9C%E6%88%BF%E4%BB%B7%E4%B8%8A%E6%B6%A8%E5%BE%88%E5%AE%B9%E6%98%93%E6%AF%81%E7%BA%A6--%E8%87%AA%E4%BD%8F%E8%A6%81%E9%80%89%E5%A4%A7%E5%93%81%E7%89%8C%E5%BC%80%E5%8F%91%E5%95%86">分期付款买房，如果房价上涨，很容易毁约 &amp; 自住要选大品牌开发商</a></li><li><a href="#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E5%92%8C%E6%88%BF%E4%BB%B7%E7%9A%84%E5%85%B3%E7%B3%BB">通货膨胀和房价的关系</a></li><li><a href="#%E5%8D%97%E4%BA%AC%E4%B9%B0%E6%88%BF%E5%88%86%E6%9E%90--%E4%B9%B0%E6%88%BF%E8%A6%81%E5%81%9A%E5%A5%BD%E8%B0%83%E6%9F%A5%E5%88%86%E6%9E%90%E5%B7%A5%E4%BD%9C">南京买房分析 &amp; 买房要做好调查分析工作</a></li><li><a href="#%E5%8C%97%E4%BA%AC%E5%8D%8E%E6%B8%85%E5%98%89%E5%9B%AD">北京华清嘉园</a></li><li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%9D%E4%BB%A3%E6%9B%B4%E6%9B%BF">中国的朝代更替</a></li><li><a href="#%E4%B8%AD%E5%9B%BD%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E5%8D%B0%E9%92%9E%E5%90%97">中国可以无限印钞吗</a></li><li><a href="#%E8%AF%BB%E5%8F%B2%E8%AF%BB%E7%9A%84%E4%B8%8D%E6%98%AF%E6%95%85%E4%BA%8B%E8%BF%98%E6%98%AF%E6%89%BE%E5%8E%86%E5%8F%B2%E8%A7%84%E5%BE%8B%E4%BB%A5%E5%8F%A4%E9%89%B4%E4%BB%8A">读史读的不是故事，还是找历史规律，以古鉴今</a></li><li><a href="#%E6%AF%9B%E5%A4%AA%E9%98%B3%E5%BE%80%E4%BA%8B">毛太阳往事</a></li><li><a href="#%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%85%B4">北京大兴</a></li><li><a href="#%E8%B4%B5%E9%98%B3">贵阳</a></li><li><a href="#%E5%AF%8C%E4%BA%BA%E8%B6%8A%E5%AF%8C%E7%A9%B7%E4%BA%BA%E8%B6%8A%E7%A9%B7">富人越富、穷人越穷</a></li><li><a href="#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E7%9A%84%E5%BD%A2%E6%88%90%E5%8E%9F%E5%9B%A0">通货膨胀的形成原因</a></li><li><a href="#%E6%B7%B1%E5%9C%B3--%E6%98%86%E6%98%8E%E4%BB%87%E4%B9%A6%E8%AE%B0%E2%80%94-%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E4%BD%93%E5%88%B6%E5%86%85%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E4%BD%93%E5%88%B6%E5%A4%96%E8%87%AA%E6%B1%82%E5%A4%9A%E7%A6%8F">深圳 &amp; 昆明仇书记 &amp; 通货膨胀体制内高枕无忧、体制外自求多福</a></li><li><a href="#%E9%95%BF%E6%98%A5">长春</a></li><li><a href="#%E4%BD%9B%E5%B1%B1">佛山</a></li><li><a href="#%E9%A6%96%E4%BB%98%E6%8F%90%E9%AB%98%E7%9A%84%E9%80%BB%E8%BE%91">首付提高的逻辑</a></li><li><a href="#%E5%9B%9B%E7%BA%BF%E5%9F%8E%E5%B8%82">四线城市</a></li><li><a href="#%E8%8B%8F%E5%B7%9E%E5%B7%A5%E4%B8%9A%E5%9B%AD">苏州工业园</a></li><li><a href="#%E4%BD%8F%E6%88%BF%E5%85%AC%E7%A7%AF%E9%87%91%E5%88%A9%E7%8E%87">住房公积金利率</a></li><li><a href="#%E6%B5%8E%E5%8D%97--%E5%A4%A7%E8%A7%84%E5%BE%8B%E6%8B%86%E8%BF%81%E7%9A%84%E5%9F%8E%E5%B8%82%E6%88%BF%E4%BB%B7%E4%B8%8D%E4%BC%9A%E4%B8%8B%E9%99%8D">济南 &amp; 大规律拆迁的城市房价不会下降</a></li><li><a href="#%E5%85%AC%E5%8A%A1%E5%91%98%E5%B0%8F%E5%8C%BA%E7%89%9B%E9%80%BC">公务员小区牛逼</a></li><li><a href="#%E6%88%BF%E5%B1%8B%E6%9C%9D%E5%90%91%E5%8F%AA%E8%A6%81%E4%B8%8D%E6%98%AF%E7%BA%AF%E5%8C%97%E8%A5%BF%E5%B0%B1%E8%A1%8C--%E4%B9%B0%E6%88%BF%E9%A6%96%E9%80%89%E5%B8%82%E4%B8%AD%E5%BF%83%E5%85%AC%E5%9B%AD%E5%9C%B0%E4%BA%A7">房屋朝向只要不是纯北西就行 &amp; 买房首选市中心、公园地产</a></li><li><a href="#zf%E6%90%AC%E8%BF%81">zf搬迁</a></li><li><a href="#%E4%BF%84%E7%BD%97%E6%96%AF">俄罗斯</a></li><li><a href="#%E7%8F%A0%E6%B5%B7--%E5%94%AF%E4%B8%80%E8%87%AA%E4%BD%8F%E6%88%BF%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%8A%95%E8%B5%84--%E8%B0%83%E6%8E%A7%E6%98%AF%E6%9C%80%E4%BD%B3%E7%9A%84%E9%80%89%E6%88%BF%E6%97%B6%E6%9C%BA">珠海 &amp; 唯一自住房不只是投资 &amp; 调控是最佳的选房时机</a></li><li><a href="#%E7%BB%8F%E6%B5%8E%E5%B4%A9%E6%BA%83%E6%9C%80%E5%90%8E%E6%8E%A5%E7%9B%98%E7%9A%84%E6%98%AF%E8%80%81%E7%99%BE%E5%A7%93">经济崩溃，最后接盘的是老百姓</a></li><li><a href="#%E5%91%BD%E8%BF%90%E4%B9%8B%E7%9F%9B">命运之矛</a></li><li><a href="#%E9%99%A4%E9%9D%9E%E5%A4%96%E6%97%8F%E5%85%A5%E4%BE%B5%E6%88%96%E5%85%A8%E5%9B%BD%E5%A4%A7%E9%A5%A5%E8%8D%92%EF%BC%8C%E5%90%A6%E5%88%99%E5%8F%8C%E8%BD%A8%E5%88%B6%E5%86%B3%E5%AE%9A%E4%BA%86%E6%88%BF%E4%BB%B7%E4%B8%8D%E4%BC%9A%E5%B4%A9%E7%9B%98">除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘</a></li><li><a href="#kkndme%E8%81%8A%E5%8C%97%E5%AE%8B%E5%94%90%E6%9C%9D">kkndme聊北宋、唐朝</a></li><li><a href="#%E5%AE%8B%E4%BB%A3%E6%88%BF%E5%A5%B4">宋代房奴</a></li><li><a href="#ZG%E6%B0%91%E4%B8%BB">ZG民主</a></li><li><a href="#%E7%8E%8B%E5%AE%89%E7%9F%B3%E7%9A%84%E9%9D%92%E8%8B%97%E6%B3%95%E4%B9%8B%E5%9B%BD%E5%AE%B6%E5%87%BA%E6%94%BF%E7%AD%96%E7%9A%84%E5%8A%A8%E6%9C%BA">王安石的青苗法之国家出政策的动机</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A4%BE%E4%BC%9A%E5%85%AC%E5%B9%B3">什么是社会公平</a></li><li><a href="#%E8%BF%98%E6%98%AF%E6%9C%89%E5%BE%88%E5%A4%9A%E6%9C%89%E9%92%B1%E4%BA%BA">还是有很多有钱人</a></li><li><a href="#%E5%8F%8C%E8%BD%A8%E5%88%B6%E4%B9%8B%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%84%E7%A6%8F%E5%88%A9">双轨制之体制内的福利</a></li><li><a href="#%E5%BC%80%E5%8F%91%E5%95%86%E6%80%9D%E7%BB%B4">开发商思维</a></li><li><a href="#%E5%86%9C%E6%B0%91%E6%94%BF%E6%9D%83%E7%9A%84%E7%BC%BA%E7%82%B9">农民政权的缺点</a></li><li><a href="#%E9%83%91%E5%B7%9E%E6%9C%89%E5%89%8D%E6%99%AF">郑州有前景</a></li><li><a href="#%E5%85%AC%E5%9B%AD%E5%9C%B0%E4%BA%A7%E6%98%AF%E7%A8%80%E7%BC%BA%E8%B5%84%E6%BA%90">公园地产是稀缺资源</a></li><li><a href="#%E5%BC%A0%E7%8C%AE%E5%BF%A0%E5%B1%A0%E5%B7%9D">张献忠屠川</a></li><li><a href="#%E6%B4%AA%E7%A7%80%E5%85%A8%E9%BB%84%E5%B7%A2%E6%9D%8E%E8%87%AA%E6%88%90">洪秀全、黄巢、李自成</a></li><li><a href="#%E6%9C%B1%E5%85%83%E7%92%8B">朱元璋</a></li><li><a href="#%E6%9B%B9%E5%8F%82%E6%B2%BB%E5%9B%BD">曹参治国</a></li><li><a href="#%E6%99%81%E9%94%99">晁错</a></li><li><a href="#%E6%B0%91%E8%90%A5%E5%B0%8F%E4%BC%81%E4%B8%9A%E7%9A%84%E8%80%81%E6%9D%BF%E5%92%8C%E6%89%93%E5%B7%A5%E8%80%85">民营小企业的老板和打工者</a></li><li><a href="#%E9%83%AD%E8%A7%A3">郭解</a></li><li><a href="#2010%E5%B9%B4%E7%9A%84%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7">2010年的中国房地产</a></li><li><a href="#%E6%88%BF%E5%A5%B4%E7%AE%97%E4%B8%8D%E4%B8%8A%E4%B8%8D%E5%B9%B8%E7%9B%B8%E5%BD%93%E5%BD%93%E4%B8%8D%E4%BA%86%E6%89%8D%E7%AE%97">房奴算不上不幸，相当当不了才算</a></li><li><a href="#%E7%B2%BE%E8%8B%B1%E4%BA%BA%E7%BE%A4%E7%9A%84%E5%B9%B3%E5%9D%87%E6%94%B6%E5%85%A5%E5%86%B3%E5%AE%9A%E6%88%BF%E4%BB%B7">精英人群的平均收入决定房价</a></li><li><a href="#%E5%86%85%E5%9C%B0%E4%B8%8D%E6%98%AF%E9%A6%99%E6%B8%AF%E6%B5%B7%E5%8D%97">内地不是香港、海南</a></li><li><a href="#%E5%8E%86%E5%8F%B2%E6%98%AF%E4%B8%80%E9%9D%A2%E9%95%9C%E5%AD%90">历史是一面镜子</a></li><li><a href="#%E4%B9%B0%E6%88%BF%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%B0%E4%BD%8D%E6%AF%94%E8%BE%83%E5%A5%BD">买房一次性到位比较好</a></li><li><a href="#%E5%A4%96%E6%B1%87%E7%AE%A1%E5%88%B6">外汇管制</a></li><li><a href="#%E4%B8%80%E7%BA%BF%E5%92%8C%E4%BA%8C%E7%BA%BF">一线和二线</a></li><li><a href="#%E5%90%95%E5%90%8E%E7%AF%A1%E6%9D%83">吕后篡权</a></li><li><a href="#%E5%B0%8F%E4%BA%A7%E6%9D%83%E6%88%BF">小产权房</a></li><li><a href="#%E5%95%86%E9%93%BA%E5%92%8C%E4%BD%8F%E5%AE%85">商铺和住宅</a></li><li><a href="#%E4%BD%93%E5%88%B6%E5%86%85%E5%A4%96">体制内外</a></li><li><a href="#2010%E5%B9%B4%E7%9A%84%E4%B8%8A%E6%B5%B7">2010年的上海</a></li><li><a href="#%E4%B9%B0%E6%88%BF%E7%89%A9%E4%B8%9A%E4%B8%8E%E6%88%BF%E8%B4%B7">买房：物业与房贷</a></li><li><a href="#%E6%94%B6%E7%B4%A7%E4%BD%8F%E6%88%BF%E8%B4%B7%E6%AC%BE">收紧住房贷款</a></li><li><a href="#%E4%B9%B0%E6%88%BF%E7%89%A9%E4%B8%9A%E4%B8%8E%E6%88%BF%E8%B4%B7">买房：物业与房贷</a></li><li><a href="#%E5%A5%B8%E8%87%A3%E8%94%A1%E4%BA%AC">奸臣蔡京</a></li><li><a href="#%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%8428%E5%8E%9F%E5%88%99">体制内的28原则</a></li><li><a href="#%E8%B4%BE%E8%B0%8A">贾谊</a></li><li><a href="#kkndme-%E6%8E%A8%E8%8D%90%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B9%A6">kkndme 推荐的历史书</a></li><li><a href="#%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%A6%81%E6%97%A9%E4%B9%B0%E6%88%BF">年轻人要早买房</a></li><li><a href="#%E4%B8%8D%E8%A6%81%E4%BD%8E%E4%BC%B0%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80">不要低估通货膨胀</a></li><li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E4%B8%8E%E9%87%8D%E5%BA%86">二三线城市与重庆</a></li><li><a href="#%E5%9F%8E%E5%8C%BA%E5%92%8C%E9%83%8A%E5%8C%BA">城区和郊区</a></li><li><a href="#%E5%AE%88%E7%9D%80%E9%87%91%E7%A2%97%E8%A6%81%E9%A5%AD%E5%90%83">守着金碗要饭吃</a></li><li><a href="#%E4%BA%BA%E5%88%B6%E7%9A%84%E7%A4%BE%E4%BC%9A%E4%BA%BA%E5%B0%B1%E6%98%AF%E5%88%B6%E5%BA%A6">人制的社会，人就是制度</a></li><li><a href="#%E5%87%86%E5%85%AC%E5%8A%A1%E5%91%98%E7%9A%84%E5%A5%BD%E5%A4%84">准公务员的好处</a></li><li><a href="#%E5%B0%8F%E5%9F%8E%E5%B8%82%E6%88%BF%E4%BB%B7%E4%BC%9A%E5%9B%A0%E4%B8%BA%E4%BA%BA%E6%B0%91%E5%B8%81%E8%B4%AC%E5%80%BC%E6%B6%A8%E4%BB%B7%E4%BD%86%E4%BE%9D%E7%84%B6%E9%9A%BE%E5%8F%98%E7%8E%B0">小城市房价会因为人民币贬值涨价，但依然难变现</a></li><li><a href="#%E4%B8%80%E7%BA%BF%E6%9D%AD%E5%B7%9E">一线杭州</a></li><li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E7%9A%84%E5%8F%91%E5%B1%95%E9%9D%A0%E6%8B%86%E8%BF%81">二三线城市的发展靠拆迁</a></li><li><a href="#%E8%BD%AC%E7%AF%87%E6%96%87%E7%AB%A0%E4%B8%80%E4%B8%AA%E5%BF%BD%E6%82%A0%E4%BA%86%E5%87%A0%E4%BA%BF%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E4%BC%AA%E6%A6%82%E5%BF%B5%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7%E6%B3%A1%E6%B2%AB">转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”</a></li><li><a href="#%E6%8B%86%E8%BF%81%E8%A1%A5%E5%81%BF">拆迁补偿</a></li><li><a href="#%E5%9F%8E%E5%B8%82%E5%BA%95%E5%B1%82">城市底层</a></li><li><a href="#%E5%9E%84%E6%96%AD%E4%BC%81%E4%B8%9A">垄断企业</a></li><li><a href="#%E5%86%9C%E6%9D%91%E8%87%AA%E6%9D%A5%E6%B0%B4">农村自来水</a></li><li><a href="#%E8%A2%81%E7%9B%8E">袁盎</a></li><li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E9%80%89%E6%96%B0%E5%9F%8E%E8%BF%98%E6%98%AF%E8%80%81%E5%9F%8E">二三线城市，选新城还是老城</a></li><li><a href="#%E5%9C%A8%E4%B8%AD%E5%9B%BD%E6%99%AE%E9%80%9A%E4%BA%BA%E6%89%8B%E4%B8%8A%E9%97%B2%E9%92%B1%E4%B8%8D%E5%A4%9A%E7%9A%84%E4%BA%BA%E8%A2%AB%E5%89%A5%E5%89%8A">在中国，普通人手上闲钱不多的人被剥削</a></li><li><a href="#%E4%B8%89%E5%88%86%E5%A4%A9%E6%B3%A8%E5%AE%9A%E4%B8%83%E5%88%86%E9%9D%A0%E6%89%93%E6%8B%BC">三分天注定七分靠打拼</a></li><li><a href="#%E4%BA%BA%E7%9A%84%E5%89%8D%E7%A8%8B%E6%9C%89%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E6%8E%8C%E6%8F%A1%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%89%8B%E9%87%8C">人的前程有的时候不掌握在自己手里</a></li><li><a href="#%E6%B2%B3%E5%8D%97%E9%83%91%E5%B7%9E%E4%B8%8E%E6%B4%9B%E9%98%B3">河南郑州与洛阳</a></li><li><a href="#%E6%9D%AD%E5%B7%9E">杭州</a></li><li><a href="#%E8%A5%BF%E5%AE%89-%E4%B8%8E-%E9%87%8D%E5%BA%86">西安与重庆</a></li><li><a href="#%E8%B0%A2%E5%9B%BD%E4%B8%AD%E7%A9%BA%E7%BD%AE%E7%8E%87">谢国中「空置率」</a></li><li><a href="#%E6%89%93%E5%B7%A5%E4%B8%8D%E5%A6%82%E6%9C%89%E4%B8%80%E6%8A%80%E4%B9%8B%E9%95%BF%E7%9A%84%E5%B0%8F%E8%80%81%E6%9D%BF">打工不如有一技之长的小老板</a></li><li><a href="#%E4%B8%80%E7%BA%BF%E4%BA%8C%E7%BA%BF%E7%9A%84%E7%94%9F%E6%B4%BB">一线、二线的生活</a></li><li><a href="#%E8%AE%B2%E6%95%85%E4%BA%8B%E5%90%AB%E6%B2%99%E5%B0%84%E5%BD%B1ZG%E4%B9%8B%E6%88%BF%E5%AD%90%E4%B8%8D%E5%B1%9E%E4%BA%8E%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E">讲故事含沙射影ZG之房子不属于市场经济</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84%E6%94%BF%E7%AD%96">什么是好的政策</a></li><li><a href="#%E6%9D%8E%E5%95%86%E9%9A%90%E6%B8%A3%E7%94%B7%E7%A5%96%E5%B8%88%E7%88%B7">李商隐「渣男」祖师爷</a></li><li><a href="#%E8%A5%BF%E4%BA%94%E7%8E%AF%E5%86%85%E7%9A%84%E5%88%AB%E5%A2%85%E6%98%AF%E7%9B%B8%E5%BD%93%E7%A8%80%E7%BC%BA%E7%9A%84%E8%B5%84%E6%BA%90">西五环内的别墅，是相当稀缺的资源</a></li></ul><h2 id="调控降房价是刚需的一厢情愿"><a href="#调控降房价是刚需的一厢情愿" class="headerlink" title="调控降房价是刚需的一厢情愿"></a>调控降房价是刚需的一厢情愿</h2><p>2010年的房地产调控，让很多人看到了希望：让房价降得再猛烈些吧。还有人更是幸灾乐祸似的呼喊：让房地产赶紧崩盘吧。让没房子的好好看看有房子的笑话，是人生的一大快事。</p><p>但是我们是不是要仔细想想，为什么调控？调控期望得到什么样的效果？</p><ol><li>是如千千万万想买房子的人期望的那样，让人人买的起房吗？</li><li>是如千千万万的流氓无产者期望的那样，让房地产崩盘，开发商上吊，dfzf不再靠卖地实现gdp吗？</li></ol><p>2010年房价下跌已经变成了人民最急切的期望，已经高过了解决超贫困家庭的温饱问题，已经超过了子女教育，医疗和养老。并且为房地产必须下降提出了若干义正言辞理由，总结下来无外乎三条：</p><ol><li>人人都有居住权。房子是用来住的，不是用来炒的。</li><li>房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。</li><li>房价上涨造成物价上涨，人民生活变得困难。</li></ol><p>的确，当经济过热，房价过高，会对经济运行和社会安定带来较高的风险。这也是国家所担忧的。防范金融风险，一切维稳才是zy考虑的重中之中。</p><p>而民间所总结的三条，应该和调控的原因和目的基本不沾边。让我们一条一条的分析一下：</p><h3 id="1、人人都有居住权。房子是用来住的，不是用来炒的"><a href="#1、人人都有居住权。房子是用来住的，不是用来炒的" class="headerlink" title="1、人人都有居住权。房子是用来住的，不是用来炒的"></a>1、人人都有居住权。房子是用来住的，不是用来炒的</h3><p>其实这是一个伪命题。房子包括房屋及房屋所属的土地两个部分。房屋本身只有居住价值；而土地所具备稀缺性，决定了土地的投资价值。房地产贵的不是房屋，而是房屋下面那块地皮。所以商品房具备了投资与自住双重属性。</p><p>任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。</p><blockquote><p><strong>liougehooa：</strong></p><p>“任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。” 任志强这句话绝对没说炒房价，房子在他眼里还是住的。<br>难道你用byt是你老er比较稀缺才买？那也没看见byt暴涨到5W一个。<br>”而土地所具备稀缺性？“任志强也说了，拿出全国耕地的1%也够老百姓住了！现在是啥科技了，舍掉1%耕地对农作物有什么影响？</p><p><strong>kkndme：</strong></p><p>华北平原从河北到山东有大片的盐碱地，你都可以用于盖房，而且会非常便宜，也没有人跟你竞价。但是你在那里盖了房子并不能保证你天天按时在北京城区上班。</p></blockquote><h3 id="2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘"><a href="#2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘" class="headerlink" title="2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘"></a>2、房子太贵了，租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘</h3><p>这个问题比较大。房价是不是太贵了？有没有泡沫？</p><p>我们首先从国民的收入结构来分析</p><p>一个遵从“丛林法则”的精英社会决定了国民收入的金字塔结构。</p><p>既然是金字塔，底端的中低收入者占据了金子塔的最大比例，但是大家要知道金字塔的顶端既使只有10%人口，那也将是一个1亿多的绝对庞大的数字，远远超过了绝大多数西方国家的人口总和。</p><p>而北上广深以及三十多个省会，这些个靠掠夺全国或者一省资源，以牺牲大多数人口的利益为代价发展壮大起来的超大型及大型城市，需要容纳全国1亿多的精英人群，是否能得出房地产严重泡沫，空置率过高的结论？</p><p>当低收入者们努力挥洒汗水期望着自己年薪能够超过5万，8万，10万。。。的时候，他们可能做梦也想不出精英阶层手中究竟拥有多少财富。</p><p>精英们会象流氓无产者们一厢情愿认为的那样：因为一个区区房产税而恐慌性抛弃手中的大量房产吗？</p><blockquote><p><strong>liougehooa：</strong></p><p>”因为一个区区房产税而恐慌性抛弃手中的大量房产吗？“ 现在不说哪个富豪不是靠偷税漏税爆发的，我就举个例子，一套房不收税，二套房也不收税，三套房收300%税，你龟儿子还敢买三套房？</p><p><strong>kkndme：</strong></p><p>你说的事情在历史上已有发生，大明律明令禁止超标准建房，如果违禁，不仅仅是收税的问题，而是打板子下大狱，没收充公的，比房产税可要狠多了。但是终究没能执行下去，原因在于官员太腐败，不符合官员地主阶层的利益，最后名存实亡了。光是梗着脖子叫唤是没有用的，利益驱动着社会的发展，违背统治阶层利益的事情即使出台也难以执行，最后的下场都是不了了之。</p></blockquote><p>答案显然是否定的。</p><p>可以确认的是，房价不是由统计局的平均收入决定的。而是精英的平均收入决定的。</p><p>为了便于分析，我们剥离掉商品房（注意：只是商品房，而不是房屋）的社会属性，先把它看做商品。是商品就有他的内在规律。</p><p>什么决定商品的价格，价值？对不起，我只能说你上学上傻了。</p><p>是供求关系，只有供求关系。</p><p>我们判断一个核心城市市区内的商品房是具备足够稀缺性的。</p><p>如果你在北京海淀区上班，即使你在山海关拥有1000平方米的住宅也不能替代你住在北京市近郊区以内的愿望。而无论你是租房，分房还是买房，只要你还在海淀区上班，你就必须住在北京市近郊区以内。</p><p>假设你挣得钱不足够多，你需要租一套房子解决你的上班问题，上班距离的远近及居住的质量，取决于你愿意支付的租金。</p><p>假设你的钱够买房子，我相信你更愿意买房，因为你可以拥有房屋的产权和房产增值的收益。而买房子的大小，品质，离你上班的远近，取决于你手中的资金和你对未来收入的预期。</p><p>买房问题很象是中国的上学问题，而且简直是异曲同工。</p><p>假设你家附近有个重点中学，教学质量很好，考大学几率很高，而其他的学校你觉得不理想，你肯定希望无论如何自家小孩也要上这个重点中学。</p><p>上重点中学凭什么？我们简单的剥离掉其他社会因素的影响，可以认为想上重点中学就要凭好成绩，小孩努力考到前多少名，就可以上重点中学。这与努力赚钱买房是一个道理，有钱的出高价就能买到好位置好环境的房子。</p><p>我们再加入社会因素的影响，比如某大人物看到这个中学很抢手，很可以赚一笔，于是就设计了加分项，谁给自己送的钱多，就给谁加分，于是小孩要上重点中学不但要考高分，还要送钱加分。</p><p>同理，当好位置的商品房成为稀缺资源，各类炒房客的出现是必然的。</p><p>如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？</p><blockquote><p><strong>liougehooa：</strong></p><p>”如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？“ 你拿一个错误的现象，说这个现象是正确的来证明你错误的房价观念是正确的，可笑！</p><p><strong>kkndme：</strong></p><p>事情不能简单用正确还是错误来评价，一件事物发生一定有发生的原因。你说皇帝统治老百姓，想杀谁杀谁是正确还是错误？如果是错的，但是却在中国延续了几千年。</p></blockquote><p>尽管炒房和公立幼儿园加价成为普遍的社会现象是令人痛心的，但它们不以刚需人群的意志为转移的存在着，且与泡沫无关。</p><p>最被提及与泡沫有关的是以下两点：</p><p>第一，中国的房价甚至高于某些发达国家的房价。</p><p>其实，众所周知的是：不光房价高于某些发达国家，石油，高速，教育，医疗，税收等费用都远远高于某些发达国家。</p><p>而且中国的精英人群尽管所占比例不大，但是绝对数量足够大，而且精英平均收入甚至远远高于某些发达国家的收入水平。</p><p>第二：租售比问题</p><p>这个问题不用过多解释，使租售比更合理的方法不是只有降低房价一种，还有一种更靠谱的：房租大幅度上涨。而且已经在行动中。房租长期保持低价就像1990年以前的和田玉长期保持低价一样不可能。</p><h3 id="3、房价上涨造成物价上涨，人民生活变得困难"><a href="#3、房价上涨造成物价上涨，人民生活变得困难" class="headerlink" title="3、房价上涨造成物价上涨，人民生活变得困难"></a>3、房价上涨造成物价上涨，人民生活变得困难</h3><p>这个问题其实也不用多解释，懂经济学的该明白自然会明白，不会轻易被忽悠，不懂的解释半天也不会明白。</p><p>简单的可以这样说，物价上涨是经济过热，钞票印多了的后果。而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。</p><blockquote><p><strong>liougehooa：</strong></p><p>”而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。“</p><p>房价高涨，你要发的钞票必须要多，不然怎么去买房子？你发的钞票越多，钞票不是你发下来去买房子就死掉了不流通了，它只要流到人的口袋或者银行的口袋，这钱立马回出现流动，能不造成通货膨胀吗？除非这笔钱收到后限制房东使用。<br>为了支持高房价，国家必须发大量货币，这也是去年房价高涨的原因。</p><p><strong>kkndme：</strong></p><p>请先了解一下中国的货币发行制度，人可以无知，但不可以乱说。让人笑话。</p></blockquote><p>其实如果房地产交易量下降，不再具有吸金功能，那么农产品等生活必须品以及房屋租金等等就会大幅上涨。这是因为多出来的大量钞票总要有个流向，如果不被房地产吸收，就会被大蒜，绿豆，姜，及全部生活必须品的上涨来吸收</p><p>事实也证明确实如此。2010年房产调控后，物价上涨的势头非常迅猛。</p><h2 id="调控的真正目的：防范金融风险-amp-通过垄断实现gj利益最大化"><a href="#调控的真正目的：防范金融风险-amp-通过垄断实现gj利益最大化" class="headerlink" title="调控的真正目的：防范金融风险 &amp; 通过垄断实现gj利益最大化"></a>调控的真正目的：防范金融风险 &amp; 通过垄断实现gj利益最大化</h2><p>那麽是不是房地产就没有泡沫呢？</p><p>这个问题谁也不知道，因为到现在zf拿不出一份权威的数据来说明房地产到底有无泡沫。</p><p>但是房价高了就有风险，zf从感性上还是有清楚认识的。</p><p>注意，我们前面啰嗦了很多，现在才开始接近这次调控的真实意图。</p><p>防范金融风险？不错，你说的很对，但是没这么简单。</p><p>辨别利益是看透一切事物真相的武器。</p><p>高房价谁是受益者？</p><p>房地产游戏的模式三个环节：dfzf卖地、银行贷款、开发商在二级市场销售</p><p>dfzf卖地之后，剩余的风险和收益都归银行和开发商</p><p>dfzf卖地的款则用于地方广场，地铁，公路之类的建设和权贵的挥霍。</p><p>dfzf只负责卖地，是无风险的买卖。</p><p>只要房价不断上涨，加杠杆的炒房客就会赚到盆满钵满</p><p>这么分析下来，最受益的地方政府、开发商、炒房客。</p><p>独独缺了zy。</p><p>这时你是否猜到zy为什么要调控？如果还猜不到没关系，听我道来。</p><p>纵观古今，上位者最不能容忍的是别人受益，自己被黑锅。</p><p>大kfs，小kfs，大炒房客，小炒房客，dfzf都是收益者，但是风险却由zy来抗。这是一笔很不划算的买卖。</p><p>而房地产混战的局面，造成了国家队央企成员只有凭财大气粗高价拿地的份，钱花的最多，风险却抗的最大。</p><p>zy深深的感觉到要想国家队受益，要想控制风险只有做到两个字：垄断。</p><p>提高资金门槛，让小kfs，小炒房客，有点钱的小老百姓推出这个游戏。房地产很好玩，但不是小人物应该玩的。</p><p>先让市场冷静，彻底整顿，踢出那些个跳梁小丑，然后国家队出马，绝对垄断的市场，才能够统一定价，才能够控制风险，才能够利润最大化。</p><p>既然油价高于美国是合理的，那麽房价高于美国一定也是合理的，关键在于垄断。</p><p>不仅仅是房价的垄断，因为过高的垄断定价将会使交易量下降，国家队也需要资金周转。</p><p>真正厉害的，还是房租的垄断。公租房的推出是房租垄断进程的里程碑。</p><p>至于苦等廉租房的同志，不要抱太大的希望。城市要建设，地铁，广场，政府大楼都要上马，钱从哪里来？不会无缘无故凭空出来。</p><p>想想小学就近上学，但是重点小学真的就近就能上吗？小学名额可以寻租，经适房，廉租房也是一个道理。</p><blockquote><p><strong>tjOOSAN：</strong></p><p>真扯啊~~~ 油价跟房价去比？？</p><p>这位kkndme ，你就别忽悠了！~~</p><p>汽车对于百姓而言，可有可无，油价涨到是美国的一百倍，中国百姓才高兴了。</p><p>大哥！房子是必须品。ok？那么既然你也认为政府的钱大多从地产来。</p><p>那么这种发展正常嘛？会持续吗？？没有实体经济，能行吗？</p><p>招你的法子说，炒楼才是中国的前途？</p><p><strong>kkndme：</strong></p><p>这位兄弟，您比那些希望钱钱去炒大米的还不靠谱。</p><p>石油影响的不仅仅是开车的人花费多了。疯狂上涨的运输成本会导致民不聊生的。</p><p>假设一斤蔬菜从广西的农民地里收购是0.5元一斤，但是由于油价的像你说的上百倍的涨，运到北京，这斤蔬菜要卖300块一斤。</p><p>社会就瘫痪了</p><p><strong>tjOOSAN：</strong></p><p>那么这种发展正常嘛？会持续吗？？没有实体经济，能行吗？</p><p><strong>kkndme：</strong></p><p>实体经济的发展不是简单的钱不去投资房产，就会去投资实体经济，实体经济就发展起来了。估计媒体洗脑洗的比较厉害，你中毒了。</p><p>资本是趋利的。无论是哪个国家，哪个社会，只要存在市场经济，这个道理就一定不会错。</p><p>为什么资金进入房地产及其他资本市场而逃离实体经济？是因为实体经济环境不好，不赚钱。</p><p>一是税赋太高，二是各种需要打点孝敬的部门、管理人员、工作人员太多，比税赋还高，不能承受之重。三是国家队在各个重要领域的垄断，使国企变成了变相税务局的职能，垄断企业的暴利定价，又是压在本应该蓬勃发展的实体经济上的又一座大山。</p><p>现在央企基本是不垄断的行业不做，把产能过剩，充分竞争的产业交给民间资本，并且还要给这些资本压上高昂的负担.</p><p>有可能垄断的行业包括房地产都会收到国家队手里，以后更是将发展成为一个高度垄断的社会。</p><p>资本不是傻子，一定会趋利，所以资本放弃了操心受累不挣钱的实体经济，转而投向房地产。房地产的调控，让资本又进入了黄金、农产品领域参与爆炒，反正就是不进实体经济。因为国家不给实体经济的环境做任何的改善。</p><p>如果实体经济有一个好的环境，有一个好的获利空间，大量的资金就不会撤出实体经济，没有资金潮涌般的投入房地产市场，中国的房地产将会是一个平稳的上涨趋势。</p><p>但是体制决定了资金的去向，不以人的意志为转移。</p><p>高税赋、暗箱成本及垄断不但造成巨大的贫富差距，而且将会导致生活成本的大幅提高，生活负担日益沉重。</p><p>一方面百姓生活负担的加重，导致一些非生活必须品严重产能过剩，将会出现大量亏损倒闭的内需企业。</p><p>另一方面精英阶层快速聚集大量财富，使奢侈品供不应求。古董，字画，玉器，豪车，顶级服装的消费比重也将越来越大。</p><p>但是能够容纳大量资金的只有两个领域：农产品领域（满足老百姓的肚子）和商品房领域（居住权要满足老百姓的需求，产权要满足精英阶层的需求）。</p><p>资金的流向只能疏导不能强堵，zf很明白这个道理。两者危害取其轻，你认为zf会选择哪个领域？</p></blockquote><blockquote><p><strong>tjOOSAN：</strong></p><p>真扯啊~~~ 油价跟房价去比？？</p><p>这位kkndme ，你就别忽悠了！~~</p><p>汽车对于百姓而言，可有可无，油价涨到是美国的一百倍，中国百姓才高兴了。</p><p><strong>vavan2010：</strong></p><p>这种人肯定最后就是蠢死的。你没车，不用汽油，你可知道生活中有多少东西是需要用汽油的？无知才最可悲！</p><p><strong>kkndme：</strong></p><p>我们为确实买不起房的低收入群体，只能感到无奈</p><p>但有些本来能买房却嫌这嫌那而不买房的傻空通知，我们只能说你买不起房，完全是自己的原因，连油价上涨意味着什么都搞不懂，贫穷真的不能怨别人。</p></blockquote><h2 id="官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真"><a href="#官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真" class="headerlink" title="官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真"></a>官方公布的统计数据，只要关系到某个群体的利益，就一定会被修饰导致失真</h2><p>说到房产泡沫的问题，就不得说说官方的统计数据。</p><p>官方的统计数据从来是可以很雷，但不可以很真。</p><p>我们的统计原则基本就是：村骗乡，乡骗县，一骗骗到国务院。</p><p>不知道有人去市、县、乡、村进行过社会调查没有？</p><p>社会调查是怎么一回事？</p><p>我来告诉你，所有的关于人口、收入、田地、贫困户的数据都是官方统一编写，统一口径，如果胆敢有哪个小民对调查人员乱说，那是吃不了兜着走的。</p><p>你问了数据编来编去的意义在哪里呢？</p><p>意义很大，起码跟向上申请拨款是关系非常密切的。数据不假，钱从哪来？</p><p>统计数据无所谓是否真实并不重要，重要的是它是获取利益的重要手段。</p><p>假设官方想证明房地产不存在泡沫，那么一定拿的出不存在泡沫的统计数据作证。</p><p>反之，也一样。</p><p>好比,CCAV为了证明高空置率的结论，派出记者专门找偏远且刚刚完工的楼盘，进行了一次纯粹为了证明内部已事先得出结论的毫无科学依据的调研。</p><p>而dfzf，为了证明刚需多么强劲，也立刻拿出了选择性失明的统计数据来进行回击。</p><p>无论是左还是右，同样都是不科学，都是现有结论，再有证据。</p><p>我们到底应该信谁</p><blockquote><p><strong>cdw1：</strong></p><p>商品房本来名字中就有商品二字不准投资岂不是笑话？真正不准投资的那叫公房，这才是保证老百姓有房住的关键，商品房诞生的时候就很明确是改善居民居住条件的，现在政府怪商品房价格过高造成老百姓没房住本来就是颠倒黑白，政府不造保障老百姓居住的公房，而让老百姓去购买改善居住条件的商品房来解决本该政府解决的居住问题，政府不作为才是造成老百姓出现居住问题的罪魁祸首。我不期望人人有房，我只希望每一个在城市里找到工作的人通过努力工作勤俭持家能在生活城市里有希望拥有一套安稳的房子来容身，不管这房子的性质是商品房、经适房、廉租房或者其他什么房子。</p><p><strong>kkndme：</strong></p><p>你说的正是根源所在啊，zf的职责应该向无房者提供的保障房，建成经适房、两限房，被权贵占有牟利，而非要把商品房赋予稳定社会的职能。zf不是不知道问题的根源，而是不愿意放弃巨大的利益。</p></blockquote><h2 id="税收从来都是向下游转嫁的-amp-房产税迟迟不出台的真正原因"><a href="#税收从来都是向下游转嫁的-amp-房产税迟迟不出台的真正原因" class="headerlink" title="税收从来都是向下游转嫁的 &amp; 房产税迟迟不出台的真正原因"></a>税收从来都是向下游转嫁的 &amp; 房产税迟迟不出台的真正原因</h2><p>闲扯了一下统计数据</p><p>还是回到这次调控中来</p><p>房地产游戏的模式三个环节：dfzf卖地、银行贷款、开发商在二级市场销售</p><p>dfzf卖地之后，剩余的风险和收益都归银行和开发商</p><p>dfzf卖地的款则用于地方广场，地铁，公路之类的建设和权贵的挥霍。</p><p>dfzf只负责卖地，是无风险的买卖。当然还有人企图利用流氓无产者和无知群众的群情激奋来进一步收取房产税来提高dfzf收入。</p><p>税收从来都是向下游转嫁的，zf多收出来的钱一定是通过最下游的房租来体现。</p><p>当然，也有很多明白人士大声疾呼反对房产税。</p><p>自古而今，即使最辉煌的朝代，最被广大群众津津乐道的太平盛世，普通群众也仅仅只是解决了温饱而已，包括贞观、文景、康乾。</p><p>国家的富庶都是以老百姓勒紧裤腰带为代价的。</p><p>所以，zf是不会理会部分明白人反对房产税的呼声的。</p><p>真正对房产税的顾及来自于dfzf对土地出卖前途的担忧，真是鱼与熊掌不可兼得。</p><p>尽管流氓无产者和无知群众的呼声很高，然而房产税征收一旦实际操作起来，就会变的不得人心，征收难度非常之大，实际效果难以预知。也就是说zf没有底。而如果房产税征收效果不佳，dfzf卖地收入再受到巨大影响，那就真正是得不偿失了。</p><p>就会变成赔了夫人又折兵。</p><p>这样的买卖，zf是不会轻易做的</p><h2 id="房地产的现状"><a href="#房地产的现状" class="headerlink" title="房地产的现状"></a>房地产的现状</h2><p>房地产的现状是，商品房二级市场是由各种类型的开发商自由竞争的，一手房开发商之间的竞争，二手房投资客之间的的竞争。</p><h2 id="房价持续上涨的本质是稀缺性让好房子成为资金最好的去处"><a href="#房价持续上涨的本质是稀缺性让好房子成为资金最好的去处" class="headerlink" title="房价持续上涨的本质是稀缺性让好房子成为资金最好的去处"></a>房价持续上涨的本质是稀缺性让好房子成为资金最好的去处</h2><p>房价为什麽在一个自由竞争的市场上能够持续上涨？因为稀缺性。不是房屋的稀缺性，而是房屋所必须占用的土地的稀缺性。</p><p>有些群情激奋的群众立刻以6500万套房子空置的事情提出质疑，还有ccav的报道，那是要多煽情又多煽情。</p><p>我们无需说6500万套的真实性（明白人都知道非常离谱）和空置我心的科学性。为什么不说，因为这种稀缺性跟空置率就完全没有关系。商品房的稀缺性是相对人民币而言的。人民币印多了，资金没地方去，商品房就涨价了。</p><h2 id="关于垄断"><a href="#关于垄断" class="headerlink" title="关于垄断"></a>关于垄断</h2><h3 id="1、垄断的好处是没有风险"><a href="#1、垄断的好处是没有风险" class="headerlink" title="1、垄断的好处是没有风险"></a>1、垄断的好处是没有风险</h3><p>垄断的市场是没有风险的，土地是完全垄断的，所以dfzf完全没有风险。</p><p>而商品房是自由竞争的市场，是具备风险属性的，尽管由于大量印钞造成了商品房的飞涨，但随着房价的高涨，风险也在积聚。</p><p>dfzf土地垄断没有风险，完全可以置身事外。</p><p>可是银行呢？属于国家的银行。</p><p>银行正在承担自由竞争市场房价高涨积聚的风险。</p><p>这是zy不允许看到的，dfzf受益，而风险全部甩给zy。</p><p>既然垄断的市场是没有风险的，那还是让房屋和土地一起垄断好了。</p><h3 id="2、垄断可以解决社会稳定"><a href="#2、垄断可以解决社会稳定" class="headerlink" title="2、垄断可以解决社会稳定"></a>2、垄断可以解决社会稳定</h3><p>垄断还可以解决一个问题：社会稳定。</p><p>常被媒体和群情激奋群众所提及的一个重要问题就是：房价收入比。</p><p>大量印刷的人民币促成了房价高企（因为商品房实在是具备了大资金需要的所有投资品属性），可是那些个巨额的资金普通老百姓并没有见到。</p><p>路人甲：我们一个月就挣2000多块钱，干一辈子买不起房啊。</p><p>路人乙：我一个月上万都买不起房。</p><p>媒体：一个家庭不吃不喝22年买一套房</p><p>大量的疯狂印刷的人民币在哪里呢？</p><p>在精英手里。</p><p>我们在回顾一下开篇，我们奉行的是精英社会，丛林法则，金字塔式收入结构。</p><p>人民币再多，也不可能流到金字塔的底端。</p><p>dfzf垄断卖地也就让百姓们发发牢骚。</p><p>而炒房客，kfs赚的盆满钵满就让生活在中下层的老百姓眼红和不能容忍。</p><p>不患寡而患不均啊。</p><p>垄断，国家队的垄断，可以解决眼红问题，也就是社会稳定问题。</p><h3 id="3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难"><a href="#3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难" class="headerlink" title="3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难"></a>3、房屋垄断只会愈演愈烈，底层人民想要拥有一套房子的难度只会越来越难</h3><p>还有一个最重要的问题：银行和民营开发商之间，是官与民之间的问题。</p><p>而银行和国家队央企，是左兜和右兜的问题。</p><p>土地是垄断的</p><p>然而房屋垄断并不是一件容易的事情。</p><p>因为民间百姓手里是存在大量二手房的，当然这也是为什么调控的板子只打在二套房、投资客、炒房客身上的原因。</p><p>同样，房租的垄断也并不是一件容易的事情，因为民间百姓手中的大量二手房都具备出租的特性。</p><p>俗话说，问渠哪得清如许，唯有源头活水来。</p><p>要垄断，必须抓住源头。</p><p>源头在哪里？</p><p>在一级市场，而不是二级市场。</p><p>房地产的垄断就是要国家队从一级市场做起，从一级市场开发着手完成对商品房开发的垄断。</p><p>一级市场，那是一个高高的门槛，民间资金，就让他该干嘛干嘛吧，房地产不是你玩的。</p><p>一级市场包括的内容是一般开发商无法参与的：</p><p>城市规划，城中村改造，旧房拆迁，城市综合体开发。</p><p>可以说从规划、改造拆迁、开发、到二级市场销售，一条龙服务。</p><p>一级市场开发的最大特点就是可以创造需求：你不是有房子吗？我拆掉你的房子，看你有没有刚需。</p><p>国家垄断控制风险的意义还在于：需求可以拆出来。</p><p>以后的路，民营开发商的日子将变得越发艰难。</p><p>土地是dfzf的，商品房开发是央企和国企的。</p><p>处于金字塔下层的40%家庭，如果还没有一套自己的房子，那么买一套自己的房子就越发的变得不可能。</p><p>商品房将逐渐往金字塔的上层积聚。</p><p>处于金字塔下层40%的无房家庭将只能以租房来解决居住问题。</p><p>租金的快速上涨期即将到来，zf已经盯上了房租这块巨大的蛋糕。因为房租的收益比房产税更靠谱，更具有操作性。</p><p>公租房，呼之欲出</p><h2 id="民生问题"><a href="#民生问题" class="headerlink" title="民生问题"></a>民生问题</h2><blockquote><p><strong>sunxinmfc：</strong></p><p>政府无需考虑民生问题么，本次号称史上最严厉的打压政策再起不到一点效果，ZF威信力将进一步下降，需要仔细考量</p><p><strong>kkndme：</strong></p><p>自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。</p><p>因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。</p><p>农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。</p><p>而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。</p><p><strong>sunxinmfc：</strong></p><p>秀才造反，三年不成，自古已然。</p><p>但我们还没有谈到所谓“造反”的地步，只是说房价如你所述，暴涨，中国的中产和以上人士将进一步携款合法外流（在房价暴涨的09年，中国外流人口达到历史峰值）。这一部分人利益如何保证？您觉得zf不需要考虑对么？</p><p><strong>kkndme：</strong></p><p>现在社会跟几百年前最大的不同是，世界是开放的，这得益于地理大发现和世界经济一体化，即使缅甸朝鲜这样封闭的国家也免不了受到来自世界范围的影响。大一统的集权社会融入了西方民主的思想，同时互联网的出现也让人们对过去的思维进行了再思考。</p><p>尽管底层百姓出国还是一个梦想，但对于精英人群，基本上是在世界范围自由流动的。</p><p>中国自古以来，商人都是没有地位的，商人的财产可以随时被官员没收，自古如此，至今如此，即使是今天也并没有出现私人财产神圣不可侵犯的宣言。即使出现了，也没有任何可以操作的可能。</p><p>明朝以后大量的商人移居海外成了华侨，现今的商人为了安全移居海外也不是什么新鲜事，不过是步明朝华侨的后尘罢了，zf会真的放在心上吗？朱元璋没有放在心上，朱棣没有放在心上，现在同样也不会放在心上。</p><p>真正可怕的是官员一方面谋取私利一方面把亲属和存款送到国外，这其实是一种国家背叛。在国内榨干老百姓的血汗，得到的金钱却在国外挥霍。什么叫卖国，不过如此。</p><p><strong>connstr：</strong></p><p>假如商人可以移居海外，官员自然也可以。官商能分家吗？</p><p><strong>kkndme：</strong></p><p>商人还是要分的吧：红顶商人就是官商，统治阶级，那是上位者。</p><p>普通商人，比如开个袜子厂赚个辛苦钱，最后袜子厂不挣钱了，官员还天天找他，让他孝敬，他就只好移民了。</p><p>普通商人在中国也是海量的，有点钱，但是没一点地位。</p></blockquote><p>中国自古以来都不是人人都能有属于自己的房子，大量的丫鬟、仆妇、管家、小厮寄养在权贵人家，身体都是不自由的，何谈拥有自己的房子。</p><p>自古以来，最多的就是失去土地的农民，住在地主家做长工，又何谈属于自己的房子。</p><p>只要是有贫富差距的社会，只要存在阶级，只要存在统治和被统治，这个社会就会不以人的意志为转移的出现大量的底层居民，没有这些底层居民。权贵就不能很好的生活。</p><p>为了权贵生活的更好，就要维持大量的底层群众。</p><p>权贵必须保证大量底层群众的基本生活，才能够让自己过得更舒服，仅此而已。这就是民生</p><blockquote><p><strong>sunxinmfc：</strong></p><p>删掉了一大段，不得不说，你说的很对。</p><p>（呻吟一下）。君不见，天涯上多少盼着被美军解放的铁杆准汉奸，政府楼被炸七成网民不是替死者默哀，而是一片欢呼。为什么会有这样的民意，参考前苏联，ZF确实应三思</p><p><strong>kkndme：</strong></p><p>爱国是与中华的历史分不开的，自秦统一以来，中国由封建时代转变为帝国时代，只有在项羽焚烧咸阳后，对诸侯进行了一次分封，但时间非常短暂，刘邦重新统一了天下，帝国时代经历了漫长的汉、唐、宋、元、明、清。天下一统的爱国情结是根深蒂固的。</p><p>而在秦以前，与中世纪的欧洲是极为相似的，齐国人可以到秦国做宰相，赵国人可以到燕国做将军。中世纪法国的诺曼底公爵可以到英格兰继承王位，瑞典的贵族可以到基普做大公，封建时代的国家概念并不是明显。欧洲经历了漫长的封建时代，国家观念很淡薄，能够抛弃国家货币成立欧盟就是明证。这对于漫长帝国时代，天下一统的国家是很难想象的。</p><p>爱国只跟历史文化传统有关。</p><p>1978年越南入侵红色高棉，当时的红色高棉对内实行红色恐怖，以gongchanzhuyi的名义对全国700万人口进行奴役和屠杀，总共屠杀了100万人。当越南军入侵时，受到了广大柬埔寨群众的热烈欢迎，称越南军解放柬埔寨是解放人类的战争。</p><p>红色高棉失去了民心，必然败亡。</p><p>那时，为了支援红色高棉，中越战争打响。有我国的强力支持，红色高棉仍然走向败亡。</p></blockquote><h2 id="房产税的制定原则"><a href="#房产税的制定原则" class="headerlink" title="房产税的制定原则"></a>房产税的制定原则</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>不过从政府要分租房市场的蛋糕而言，我有不同的看法</p><p>政府的公租房要想租出好价格，有两种方式</p><p>1）减少市场可出租房源（北京就这样干了，拆迁廉价城中村）</p><p>2）提高竞争房源的成本。（所以我认为推出房产税是大概率的事情，因为政府的公租房是不需要交房产税的）</p><p>于是竞争房源的房租暴涨，政府的公租房也就可以羞羞答答的打个9则来</p><p>安抚一些底层了，反正所有的黑锅都有竞争房源的房东背了</p><p><strong>kkndme：</strong></p><p>房产税的问题我觉得zf还是慎重的</p><p>1、如果采用不公平法则：</p><p>公务员，垄断企业，事业单位的福利房不上税，权贵与利益集团购买囤积的大量商品房不上税，只有普通百姓上税，会加剧社会矛盾，而房产税会大幅提升租金，在公租房没有大量建起来之前，对稳定不利，维稳才是第一要务。</p><p>2、如果实行公平法则</p><p>小产权房，福利房，权贵囤积房都要上税，执行难度太大，可操作性不强，阻力几乎难以逾越。</p><p>如果真的收房产税，采用不公平法则的可能性最大，普通的无房百姓生活将变得非常艰难。</p></blockquote><h2 id="维稳的本质是人民能吃饱饭"><a href="#维稳的本质是人民能吃饱饭" class="headerlink" title="维稳的本质是人民能吃饱饭"></a>维稳的本质是人民能吃饱饭</h2><p>维稳问题其实最终还是吃饭问题。</p><p>房价上涨可以不买，如果房租价格不能控制，农产品价格不能控制。一旦大批群众吃饭出现了问题，维稳就无从谈起了。这个底线，还是要严守的</p><h2 id="公租房是为体制内服务的"><a href="#公租房是为体制内服务的" class="headerlink" title="公租房是为体制内服务的"></a>公租房是为体制内服务的</h2><p>说到公租房问题</p><p>首先还是要提到我们实行的双轨制</p><p>从某一方面可以简单的理解为统治阶级内和统治阶级外。 <br>也就是我们常说的体制内，体制外。</p><p>体制内：公务员、垄断企业及医院高校科研院所等事业单位。</p><p>体制外：外资、私企打工者，个体工商户，农民，这里面也应当包括高层的老板和最底层的长期无业人员。</p><p>我们感受最深的就是涨工资的问题，一旦政府涨工资，那就一定是体制内涨工资，跟体制外完全没有关系。在金融危机的08年，大批企业关门，减薪，裁员，美国欧洲因为钱紧不得不降低公务员薪水。而这时，我们神奇的国家在干一件事：公务员普遍加薪，是为了全国百姓着想—刺激消费。</p><p>还有保障房问题，这个也是我们感受最深的：保障房&#x3D;公务员及垄断企业住房；解决住房问题变成了如何让领导干部住更多更大的房子，如何让体制内员工拥有足够舒适住房的问题。</p><p>体制外的群众，那是别想得到一点好处的。谁让你是被统治阶级呢。</p><p>公租房的推出，也要解决两个问题：</p><p>1、体制内的最下层（最下层也是统治阶级，也就是是古代官吏中的吏）员工的基本住房问题</p><p>2、向体制外被统治的小民稳定收钱的问题。</p><h2 id="房产税一定会转嫁给租房人"><a href="#房产税一定会转嫁给租房人" class="headerlink" title="房产税一定会转嫁给租房人"></a>房产税一定会转嫁给租房人</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>对公租房的问题受教了</p><p>不过当前从来不存在什么公平正义</p><p>税收向来是穷人多交，富人不交或少交</p><p>不过我很感兴趣的是假如推出了房产税</p><p>政府采取何种方式收</p><p>难道是如同鬼子进村了，挨家挨户的收？</p><p>但鬼子本身就是房产税的征收对象（不然也当不了鬼子）</p><p>他们自己都抵制，难道还指望他们向屁民收</p><p>遇到那种要钱没有，要命有一条的主</p><p>难道政府还开拖拉机来收？</p><p>5年前就叫嚣对房租收个人所得税</p><p>到现在也没有个影了</p><p>操作性实在太差</p></blockquote><p>房产税无论是持有环节征收，还是交易环节征收都是要向最终租房人转嫁的。</p><p>好比鸡饲料上涨没有可能鸡肉不涨价，但是养鸡的并没有赚更多钱。</p><h2 id="巨大的税收消耗也决定了GDP必须快速增长-amp-公务员越精减越多"><a href="#巨大的税收消耗也决定了GDP必须快速增长-amp-公务员越精减越多" class="headerlink" title="巨大的税收消耗也决定了GDP必须快速增长 &amp; 公务员越精减越多"></a>巨大的税收消耗也决定了GDP必须快速增长 &amp; 公务员越精减越多</h2><p>降低百姓租房困难的唯一国际通行办法就是减税。但是减税，在我国是很难行的通的。一个高增长高通胀的国家，高昂的腐败成本和巨大的浪费将导致国家必须维持高税收才能维持运转，gdp保8实际上是必须的也是迫不得已的。维持正常的运转，维持庞大的消耗税收而不是创造税收的公务员队伍，没有gdp快速的增长怎么可能呢。</p><blockquote><p><strong>feiying：</strong></p><p>这种看法很有道理，但保8毕竟会有个尽头，一旦走到头了那怎么去做呢</p><p><strong>kkndme：</strong></p><p>对于小富即安的我等小老百姓来说，希望此生不要见到这一天的到来。</p><p>对于流氓无产者来说，盼望着这一天的到来。届时新的英雄将从流氓无产者中产生。如同威武的 同志。</p><p><strong>艾馨999：</strong></p><p>我也觉得应精减公务员，也许减掉三分之二房价就见效了，呵呵。中国确实存在很多不应有的机构。</p><p><strong>kkndme：</strong></p><p>千万不能精减，越精减越多。<br>一般裁减公务员都是专门裁那些没背景，没关系，不会拍马屁，傻干活的。而留下的就是有背景有关系，会拍马而不干活的。<br>当傻干活的公务员被裁掉以后，剩下的不干活的公务员照样不干活。<br>于是政府发现没人干活了，人不够用了，再大批量招人，所以越精简人越多。<br>这就叫精减膨胀</p><p>特别是把熟悉业务的熟手减下来后，不得不招3个新手才能顶的住。等新手熟练了，人又富裕出来了。<br>精减膨胀这是不可更改的。<br>千万别精减，谁提出精减跟谁急，到时人民更没活路了。</p><p><strong>跳坑的青蛙：</strong></p><p>楼主关于精简膨胀的见解很精辟~<br>很多事情看起来、听起来很美，也仅仅是看起来、听起来而已，<br>有丰富生活经验的人仔细思考一下、观察一下就不是那么回事了~</p><p><strong>kkndme：</strong></p><p>是啊，很多空空们扯着脖子呼喊这个政策那个政策，殊不知执行下来，最倒霉的还是自己。管老爷利用空空们鸡冻的心情趁机敛财，赚个盆满钵满。等空空们明白过来，也没办法了。<br>好比许多人最欢迎的费改税，结果税增加了，费却一点没见少。</p></blockquote><h2 id="调控的好处是让zf利益最大化-amp-防范金融风险"><a href="#调控的好处是让zf利益最大化-amp-防范金融风险" class="headerlink" title="调控的好处是让zf利益最大化&amp;防范金融风险"></a>调控的好处是让zf利益最大化&amp;防范金融风险</h2><blockquote><p><strong>骑自行车买别墅：</strong></p><p>就说政府为什么要调控？</p><p>难道就为了给你说的P民面子？？</p><p>如果房价一直暴涨，不更符合食利阶层的利益？房价低价一起彪～</p><p><strong>kkndme：</strong></p><p>真不知道你仔细看了没有。我通篇也没下过调控是为了给P民面子的结论。</p><p>调控的根本原因还是zy在房地产的游戏中没有得到好处。调控是为了让zy的国家队参与进来，成为主体。</p></blockquote><h2 id="垄断可以控制价格，维持稳定"><a href="#垄断可以控制价格，维持稳定" class="headerlink" title="垄断可以控制价格，维持稳定"></a>垄断可以控制价格，维持稳定</h2><p>垄断的目的还在于能够控制价格，为了维稳，zy是不希望暴涨的，但也不希望不涨。</p><h2 id="体制内的住房问题有国家保驾护航"><a href="#体制内的住房问题有国家保驾护航" class="headerlink" title="体制内的住房问题有国家保驾护航"></a>体制内的住房问题有国家保驾护航</h2><p>回头还说公租房</p><p>在私企打过工的都知道，毫无归属感可言，老板脑袋一发热，随时让员工卷铺盖卷走人。那是要多没保障有多没保障。原因是社会关系，关键客户，都掌握在老板一个人手里，员工就是打个下手，一不爽了，就换人呗。</p><p>统治者可知道不能这么用人的。一个庞大的国家机器要想正常运转，必须得让手下的和自己的利益一致。如果自己吃肉，手下的连汤都没得喝，这个机器就转不动了。</p><p>因此，在房价高涨的时代，保障房才成为zy默认的公务员房、垄断企业房。 <br>公租房首要解决的就是手下里面最底层人士的住房问题。 <br>我认为针对于体制内来说，无论是公务员，事业单位，还是国有企业的初级员工，都可以通过所在单位申请公租房，公租房的租金会略低于市场，主要是单位一定会提供补贴。 <br>体制外对公租房的申请就没有那么幸运了。</p><h2 id="依靠但又不能完全依靠开发商建公租房"><a href="#依靠但又不能完全依靠开发商建公租房" class="headerlink" title="依靠但又不能完全依靠开发商建公租房"></a>依靠但又不能完全依靠开发商建公租房</h2><p>钱的问题，dfzf也想到了解决的办法。</p><p>在卖地时就要求开发商配套建设一定比例的经适房、廉租房或公租房。 <br>然而，羊毛出在羊身上，开发商不可能做赔本的买卖。经适房好说，反正是卖个住户，大不了利润很低，顶多挣得少点。而廉租房和公租房就纯粹是只见投入不见产出的（开发商可没资金没耐心收租子）。廉租房和公租房的建设成本必须加到所建的商品房身上，这肯定会抬高房价。<br> 关键是拿地成本逐年上涨，孝敬的资金也在逐年上涨，在加上多出来的廉租房和公租房建设成本，房价不可能无限抬高的。开发商也需要资金回笼周转。房价越高风险越大只是无论zf，开发商，炒房客和买房群众都有的共识。只是房价多高才是高，不同的人理解是不同的。</p><p>显然，把大量廉租房和公租房的建设寄托在开发商配套身上是完全行不通的，不仅不能解决住房问题，还让本来就高企的房价更加雪上加霜。</p><h2 id="体制内的住房问题不难解决"><a href="#体制内的住房问题不难解决" class="headerlink" title="体制内的住房问题不难解决"></a>体制内的住房问题不难解决</h2><p>体制内公务员、垄断企业和事业单位的员工住房问题是不难解决的，因为有zf行为的强制意志在里面。</p><p>1、df划拨土地，征集开发商建经适房、公租房</p><p>2、dfzf强制要求开发商建配套经适房、公租房，建设成本就转嫁给购买商品房的冤大头吧。</p><p>3、体制内单位自有土地，集资建房。</p><p>多管齐下，体制内人员的住房不难解决，甚至体制内人员每人住好房子大房子多套房子的问题都不难解决。处于金字塔的中上层，他们俯瞰着芸芸众生。</p><h2 id="解决体制外的住房问题：国家垄断，细水长流收租"><a href="#解决体制外的住房问题：国家垄断，细水长流收租" class="headerlink" title="解决体制外的住房问题：国家垄断，细水长流收租"></a>解决体制外的住房问题：国家垄断，细水长流收租</h2><p>处于金字塔下层的体制外的广大群众怎么办？</p><p>体制内员工的住房舒适性和投资获利是首要保证的，不然光让干活不给好处，怎么能让手下听话呢？</p><p>体制外广大群众的住房问题也要解决，这关系到社会稳定。</p><p>能不能拿出一个办法，即解决了群众住房问题，又可以从群众手里长期获取收益？</p><p>细水长流收租子的事情开发商做不了，但zf可以做。</p><p>公租房，如果解决了钱的问题，面向广大群众的公租房的推出，将会取得双赢的局面。</p><p>既然房地产开发最肥的肉留给了国家队，国家队也应该投身到公租房的建设中来。</p><p>国家队全面进场之前，大鱼小鱼虾米泥鳅，皆可得利。</p><p>不把小鱼虾米泥鳅赶出池塘，市场无法控制，风险无法控制，公租房建设也无从谈起。</p><p>二套房首付提高到50%，第三套房停止贷款，小开发商的清理整顿，民营企业在招拍挂中无论价高价低都无法取得土地，等等一系列重拳直击小鱼虾米。</p><p>土地将回到国家队手中，这个世界将变得清爽。</p><p>让时光倒流到80、90年代，我们的dfzf守着蕴藏着巨大财富的金矿、锡矿、铜矿却过着贫穷的日子。没有资金，矿山是没有办法变成财富的。于是招商引资，为了gdp,为了解决就业问题，出台了各种优惠政策，于是外商堂而皇之的走进来了。成为了这些矿山的主人。5年，7年或者10年，外商享受的免税期满的时候，外商卷着巨额财富走了，留下了一个个废弃的充满危险的大坑。这是血琳琳的教训，zf没有理由不吸取。外资、私企、小业主总有一天会让他们清场，尽管这一天晚来了十几年。</p><p>在土地日益稀缺的今天，房租难道不是可持续产出的金矿？让炒房客、投资客、民企开发商见鬼去吧。</p><blockquote><p><strong>kkndme：</strong></p><p>在土地日益稀缺的今天，房租难道不是可持续产出的金矿？</p><p><strong>百无一用一书生：</strong></p><p>如果人们宁愿住桥洞呢，如果人们决定离开呢，如果房租收入不断下降呢</p><p><strong>kkndme：</strong></p><p>宁愿住桥洞的早晚要当盲流处理的</p><p>逃离城市基本是一部分人被淘汰掉，选择，离开，而又有更多的人冲击去。</p><p>房租收入下降基本是做梦才会出现的事情，国家队的进场就是不让房租下降</p></blockquote><h2 id="普通人买得起「优质商品房」就尽早买把"><a href="#普通人买得起「优质商品房」就尽早买把" class="headerlink" title="普通人买得起「优质商品房」就尽早买把"></a>普通人买得起「优质商品房」就尽早买把</h2><blockquote><p><strong>懒兔爱散漫：</strong></p><p>楼主的意思是今后体制外的人（除最高层)外，是无缘商品房，只能住公租房了？</p><p><strong>kkndme：</strong></p><p>如果你现在还买的起商品房，那你就尽早买吧</p></blockquote><h2 id="商品房和公租房的区别"><a href="#商品房和公租房的区别" class="headerlink" title="商品房和公租房的区别"></a>商品房和公租房的区别</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>有个疑问</p><p>商品房和公租房相比，优势在什么地方？</p><p>那些楼裂裂的商品房估计质量还不如公租房吧</p><p>楼主应该加一句，买质量好的商品房</p><p><strong>kkndme：</strong></p><p>商品房和公租房的区别实际就是土地性质的不同，一个是出让，一个是划拨</p><p>出让那必须是招拍挂，那必须是天价。</p><p>划拨就基本算是白给，收钱就是象征性的意思意思。</p><p>是商品房还是公租房，土地的性质说了算，dfzf说了算。跟房屋质量没有关系。</p><p>一套房子假设20000一平，房子的价值也就占30%，剩余的都是土地的价值</p></blockquote><h2 id="提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）"><a href="#提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）" class="headerlink" title="提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）"></a>提议通过征普税调节贫富差距，不是傻，就是坏（制定政策的人不会让政策针对自己，那么政策都是谁制定的呢）</h2><p>今天看到搜狐上一篇文章说道要通过征税来调节贫富差距，提出这个方案的人不知是无知还是故意，如果zf听了这种无耻参谋的建议，不知道多少老百姓会活的更惨。</p><p>假设出台又一个新税种，无乱它叫什么，我们暂定为财产税。既然有了新税种，就要定任务，那好了为了这个税种制定了年上缴多少多少的任务。</p><p>实操的时候，执行的工作人员发现一旦轮到权贵脑袋上的事就没办法执行，你执行，他先让你下课。</p><p>但是任务必须完成，那还是从普通老百姓身上打主意吧。于是政策就完全走样了，非但起不了劫富济贫的目的，反而加重了穷人的负担。</p><p>往近里说，个人所得税，挣的是谁的税？权贵没看见交，月薪3000块的工薪层可一个都跑不了。3000块月薪上缴的个人所得税你看着不多，可对于养孩子糊口的老百姓来说，哪怕10块钱都是重要的。他们可没有资本象月薪上万的小资一样动不动花500块钱泡个吧。</p><p>个人所得税是有任务的，工作人员必须完成任务，税别管是局级干部交的，还是连孩子幼儿园都上不起的穷光蛋交的，总之完成任务就是好样的。既然局长的税收不上来，就要从穷光蛋身上加倍收上来。</p><p>往远里说，王安石变法是怎么失败的，以史为鉴可以知得失。王安石的初衷难道不是好的吗，可结果怎么样呢？只有一个——民不聊生。</p><p>书生误国啊。</p><h2 id="调控带来的影响"><a href="#调控带来的影响" class="headerlink" title="调控带来的影响"></a>调控带来的影响</h2><p>许多兄弟关心房价什么时候会涨</p><p>那么先看看这次调控后都出现了什么样的现象。</p><ol><li>全国房产成交量大幅下降</li><li>一线城市房价略有下跌，但并不持续，到现在基本跌不动了</li><li>多数二三线城市房价不跌反涨，成交量逐渐回升</li><li>大多数二线以上城市租金持续上涨</li><li>农产品价格有上涨迹象，大蒜、姜等小品种农产品遭遇爆炒。</li><li>变化莫测的政策导致精英阶层出现移民潮</li></ol><p>还有什么，欢迎大家补充</p><h2 id="农产品的价格关系到影响稳定的吃饭问题"><a href="#农产品的价格关系到影响稳定的吃饭问题" class="headerlink" title="农产品的价格关系到影响稳定的吃饭问题"></a>农产品的价格关系到影响稳定的吃饭问题</h2><p>农产品价格的上涨是很值得警惕的。想买房子但嫌房子贵的都市白领对农产品的价格很不敏感，但是金字塔最底层的最大多数群众是很敏感的。领导们也很敏感。这牵扯到相当大比例人口的吃饭问题，稳定压倒一切。</p><h2 id="农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管"><a href="#农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管" class="headerlink" title="农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管"></a>农产品价格的抬头会导致物价全面上涨，但国家不会坐视不管且有能力管</h2><p>农产品价格的抬头将会导致物价全面上涨，在不引起质变的前提下，房价作为商品也不例外。这个引起质变的前提是出现饥荒的极端情况，这样的几率在现在社会很少。尽管干旱和洪涝使农产品大幅度减产，但是农产品还可以进口，国家还有粮食储备，保证全国人民填饱肚子还是不存在问题的。</p><h2 id="资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力"><a href="#资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力" class="headerlink" title="资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力"></a>资金会在优质资产之间流动，而决定优质资产价格的是精英阶层的购买力</h2><p>一线城市仍然沉默，国家队在积极运动。二三线城市的房价上涨的成交量的回升却给了市场一个明确的信号。这是资金运动的规律。国家队对一线城市的布局，迫使资金流向二三线城市。二三线城市相对（与一线城市相比）不高的价位给出了较大上升空间的预期。</p><p>全国富人买北京上海，全省富人买省会，房价的合理性已经不能用简单的本地平均收入来衡量。精英阶层的购买力才是关键。</p><h2 id="资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢"><a href="#资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢" class="headerlink" title="资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢"></a>资金流向规律决定了农产品和资产价格总有一个要涨，人为压制，一定会按下葫芦浮起瓢</h2><p>明年物价进入持续上涨期是一个不容回避的问题。</p><p>在资金总量不变的前提下，巨量资金推动农产品价格上涨或者推动房价上涨是一个必须的选择。</p><p>今年zf用行政手段严厉打击蒜和绿豆价格的暴炒，基本上没有起到作用，资金有自己的运作规律，光靠拿张悟本出气也不能解决问题。</p><h2 id="资金流向规律决定了洼地不会一直是洼地"><a href="#资金流向规律决定了洼地不会一直是洼地" class="headerlink" title="资金流向规律决定了洼地不会一直是洼地"></a>资金流向规律决定了洼地不会一直是洼地</h2><p>二三线城市的房价的上涨使与一线城市的差价缩小，为一线城市的发力提供了动能。</p><p>无论你喜欢还是不喜欢，都不是以人的意志为转移的</p><h2 id="大城市对近距离的小城市有虹吸效应"><a href="#大城市对近距离的小城市有虹吸效应" class="headerlink" title="大城市对近距离的小城市有虹吸效应"></a>大城市对近距离的小城市有虹吸效应</h2><p>许多人心怀房价肯定会跌回2004年的美好愿望，刻舟求剑似的思维错过了一次次购房的机会。在患得患失中，在牛刀的号角声中，在任志强的大炮声中，迷失了自我。</p><p>任何事物都是有其规律性的。关键是否有一双慧眼能够穿透重重的迷雾。</p><p>假设你是个投资客，你非要去石家庄和长沙买房子，结果发现不怎么升值，怨天怨地：</p><p>石家庄作为一个二线省会怎么会不涨？长沙的房价怎么那么低？</p><p>我们知道，北京的房子是全国有钱人买的，省会的房子是全省的有钱人买的。但是当省会城市距离一线大城市在6个小时高速以内，省里的有钱人的资金就会流向一线大城市，而不是省会。河北的富人一定会选择在北京投资房产，湖南的富人一定会选择广州深圳投资房产。</p><p>假设你是一个投资客，你去昆明旅行，发现昆明的房价甚至高过重庆，很不理解。你很疑惑昆明这么小的西部边陲城市投资价值在哪里？</p><p>昆明是云南省内唯一的大城市，且相邻的二线以上城市离云南省都比较远。云南地州资源丰富，虽然穷人占的比例大，富人的数量却也不少。昆明南有滇池，北有长虫山，作为一个700万人口的城市，土地资源非常稀缺。所以贵，一定有贵的原因。便宜一定有便宜的道理。</p><h2 id="决定房价的因素有很多，具体情况具体分析"><a href="#决定房价的因素有很多，具体情况具体分析" class="headerlink" title="决定房价的因素有很多，具体情况具体分析"></a>决定房价的因素有很多，具体情况具体分析</h2><blockquote><p><strong>zzz4697：</strong></p><p>楼主针对南昌的房价做个分析吗？从刚公布的100个城市房子均价看，南昌5k每平左右，是高了还是低了？</p><p><strong>kkndme：</strong></p><p>对于不了解的城市不敢妄下断言。没到现场调查就没有发言权啊。</p><p>房价会不会涨还要看dfzf的规划。<br>比如广州拥有大量的城中村，其周边有较多的大城市，广州的房价就比北京和上海低。如果广州的城中村一旦大规模拆迁，房价将会大幅上涨。</p><p>比如南宁东盟贸易自由港的概念使南宁的房价涨幅惊人。</p><p>南昌的地理位置，zf规划，发展前景，江西富裕人口的多少，都是决定房价的因素</p></blockquote><h2 id="房价暴涨是相对于钱而言的，不是相对于实际购买力而言的"><a href="#房价暴涨是相对于钱而言的，不是相对于实际购买力而言的" class="headerlink" title="房价暴涨是相对于钱而言的，不是相对于实际购买力而言的"></a>房价暴涨是相对于钱而言的，不是相对于实际购买力而言的</h2><blockquote><p><strong>tjOOSAN：</strong></p><p>。。。。。。暴涨之后。。。。。。</p><p>我们不就是第二个日本吗？</p><p>供求关系？供求关系，现在是谁在决定？国家！</p><p>国家的经济结构决定的。制造业的资金都进入房地产了。能不涨吗？普通人有几个可以够炒房资格的？</p><p>日本 当初也是供求关系！~~ 供求关系的根本也不应脱离，国家的经济实力！！</p><p>还暴涨？怎么涨？再涨都够去美国买房了！！ 你这不扯淡么</p><p><strong>kkndme：</strong></p><p>中国和日本最大的不同在于日本的货币是开放的，中国的不是，是不能自由兑换的。</p><p>暴涨是相对于钱而言的，不是相对于实际购买力而言的。</p><p>80年代工资200多块钱一个月的时候，是不能想象90年代末北京城区5000每平米的房价的。那时候万元户已经是富人的代表了。</p><p>90年代末工资1000块钱的时候是不能想象现在30000一平米的房价的。90年代的100万绝对是富裕群体。可现在连个中产都算不上。</p><p>货币的持续贬值你没有考虑</p></blockquote><h2 id="土地不稀缺，优质土地稀缺"><a href="#土地不稀缺，优质土地稀缺" class="headerlink" title="土地不稀缺，优质土地稀缺"></a>土地不稀缺，优质土地稀缺</h2><blockquote><p><strong>tjOOSAN：</strong></p><p>在反驳楼主一句！！</p><p>在中国的土地，可不稀缺！~~ 只是没开发罢了！！~~</p><p>中国与世界不同！ok？13亿人！！用十三亿的居住权作为市场竞争的资本。</p><p>那太可怕了！真的！！！如果可能，中国绝对可以产出世界第一贵的地价！</p><p>为什么？这么多人需要房子。能不涨吗？</p><p>呵呵！多少有点扯淡！！别再提供求关系了！~~ 供求根本是平衡的！！</p><p><strong>kkndme：</strong></p><p>中国有13亿人口，960万平方公里土地，土地一点不稀缺。</p><p>但假设你在北京西城上班，让你去塔特拉马干买房子，你愿意去吗？</p><p>全国有点钱的都要在一线城市和省会城市买房子，所以才会稀缺。</p><p>大兴安岭有大量的土地，哪个有钱愿意跑去置业呢？</p></blockquote><h2 id="集中发展大城市是导致优质土地稀缺的原因"><a href="#集中发展大城市是导致优质土地稀缺的原因" class="headerlink" title="集中发展大城市是导致优质土地稀缺的原因"></a>集中发展大城市是导致优质土地稀缺的原因</h2><p>中国经济发展不平衡，牺牲全国大多数城市和乡村，来保证北上广深及大部分省会城市的繁荣才是造成土地稀缺的愿意。</p><p>土地有的是，房子有的是，但好位置的土地和房子并不多。</p><p>一方面大量的小县城和乡镇、村庄人口锐减，因为缺乏谋生手段不得不背景离乡外出打工，另一方面超大型城市越来越拥挤，土地资源越来越稀缺。</p><p>这就是中国集中发展极少数标杆城市所造成的呀，也是因为如此，才造成了中国金子塔式的收入结构，贫富差距越来越悬殊。</p><h2 id="为人民服务是说给人民听的"><a href="#为人民服务是说给人民听的" class="headerlink" title="为人民服务是说给人民听的"></a>为人民服务是说给人民听的</h2><p>很多人很疑惑，贪官越来越多，根本不把老百姓的利益放在心里，这些贪官即使被曝光了，还能继续当官。这是为什么呢？</p><p>首先理解一下老百姓，也就是民到底是什么？</p><p>民就是牛养，古代的时候，官员管理百姓叫做牧。官员管理百姓就是替君主放牧，只要保证牛羊不逃跑，不骚乱，那么就是合格的官员。</p><p>秦始皇暴政，百姓揭竿而起，可是陈胜起事后基本视民众如草芥，项羽屠杀平民比始皇更残暴。</p><p>萧何是一个很贤德的人，对百姓很好，赢得了很高的名声。刘邦在广武山和项羽对峙，得知了萧何在关中深受百姓爱戴，就疑心萧何要造反。一个君主爱民如子是为了百姓的支持，江山永固，一个臣子对老百姓好是不是要造反呢？于是派人去调查萧何。</p><p>萧何是个聪明人，感觉到刘邦已经不信任他了。于是赶紧改变工作作风，开始霸占百姓的田产，上大街欺负漂亮的妇女同志，并且派自己的子女上前线给刘邦做人质。</p><p>刘邦看到了萧何的行为非常高兴，知道萧何不会造反就放心了。</p><p>百姓不是牛羊是什么？</p><p>在红色高棉统治下的柬埔寨人，民连牛羊都不如呀。</p><p>波尔布特同志坚持gongchanzhuyi的按需分配，取消了货币。于是市场经济完全没有了。群众完全变成了按阶级分配了。</p><p>阶级只分为两种，波尔布特老板及其打手是绝对的统治阶级，其他人为被统治阶级，也可以称为奴隶阶级。统治阶级对奴隶阶级不爽可以直接拿ak47突突。柬全国700万人口被波老板突突死了100万，当然不光是突突，还有活埋。</p><p>以至于越南派了10万军队侵略柬埔寨，受到了柬埔寨人民的夹道欢迎，称为解放人类的战争。</p><p>公道自在人心</p><h2 id="历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙"><a href="#历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙" class="headerlink" title="历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙"></a>历史是一面镜子，不同的国情决定了采取同样的政策结果可能是南辕北辙</h2><p>博古才能通今，不了解历史无法治理国家，不了解历史也无法对事务有一个清楚的认识。</p><p>我们的今天本来就是历史的延续，前人经验和智慧的总结，不是一句话就可以抹杀的。</p><p>因为秦以后漫长帝国时代的大一统，才会把中央集权延续到现在。</p><p>而西方封建时代延续到地理大发现，诸侯割据王国、公国、侯国林立为现代的西方提供了民主制度的可能。</p><p>在制度上完全的不可比性，使向国际接轨成为了笑话。</p><p>我们看到的结果就是，物价上涨与西方接轨，甚至堂而皇之的超过西方，体制外的工资则与非洲结果，也算是国际化了。</p><h2 id="zf限制政策房的利润，那kfs就一定会偷工减料"><a href="#zf限制政策房的利润，那kfs就一定会偷工减料" class="headerlink" title="zf限制政策房的利润，那kfs就一定会偷工减料"></a>zf限制政策房的利润，那kfs就一定会偷工减料</h2><blockquote><p><strong>mellyzhang：</strong></p><p>大家听过那个西三旗的有名的限价房——旗胜家园吧<del>！外表看起来那么光鲜，地段也不是特别偏，紧邻城铁，当然是被人疯抢都抢不到的两限房呀</del>！还不是质量问题一大堆。</p><p> ZF安排的政策房也是要KFS建的，哪个KFS没肉吃还能保证把房子盖好？？！！所谓检测都TMD是虚的~。</p><p><strong>kkndme：</strong></p><p>这是肯定的，开发商都追求利润最大化。</p><p>zf建设两限房限制开发商利润，开发商必然偷工减料，zf都知道怎么回事，必须争一只眼闭一只眼，否则这个政策就执行不下去了</p></blockquote><h2 id="屁股决定脑袋，人民不知厉害关系选房子，zf选农产品"><a href="#屁股决定脑袋，人民不知厉害关系选房子，zf选农产品" class="headerlink" title="屁股决定脑袋，人民不知厉害关系选房子，zf选农产品"></a>屁股决定脑袋，人民不知厉害关系选房子，zf选农产品</h2><p>对于渴望拥有一套产权住房的都市小白领对希望房价狂降已经到了歇斯底里的程度，他们赞成农产品价格放开，让资金炒作农产品，而离开房地产市场。理由很简单，一套房子一涨就是几十万甚至上百万，而大米小麦，一斤就算涨到10块，也根本不能影响到自己的生活质量。</p><p>如果我国农产品价格是开放的，资金流向大米、小麦、猪肉，并且允许囤积，房地产一定会下跌的，这是毫无疑问的。</p><p>但是，我们看到的绝不是10块钱一斤的大米、小麦，而是500块钱、1000块钱一斤的大米、小麦。</p><p>我国将会出现大面积的饥荒，几千万甚至上亿的底层人士饿死街头，社会将出现大的动荡。</p><p>而产权房屋价格的上涨牺牲的主体只是体制外部分都市白领的利益，换来的不过是网络上没完没了的牢骚和咒骂。</p><p>巨量资金必须有地方去，如今面临的房地产和农产品之间的选择，你认为zf会怎么做？</p><h2 id="各个阶层的住房问题都安排的妥妥的"><a href="#各个阶层的住房问题都安排的妥妥的" class="headerlink" title="各个阶层的住房问题都安排的妥妥的"></a>各个阶层的住房问题都安排的妥妥的</h2><p>体制内中层、高层可以分到多套福利房，低层至少能够分到一套保障房，即使最不重要部门的底层员工，搞到由单位补贴的公租房是没有问题的。</p><p>体制外的高层、中层，以他们的资金实力买多套房子都是不成问题的。</p><p>农民，分配有宅基地。国家要稳定，首先就是要农民稳定，因此我国只有农民能够分到土地自己盖房子。</p><p>军人，会享受到比公务员更好的福利，让军人享受更高标准的福利待遇，国家有深刻的认识。</p><p>那么只有体制外的都市中下层群众才是高房价的受害者，可是这个群体的地位真的很微不足道。</p><h2 id="顶层的岁月静好来自于底层的负重前行"><a href="#顶层的岁月静好来自于底层的负重前行" class="headerlink" title="顶层的岁月静好来自于底层的负重前行"></a>顶层的岁月静好来自于底层的负重前行</h2><p>这些既无稳定工作（低层都市白领失业的概率还是蛮大的）又无自己的房产的都市小白领是金子塔底层被压榨的对象，甚至远远不如交通便利地区的农民。</p><p>没有这个群体的存在，金字塔上层的权贵是无法享受舒适的生活的。</p><p>社会需要底层群体用巨大的付出和极少的收获为金字塔上层群体服务。</p><p>当然，在巨大的付出后，有少数人会从低层脱颖而出，爬到金子塔的中层、甚至上层。 <br>这些少数人带给了底层群体奋斗的希望。</p><p>拥有一套属于自己产权的房子，就只有一套路：从金字塔的底层往上爬。这条路很艰辛，并且会越来越艰辛，但总有希望。</p><h2 id="底层指的是体制外底薪白领"><a href="#底层指的是体制外底薪白领" class="headerlink" title="底层指的是体制外底薪白领"></a>底层指的是体制外底薪白领</h2><blockquote><p><strong>天地间间：</strong></p><p>楼主有一点没说透彻，那就是白领的工资普遍较高，他们有能力买房子，但是受到几千年以来的小农经济思想的约束，他们普遍认为买房子不划算，占便宜心里普遍严重，别看他们外表光鲜，其实还都是一帮农民</p><p><strong>kkndme：</strong></p><p>我说的是买不起房的低收入小白领</p><p>高薪白领不买房的不多吧，都是网上吹的吧。</p><p>高薪白领一般还是有自住房的，只是有人不愿意投资房产。每个人想法不同而已。</p></blockquote><h2 id="资金终会流向具有稀缺性的资产"><a href="#资金终会流向具有稀缺性的资产" class="headerlink" title="资金终会流向具有稀缺性的资产"></a>资金终会流向具有稀缺性的资产</h2><blockquote><p><strong>天地间间：</strong></p><p>请问楼主所说的低薪白领一个月赚多少钱算底薪？</p><p>就拿我说吧，我06年买的房子，当时月薪3000元，这在当时算不算低薪？</p><p>但是我买房了，还是一个人买的，当然老爸赞助了点。每个月还完月供兜里就剩几十元，硬扛下来了。</p><p>目前年薪12万，我老婆年薪6万？这算不算高新？</p><p>如果我当时没买房子，以我们2个人的收入当下也买的起，只不过生活负担重一些。</p><p>所以请楼主明示，什么是低薪？</p><p><strong>kkndme：</strong></p><p>兄弟，你所描述的是另外一个问题。先说说你所说的这个问题，再谈谈什么叫低薪</p><p>先说06年你月薪3000买房子的问题。</p><p>我们打一个比方：</p><p>假设80年代，咱们两个月薪都是100块。你喜欢清朝的瓷盘子，咬咬牙，一年用好不容易攒下的100块钱买了清朝瓷盘子。我喜欢缝纫机，用一年好不容易攒的钱买了一个缝纫机。</p><p>市场有价值发现功能。显然，80年代清代瓷盘子的价值没有得到发现。</p><p>进入90年代，随着社会的发展，社会财富的增加，钞票也大幅度增加。清代瓷盘子的市场价值发现出来了，瓷盘子价格开始大幅上涨，你的瓷盘子由100块涨到1000块。而我买的缝纫机已经淘汰了</p><p>瓷盘子具备投资品的一切属性，能够吸收社会的富裕资金，而缝纫机没有这个功能。我很眼红，我虽然买的起这个瓷盘子（因为90年代我的工资由100涨到了800），但是我觉得价格太高了，没有买。而你的瓷盘子在90年代为你挣了900元钱。</p><p>时光又到21世纪，社会资金越来越多，钞票越印越多，可瓷盘子在市场上越来越少（都被收藏了），于是瓷盘子涨到了1千万一个，我即使想买瓷盘子再也买不起了，而不是嫌价格高的问题。而你已经成为了千万富翁。那个瓷盘子也并没有因为1千万的价格实在太高而暴跌，相反价格仍以每年20%的速度增长。</p><p>06年你在房价价值发现的初期买了房子，就像90年代你用1000块买清代瓷盘子。</p><p>如果你的工资不变，或者变化不足够大，现在你将没不起房子，就像你在21世纪不可能买的起瓷盘子。</p><p><strong>天地间间：</strong></p><p>楼主啊，你有一个概念错误：清代的瓷盘子是收藏品是古董，其价值是由拥有瓷盘子的收藏家决定的，而房子是商品（我指的是商品房，不是公租房之类的保障房），其价值远没有古董增值速度快，所以说收藏品和商品是有区别的。</p><p><strong>kkndme：</strong></p><p>呵呵，商品房当然和清代磁盘是不同的，升值空间不同，投资对象也不同，但价值发现的道理是一样的。投资品的基本属性：稀缺性是共有的，当然稀缺的程度不同。</p><p>我所讲的是投资品的价值发现，而不是商品房&#x3D;清代瓷盘</p></blockquote><h2 id="土地的稀缺决定了大多数人永远买不起想买的房子"><a href="#土地的稀缺决定了大多数人永远买不起想买的房子" class="headerlink" title="土地的稀缺决定了大多数人永远买不起想买的房子"></a>土地的稀缺决定了大多数人永远买不起想买的房子</h2><blockquote><p><strong>天地间间：</strong></p><p>此外，您还没有正面回答我什么是低薪</p><p>我今年30多岁，如果我刚毕业肯定是拿底薪的，往最坏了想，我毕业几年到今年混的不好，今年只赚3000元一个月，我就买不起房么？</p><p>如果你觉得是，那么你错了，我仍然可以买的起，我会到比较偏远的地段去买房子，比如密云，延庆等买套小户型二手房，那里的房价我仍然可以支付月供，当然我还是要像老爸要点钱付首付的。</p><p>可是如果我不这么想，觉得去哪里不划算，在四环里买房子多好啊！那么我可能就买不起了，因为在四环里买房已经超出了我的能力</p><p>那么请问我买不起四环里的房子是房价的问题呢还是我的问题呢？是不是说我买不起四环里的房子就是我买不起房？</p><p>综上所述，每个人都有自己的能力极限，不同能力的人去不同的地段买房子，一味的强求自己做能力不及的事情，反而还怨天尤人的，这就是小农意识。</p><p><strong>kkndme：</strong></p><p>如果我们买首套房，不是为了投资。我们买房总有个基本的要求：</p><p>有一个自己的家，并且上班相对方便</p><p>如果你在长城饭店上班，你跑去密云买个房子。首先你上班就成问题。</p><p>如果我月薪3000块，我甚至不能在密云买房子（因为也上万了），但我可以在山西的某个县城买套房子。问题是我买这套房子干什么？</p><blockquote><p><strong>先天下之友：</strong></p><p>请问楼主，在密云延庆买房子就不能去长城饭店上班吗？貌似密云延庆的城轨马上就要开通了，一个小时就可以到三元桥的，如果你仍然觉得不可能，那么我就很同情生活在东京纽约的白领了，他们买房子都在离工作单位50-100公里的地方，他们大部分人也靠城铁上下班的，所以说东京和纽约的白领生活在水深火热中啊</p><p>此外，密云和延庆的二手房子10000元一平？用不用我贴个卖房帖子啊？密云和延庆县城里的二手房子均价6000一平，一居室50平吧，总价 约30万，首付12万，月供1200元左右，这个对于月薪3000元的人来说是不成问题的，当然去密云延庆买别墅确实是10000元一平。</p><p><strong>kkndme：</strong></p><p>这种抬杠没什么意义，如果密云的轻轨修通了，1小时到三元桥，密云就由远郊区变为了近郊区，房价也不会维持现有水平，一定会水涨传高。</p><p>我没看过密云的规划，如果真有这个规划，且密云房子还没有大涨的时候，还时值得购买的。</p><p>密云的房价我倒真没去看过，不过以前有个住密云的同学说密云的新盘1万多了，老房子价格我并不知道。</p><p>我们只不过打的一个比方，假设密云到城里上班没有问题，普通小白领又买得起，那么不买的可以称为傻空。</p><p>但是确实有真正买不起的，连密云也买不起的，月收入3000，但要供养老人和孩子的，即使能在河北某个县城买，可是房子不能上班就完全没有意义了。</p></blockquote><p><strong>天地间间：</strong></p><p>我的中心思想是：北京的白领普遍买的起房子，但是有一部分不买，其原因是想花最少的钱去获得最好的地段，最好的楼层，最好的朝向的房子，这是划算不划算的问题，不是买得起买不起的问题</p><p>当然有的人会说：买房了，得病了怎么办？失业了怎么办？一大堆怎么办！那么请问：既然你知道早晚要见马克思，为什么现在还活着啊？一刀了断了算了，呵呵</p><p><strong>kkndme：</strong></p><p>你说的这类人其实是因为贪婪和恐惧，幸运不会垂青即贪婪又恐惧的人。用天涯的语言来说：就是传说中的傻空</p></blockquote><h2 id="不同阶层的人对收入高低有不同的理解"><a href="#不同阶层的人对收入高低有不同的理解" class="headerlink" title="不同阶层的人对收入高低有不同的理解"></a>不同阶层的人对收入高低有不同的理解</h2><p>再说说收入高低，不同城市，不同消费水平，对收入高低有着不同的理解。<br>我们举北京为例。</p><p>反映真实居住成本的是房屋租金，而不是房价。</p><p>在北京生活，一家三口的通常情况</p><p>一个位置能够满足上班条件的两居室租金大约3000元，小孩花费没有3000块是下不来的，再加上夫妻俩2000元的基本生活花费，也就是说8000月收入的家庭，刚好能达到收支平衡。</p><p>如果是体制外的都市白领，这个收入是很可怜的，因为还要考虑到失业问题，并且应付万一发生的意外支出。所以每月能有2000元的结余是必须的，那么10000元是在北京生活的基本水平。</p><p>而购买商品房所支付的金钱是要远高于租金成本的，因为你买的不是房屋居住权，而是房屋的产权，一定会出现溢价。</p><p>如果你现在的家庭收入能够再买得起一套房子，那么你的收入水平应该至少是小康，甚至达到中产</p><blockquote><p><strong>天地间间：</strong></p><p>楼主，一对有工作经验的年轻的北京白领夫妻月收入只有8000元？这是怎么统计的？</p><p>您的统计结果不准啊，我的结论是10000-12000元&#x2F;月是北京标准的白领夫妻的月收入，那么这笔钱能不能买房子？</p><p>能，能不能付首付？可能不能，首付款怎么来的？一部分是父母赞助的。</p><p>作为父母就要把自己的孩子扶上马，再送一程，这和啃老没关系</p><p><strong>kkndme：</strong></p><p>呵呵，这个也不好这么说，不同行业间的薪水差距实在太大了。</p><p>比如一个有6、7年职业学校的教师或者一个有5，6年电脑分销经验的产品经理（都是大学毕业），他们辛辛苦苦干一年多点的也就7、8万块。他们都不晓得招商银行随便一个客户经理轻轻松松年薪几十万。</p><p>同是大学毕业，同是5、6年工作经验，北京几十万年薪收入的人不少，但一个月只挣3、4000块的数量更庞大。</p><p><strong>先天下之友：</strong></p><p>楼主，我说的是北京白领夫妻的标准工资，什么是标准工资？就是这个城市的可提供工作岗位加权平均工资，也就是说，你在北京混，正常的情况下，北京的白领夫妻在成为这个公司的主力员工以后就可以拿到的工资，什么是主力？就是在你的单位里能够独立挑起一滩活。</p><p>此外，在北京的白领，月薪3000元在大多数公司都是起薪价，工作几年后工资翻一番的比例很大，我在北京混了很久了，我相信在北京的绝大多数老板是给员工出路的，楼主你说是么？</p><p><strong>kkndme：</strong></p><p>我倒是觉得平均工资真没有什么意义。</p><p>你在中石化工作，各种收入加一起一年低于20万的还真没有。</p><p>你做基金经理年薪低于100万的还真不好找。</p><p>你在电力系统，有点职务的，一年搞个上百万都是轻轻松松的。</p><p>你要是公务员有点级别，好的一年收入上千万，不好的一年收入也就十来万。</p><p>但你要是在某个私营或者股份公司做个人事，行政，一年弄好了也就几万块钱</p><p>你要是做销售，好的销售年薪几十万，上百万，不好的销售一年也就挣2、3万。</p><p>我真不知道平均工资意义在哪里？</p><p>一个年收入千万的总经理跟100个失业的白领平均，人人都是年收入10万</p><p><strong>先天下之友：</strong></p><p>我还是要强调白领的平均工资，这个很重要，也是很多北漂留下来的重要理由，不同行业收入不同，但是主流行业的收入差距是不大的，至于你说的中石油和其他的高薪公司这个一般人进的去么？</p><p>至于失业问题，这个和国家的政策密切相关，属于不可抗力，一味的强调这一点没意思</p><p><strong>kkndme：</strong></p><p>如果仅指北漂而言，一般大学毕业的普通北漂白领有个几年经验的月薪大概是8000-15000不等吧。北漂几年的普通家庭月收入在15000-20000.</p><p>这个收入，即使在现在，在北京五环以外买房还是没问题的。</p><p>低于这个收入，真的考虑回家吧</p></blockquote><h2 id="一二线买房只会越来越难，最终租房会成为主流"><a href="#一二线买房只会越来越难，最终租房会成为主流" class="headerlink" title="一二线买房只会越来越难，最终租房会成为主流"></a>一二线买房只会越来越难，最终租房会成为主流</h2><p>在北京一个年薪15万的普通家庭仍然买的起房，在五环外，只是你愿不愿意买。</p><p>但以后一个年薪15-20万的普通家庭买房子，即使是五环外的，也只能是梦想了。</p><p>租房将成为今后小白领主流的生活方式。</p><h2 id="人需要一个安身之所，能买早买比晚买好"><a href="#人需要一个安身之所，能买早买比晚买好" class="headerlink" title="人需要一个安身之所，能买早买比晚买好"></a>人需要一个安身之所，能买早买比晚买好</h2><blockquote><p>房价是由土地决定的，而土地是咱们这个国家的根本，当年不就因为要改变土地的属性，才有了我们的党。</p><p>凡房屋也都是只有土地的使用权，土地属于国家，说收回的话不管你有无房证更不会和住房者商量，如（拆迁），这个性质决不变，想下，对有房者如此，会为了没有房子的而制定均衡均分的土地政策下降房价吗？</p><p>现在贫富分化越来越严重，真买的起房的考虑的重点不会是贷款，买不起的，房价跌去三分之一也还是买不起，不要看政府如何了，如果能少贷款或不贷款买处房的话就买吧，人早晚得有个安身之所，不要贪大求全，战争或地震来了房子不值钱，但万一战争或地震不来呢？</p><p>kkndme</p><p>没错，就是这个意思，如果战争来临，你手中的钱也变成废纸</p></blockquote><h2 id="股市"><a href="#股市" class="headerlink" title="股市"></a>股市</h2><blockquote><p><strong>新智战者：</strong></p><p>楼主对楼市的分析让人佩服！能否谈谈股市？现在的股市不管涨跌，我只是看到ZF在疯狂的发行新股大盘股，压大盘是肯定的了，看样子又是下一盘很大的棋！</p><p><strong>kkndme：</strong></p><p>你要注意2010年的股市与以往是不同的。因为股指期货的出现。</p><p>要时刻关注股指期货投入的资金量。</p><p>当股指期货资金量足够大的时候（什么叫足够大就要看个人的判断了），期指将指导沪深300指数。大盘会跟着固执期货走</p></blockquote><h2 id="如果房价不涨，那其他产品会怎么涨"><a href="#如果房价不涨，那其他产品会怎么涨" class="headerlink" title="如果房价不涨，那其他产品会怎么涨"></a>如果房价不涨，那其他产品会怎么涨</h2><blockquote><p><strong>lfastro：</strong></p><p>“上帝欲使其灭亡，必先使其疯狂！”</p><p>很想看看“报复性上涨”是个什么样子。</p><p><strong>kkndme：</strong></p><p>你可以这样理解（只是为了理解方便做个示意）：</p><p>假设房价从2004年的4000一平，涨到2010年的20000一平</p><p>猪肉从2004年的6块一斤，涨到2010年的10块一斤。</p><p>但是如果房价2004年4000一平，到了2010年还是4000一平</p><p>那么，猪肉从2004年的6块一斤，将在2010年涨到30块一斤，不仅猪肉，还有大米，小麦，大蒜、葱、姜、房租都会翻几倍的价格。</p></blockquote><h2 id="zf如何利用公租房控制租房市场"><a href="#zf如何利用公租房控制租房市场" class="headerlink" title="zf如何利用公租房控制租房市场"></a>zf如何利用公租房控制租房市场</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>政府要垄断房租市场？市场上已有的和不断要产生的出租房源政府怎么让它们消失呢？</p><p>还是说政府要造足够多的公租房来占据市场主体 那就更难了 要花多少钱呀 公租房的地段好不了的</p><p><strong>kkndme：</strong></p><p>公租房将为房租市场树立一个标杆。有了这个标杆，私人出租房将会对比公租房做一个参照。</p><p>公租房是有限的，是需要申请的，而私人出租房会在相同位置将自己的房租定价高于公租房。</p><p>这样就保证了公租房的价格低于市场。</p><p>公租房不是廉租房，zf要持续赚钱，他的定价不会低，私人房就会定得更高，这将导致市场上的房租整体上涨。</p><p>公租房的吸引力在哪里？</p><ol><li>对体制内会有单位补贴</li><li>对体制外人员可以提供一个较长的稳定租期。</li><li>zf定价的标杆作用，无论怎么定价，公租房都会低于周边市场价格.</li></ol></blockquote><h2 id="城中村不会长期存在"><a href="#城中村不会长期存在" class="headerlink" title="城中村不会长期存在"></a>城中村不会长期存在</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>城中村可是提供廉价房源的地方 这个公租房的竞争对手肯定要被政府干掉 所以城中村的拆迁改造那是一定的</p><p><strong>kkndme：</strong></p><p>城中村一定会消失的，不消灭城中村，哪来的GDP</p></blockquote><h2 id="三四线城市的未来"><a href="#三四线城市的未来" class="headerlink" title="三四线城市的未来"></a>三四线城市的未来</h2><blockquote><p><strong>alice_xg：</strong></p><p>写得非常好</p><p>楼主能否分析下未来三四线小城市的发展，是否会空心化</p><p>另外，请分析下海南的城市有没有投资价值</p><p><strong>kkndme：</strong></p><p>四线城市房价也会缓步上涨，但比较慢，主要还是因人工成本，原材料价格上涨造成的建筑成本上涨。</p><p>城市的空心化可能性不大，人口仍然会缓慢增长。但偏远乡镇却存在空心化的可能。</p><p>海南具备得天独厚的海岸线资源，这是全国任何一个其他海滨城市无法比拟的（其他的海滨确实比较差，毫无美感）。但关键还是zf如何开发，急功近利的开发，和毫无节制的圈海岸线可能会大幅降价海南的旅游与投资价值。</p><p>取决于政策，有较高风险</p></blockquote><h2 id="房租价格涨不上去，本质是买房还看起来有希望"><a href="#房租价格涨不上去，本质是买房还看起来有希望" class="headerlink" title="房租价格涨不上去，本质是买房还看起来有希望"></a>房租价格涨不上去，本质是买房还看起来有希望</h2><p>今天下午才出门，上午闲来无事，跑来再说两句。</p><p>一是再说说房租问题，房租的发展趋势：</p><p>现在房租低的一个重要原因是因为，大多数都市小白领还希望能够买一套属于自己的产权房，至少他们觉得即使现在钱钱不够，但是努力一把，跳个脚还能够得着。所以他们省吃俭用拼命的存钱。一个月薪10000块的小白领租一套月租金3000元的还算舒适的两居室是没有问题的，但是他为了攒钱买房宁可几个人合租一室，仅仅愿意在居住上花费少得可怜的500元钱。</p><p>随着国家队的进入，民营资本的退出，房地产开发和房地产投资的门槛都会大幅度提高，投资房产以后就成为富人的专属。</p><p>小白领的生活将变得“轻松”，因为除非能够上位，否则一般人跳脚是够不到属于自己的那套房子的。对于拥有房产失去希望，将使他不得不搬出合租房而转而租住一套还算舒适的两居室。</p><p>高昂的商品房价把大量的小白领从合租房中解放出来，转而去租住两居室或者三居室。</p><p>房租的价格一定会通过市场发现功能，找到他的位置。</p><blockquote><p><strong>想住清合吗：</strong></p><p>看了那么久，突然间觉得，楼主会不会过于武断了？</p><p>尽管我也看好房价和房租都上涨，但是，买房应该不会只是富人的专属。例如在日本，有许多的普通白领买的起房，难道在中国，白领就买不起吗？</p><p><strong>kkndme：</strong></p><p>白领是分层次的，有技术，有能力，有背景，肯吃苦的白领将通过努力获得更多的收入，获取更高的职位，走进金字塔的中层，买房子肯定没有问题。但进入金字塔中层的绝不会占大多数比例。</p><p>低级白领，公司办公室普通职员，一无技术，二无资 没有特殊的技能或本领，又没有什么关系和背景，对机会的把握能力也不是很强，如果家里也不富裕，这样的同志今后买房子就比较困难了。金字塔的底层人数比例是最大的。</p><p>日本的国情确实跟中国有很大不同，另外日本东京的房子也不是普通白领买的起的。我认识个NEC的部长（相当于中国企业的总监），也算大企业的中层干部，他也在东京买不起房子，家在离东京很远的郊区。</p><p><strong>中年不惑吗：</strong></p><p>日本的城市化已完成 不过东京市中心的房子小白领是买不起的 他们买的是东京卫星小城市的房子 如同你在上海工作 去扬州买房子还是能承受的 人家的地铁一个小时能跑200公里 你说生活半径能扩大多少呢 再说日本是有选票的</p><p><strong>kkndme：</strong></p><p>没错，就是这个道理。天涯里有些人说年薪30万买不起房，年薪70万买不起房。原因还是期望太高了，以为自己年薪70万了，就是人上人了，就必须住市中心的大房子。</p><p>但事实上市中心的大房子是绝对稀缺的，人上有人，天外有天。</p><p>买房子还是量力而行。有1000万资产的人是买不起价值2000万的翡翠的。有1个亿资产的人也不能买下故宫的居住权。</p></blockquote><h2 id="稀缺房的价格永远涨"><a href="#稀缺房的价格永远涨" class="headerlink" title="稀缺房的价格永远涨"></a>稀缺房的价格永远涨</h2><blockquote><p><strong>sunxishila：</strong></p><p>我认为房价不可能跌的（至少5年内） ，尤其北上广，因为</p><ol><li>地球资源就那么点，美国人不可能允许所有的人都过上他们那样的高消耗生活，所以美国人就尽可能地创造无产阶级国家来为其当奴隶进行打工，中国的现状也一样，利益集团以及国家政府为了其利益以及维稳庞大的执政集团必须要通过工具将更多的人丧失生产资料以便当其奴隶。试想如果人人都有房住，人人都有闲钱可以自由的选择生活方式，我们以出口为主的血汗工厂还能招得到工人吗？北上广还能存在这么多外资企业吗？外资企业没的话，没这么多就业机会，所有的外地人回家了，上海的办公楼，出租房不全完蛋了 ，那么势必减少了各种税收，那么北上广正常的维持城市运行的资金必将断裂…怎么可能呢。</li><li>适度宽松的货币政策（也就是过量发行的货币）必将导致通货膨胀，在中国货币多了必将走进房地产，因为在中国基本没有别的更靠谱的投资渠道。长期看来，货币一直是贬值的 ，世界上几乎所有的国家货币一直都在贬值，这是货币的固有属性，就是剥削。除非取消货币，可能吗？</li><li>房价下跌或者价格合理当然是有可能的，可是这取决于政治，除非取消一党执政，除非土地似有话，原因相信大家都清楚，你们认为近期可能吗？</li></ol></blockquote><h2 id="粮食和房子的不同是，房子无法和土地剥离"><a href="#粮食和房子的不同是，房子无法和土地剥离" class="headerlink" title="粮食和房子的不同是，房子无法和土地剥离"></a>粮食和房子的不同是，房子无法和土地剥离</h2><p>二是再说说粮食问题</p><p>中国的粮食实行储备制度，国家每年从农民手里收购一定数量粮食以及进口一定数量的粮食用于储备。</p><p>中国的稻米主要出自东北和广西，东北米好吃但产量小价格高，广西米难吃但产量达价格低，都市人都愿意花高点的价格购买东北米。</p><p>各地储粮通行的做法是以储粮为名收购的东北米加价在市场上出售牟取利润，再低价收购难吃的广西米用于粮食储备。</p><p>米在市场上的价格差别还是很大的，好的东北米可以卖到5块钱一市斤，一般的东北米卖到3块钱左右一斤，差点的东北米卖到2块钱一斤。而广西米基本在2块钱以下，而且除非比较穷的，一般人都不愿意吃。</p><p>大家可以看到在市场上交易的大米跟其他商品并没有什么不同，好的稀缺的就贵，差的产量大的就便宜。 <br>但是米和房子不同，一方面米是当年的好吃，放到第二年陈了就不值钱了，第二年土地上新的稻子又长出来，会有新的米下市。但是房子不会，一栋楼今年卖掉了，明年这块已经卖掉了的土地并不能长出另外一栋楼。另一方面，中国实行的储备粮制度将会在粮食减产的时候平易粮食价格的上涨（尽管储粮和市场上销售的粮食完全不是一个品质），而且国家对口粮的问题会高度重视。 <br>粮食作为商品本身是与土地剥离的，而房屋作为商品却无法从土地剥离出来。这是粮食与房子的根本不同。</p><p>商人在粮食稀缺时期进行囤积会枪毙，在粮食丰收时期囤积粮食只能亏损（第二年的米就没人吃了。</p><p>商品房作为商品在市场上交易，而保障房是为了保障低收入群体的最基本居住，这与粮食分为储备粮和商品粮又多少有些相似。</p><p>但是商品房土地和房屋无法剥离，产权和居住权却是剥离的，这就使既保障人民的基本居住权，又通过产权的升值牟取巨大的利益成为可能。zf实在是再明白不过了。</p><h2 id="购买房价基数低的省会城市，怎么都不会亏的"><a href="#购买房价基数低的省会城市，怎么都不会亏的" class="headerlink" title="购买房价基数低的省会城市，怎么都不会亏的"></a>购买房价基数低的省会城市，怎么都不会亏的</h2><blockquote><p><strong>Razerwu：</strong></p><p>我也年纪小，07年才毕业，学经济的，人文历史基础有一点，关注房价有两年了。看了楼主帖子，更是开朗了。</p><p>升斗小民一定要跟形式跑，千万别一厢情愿，也别被媒体的话语误导了。</p><p>以后，征服会逐渐保证居者有其屋，但是不是每个家庭住的房子有自己产权。中国社会阶层分化很严重。主要分体制内和体制外两个群体。体制内的即使明摆着的收入一般，但是福利好。体制外的，有高薪的，但是低收入的更多。我们公司一般在年收入到手5-6W左右。这个应该是这个城市的平均水平了。我相信50%的人都在这个数。这个收入租个房子，除去其他生活开支，一年还能余个1,2W，如果是两个人一起生活，也能养小孩的，只是，你永远买不起自己的房子。</p><p>但是我也知道，更多的小白领，在空调房里工作，一个月就领1000来块的薪水，而那里房价也不低，8000-10000了。你还是买不起。</p><p>所以，未来你可以选择在房价高的地方生活，然后租房。你也可以选择回到三四线城市。但是很可能，到时候那里的房子价格也不低，如果你能力够，还是有希望买到商品房。</p><p>非常有钱的人很多，我不知道他们会怎样投资。</p><p>我想给一些跟我一样收入层次的人一些建议。</p><p>物价必涨，这是趋势，如今农村的农民都不怎么种地了，征服在搞平整，以后都会自动流转，每个村的徒弟承包给一个人，别的农民给他打工。有资金的农村出来的，可以考虑往农业方向发展。</p><p>我薪水收入一般，但是有外快，跟女友一块存钱，年收入超过20W，</p><p>楼主在帖子里提到长沙和石家庄的例子，我认为，二三线城市也要具体分析，像我老家长沙，房产升值空间还是有的，只要每年涨20%，我就满足了。一线城市的房子更稀缺，但是，城市化的进程，不可能继续像上一个10年那样，大家都往一线城市跑了。所以，房地产暴涨的时代我不相信还有。我还相信二线城市和一线的房价差距会慢慢拉近。</p><p>所以，我用09年的结余，在今年上半年长沙贷款买了一套，我准备下半年再买一套。我不是炒房，我是略有结余的工薪阶层，我选择保值，总比放在银行要好。事实证明我是对的上半年买的现在已经涨了10%了。</p><p>一线和省会城市的商品房，未来一定会成为更加稀缺的资源。</p><p><strong>kkndme：</strong></p><p>长沙的房子一定会涨，只不过涨得会比其他城市慢。</p><p>低价买涨幅滞后的房子有一个好处，一旦长沙放出“大量拆迁”等利好因素，你就赚大了。购买房价基数低的省会城市，怎么都不会亏的</p></blockquote><h2 id="房地产是资本市场还是实体经济？"><a href="#房地产是资本市场还是实体经济？" class="headerlink" title="房地产是资本市场还是实体经济？"></a>房地产是资本市场还是实体经济？</h2><p>还有一个关于实体经济的问题，房地产是资本市场还是实体经济？</p><p>我们回顾一下，房地产的居住属性和产权属性是剥离的。</p><p>依照房地产的居住属性，房地产绝对属于实体经济。</p><p>从下游来说，不搬新家重新购买一套家具、一套家电、做一次大的装修的可能性都不大。在没有改善住房的前提下，去换家具家电，搞装修的应该是一个很小的比例。</p><p>从上游来说，钢铁、水泥、机械等行业无一不受到到房地产的影响。</p><p>房地产影响到钢铁、水泥、机械、家电、家具、建筑建材等多种领域，影响真的不小。</p><p>依照房地产的产权属性，房地产又是资本市场。</p><p>资金推动了商品房价格的快速上涨。</p><p>房地产为政府积聚了大量的财富（卖地），这些财富用来建造地铁、公园、广场、办公大楼、公款招待、潇洒挥霍，又推动了实体经济的增长。</p><h2 id="什么是傻空"><a href="#什么是傻空" class="headerlink" title="什么是傻空"></a>什么是傻空</h2><p>关于买房量力而行的事，还是有必要再说得清楚些的。</p><p>还是打个比方</p><p>假设某人家庭月收入15000块（都市小白领的通常收入），工作6年，手里有50万存款，我可以在北京北五环外（比如西三旗或者回龙观）买一套价值150万的房子（2万每平米，70几平米）。首付50万，贷款100万，月供7000多，是完全买的起的，而且因为轻轨的开通，即使在市中心工作，上班时间肯定可以在2个小时之内（作为北京这个城市来说是可以接受的）。</p><p>但是这个人心比较高，非要在北四环内，买一套100平的住宅，二手房3万一平米，100平米就是300万。首付按30%算，也就是90万，还要贷210万，已经完全超过了他的收入水平及收入预期。于是这个人成天怨天尤人，成天喊自己买不起房，抱怨zf，憎恨炒房客和开发商。天天叫唤社会不公平。</p><p>过了1年，国家队布局完毕，西三旗、回龙观房价涨到30000一平米了，买个70平的还要210万。首付30%，要60多万，贷款150万，月供12000左右。这时，他买西三旗70多平米的房子已经很费劲了。</p><p>这种行为叫什么？这就叫傻空。</p><h2 id="什么是真买不起房"><a href="#什么是真买不起房" class="headerlink" title="什么是真买不起房"></a>什么是真买不起房</h2><p>再比如说</p><p>某人家庭月收入比较低，8000块，在北京上班，西三旗和回龙观的房也要150万的总价，是买不起的。他的收入水平只能在密云或者河北买房子，但是即使在密云或者河北买了房也没办法上班。这个人就叫做真的买不起房。</p><p>如果他对未来的收入预期也不是很高的话，房价未来的上涨将使他进一步对买方绝望，他将彻底放弃攒钱买房，带着老婆孩子搬出跟人合租的城中村，每月花费2500块钱在回龙观租一间两室一厅的住宅。</p><p>日子就这么过下去了。</p><p>量变将引起质变，8000块钱的家庭月收入，是真买不起房的家庭，而15000月收入的家庭买不起房就叫傻空。</p><h2 id="具体情况具体分析，如果看不懂，一定是没有抓住问题本质"><a href="#具体情况具体分析，如果看不懂，一定是没有抓住问题本质" class="headerlink" title="具体情况具体分析，如果看不懂，一定是没有抓住问题本质"></a>具体情况具体分析，如果看不懂，一定是没有抓住问题本质</h2><p>小时候看春秋战国之类的书籍，总弄不明白一个问题：</p><p>a国家跟c国家打，他的邻国b就会很害怕，害怕a国家灭了c国家实力更强大，对自己不利。</p><p>e国家跟g国家打，他的邻国f就会很高兴，高兴e国家与g国家两败俱伤，自己可以获取利益。</p><p>后来我终于弄懂了。</p><p>当a国家跟c国家打仗时，如果a的国力明显强过c,他的邻国b就会很害怕，因为a国家很轻易就会灭掉c国家变得更强大。</p><p>当a国家跟c国家打仗时，如果a的国力跟c差不多,他的邻国b就会很高兴，因为a国家跟c国家会拼得两败俱伤。</p><p>分析问题，一定要深入的研究啊</p><h2 id="桂林-vs-南宁"><a href="#桂林-vs-南宁" class="headerlink" title="桂林 vs 南宁"></a>桂林 vs 南宁</h2><blockquote><p><strong>leeyq88：</strong></p><p>楼主的观点高明，因为把房价与整个经济及政治层面的东西联系起来了。请教一个问题，桂林属于5线城市了吧，现在均价近5000，请楼主分析一下桂林这种级别城市房价的趋势。</p><p><strong>kkndme：</strong></p><p>缓慢上涨，有钱买南宁吧，东盟贸易提供了巨大的空间</p></blockquote><h2 id="公租房的量级不会冲击到商品房市场"><a href="#公租房的量级不会冲击到商品房市场" class="headerlink" title="公租房的量级不会冲击到商品房市场"></a>公租房的量级不会冲击到商品房市场</h2><blockquote><p><strong>vavan2010：</strong></p><p>楼主说得好，根据你所描述的，关于房租的这一块，我看到的前景是，由于国家队的加入和垄断，以后开发商只有可能是财雄势大集团的地产商和国家队这两种了。</p><p>而大量的建筑公屋，也是要分租赁市场的一杯之羹，又有公租房又有廉租房，再加上物业税的出台，这样愿意持有普通住宅多套的收租客会不会减少？</p><p>因为没钱买的会去租公租或廉租，有钱租的也去租高端好房，就象香港一样，有钱的买商品房，一般的买普通限价房，经济实用房，没钱的住公屋或廉租。反而持有普通住宅多套的会不会逐渐减少？</p><p><strong>kkndme：</strong></p><p>公租房只能是有一定量，不会是大量，首先解决的也是体制内的住房问题。持有多套住宅的有自己的市场空间</p><p><strong>醉生梦思1：</strong></p><p>这个问题很好解答，香港公租房占5成比例，私人租房市场委缩了吗？没有，这是市场上不同档次的产品，对应不同的需求。</p><p>就像有人看盘，绿化不好，没有游泳池的房子坚决不要是一样的道理。</p></blockquote><h2 id="贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体"><a href="#贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体" class="headerlink" title="贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体"></a>贵阳，资源的稀缺导致权贵更容易垄断，通过低收入高物价的方式剥削底层群体</h2><p>旅行的第一站，是贵阳。</p><p>一座低收入高消费的西部边远城市。</p><p>当地人说贵阳的消费太黑人，太畸形了。大多数当地人的收入相当于中部城市的县城水平，生活必需品的消费却超过了北京。</p><p>越偏远的地方越黑暗，越偏远的地方越不存在公平，越偏远的地方贫穷群众的比例越大，越偏远的地方权贵生活的越腐败、越奢华。</p><p>越是资源匮乏的地区，权贵阶层越富裕，这是以绝大多数人的贫穷为代价的。</p><p>资源的稀缺，导致权贵易于对资源形成垄断，通过以低收入高物价的方式，对底层群体进行赤裸裸的掠夺。</p><p>于是权贵们鲜衣怒马，下层群众褴褛衣衫。</p><p>贵州难道不是中国的缩影吗？</p><p>在欧洲的商业区，我国权贵们一掷万金，引来欧洲群众围观，瞠目结舌。以至于全世界都没法相信我国不是超级发达国家。</p><p>贵阳的近郊房价已经9000一平米，远郊的金阳房价已经接近了6000一平。</p><p>但是我们能就此判断贵阳的房价存在巨大泡沫吗？</p><p>贵阳到处是山，地少人多，物产极不丰富。</p><p>因此，贵阳的商品房就像贵阳的餐厅一样，和普通群众是完全没有关系的。而对于权贵与精英来说，即使再翻几倍的价格也一样买得起。（腐败啊）</p><p>看看贵阳，想想中国。</p><p>资源的匮乏将形成高度的垄断，导致贫富分化进一步加剧，生活成本大幅度提高，中国正走向低收入高消费的畸形社会结构，群众生活越艰难，权贵的生活就会越富足。 <br>生活必需品和房价都会变得比西方国家更贵。</p><blockquote><p><strong>fzh_0931：</strong></p><p>鉴定完毕，聪明的房托！<br>通篇围绕通货膨胀核心立论，既然商品房是商品，那就不具备投资品的一些属性，（帖子里关于清代磁盘子的案例很不错）为什么还要在这里忽悠呢？抵御通货膨胀的手段，除了买房以外还有很多不错的选择，为毛还在这里大谈特谈房价暴涨呢？既然在上世纪90年代是商品房价值发现初期阶段没有买进，那么到了现在这个所谓的价值发现中期或者后期阶段还有什么理由买进呢？（当然，没有自住房的例外，对于投资者来说，眼下投资房产恐怕不是最好的选择）我相信，随着通货膨胀的加剧，我们手里的钞票不断贬值，房子肯定还是会上涨，只不过不是暴涨和普遍上涨，会是局部的，具有某些概念的，那么试问，我们作为普通百姓，怎么才能未卜先知到底是哪一部分的房子会上涨？那一种概念的房子会上涨？恐怕也只有那些个具有神通的精英阶层才能知道，所以作为一个普通小民来说，俺是不会淌这趟浑水滴，俺自己够住就行，真要有天，时来运转，中了六合彩或者虾米大奖之类的，俺实在是不知道那钱做什么用时才会考虑在海南？还是杭州？抑或是南京买所蜗居来等待升值，否则俺只能望房兴叹。。。</p><p><strong>kkndme：</strong></p><p>从2005年开始</p><p>傻空眼里<br>凡是认为房价不会降的都是房托<br>凡是买房子的就认为49年加入国民党的。</p><p>装成傻空专骗真傻空的人，一面天天喊着房价暴跌，一面抄了一套又一套</p><p>真傻空除了骂街恨社会，什么也没得到</p></blockquote><h2 id="重庆：高层和别墅怎么选？"><a href="#重庆：高层和别墅怎么选？" class="headerlink" title="重庆：高层和别墅怎么选？"></a>重庆：高层和别墅怎么选？</h2><blockquote><p><strong>yourrainbow：</strong></p><p>Lz还在吗？咨询下重庆房价的走势呀！</p><p>投资别墅与高层的比较！</p><p><strong>kkndme：</strong></p><p>我个人很不喜欢重庆这个城市，但是我不得不说重庆的发展空间很大，无论是经济还是房价。</p><p>别墅，如果有钱投资，一定是别墅，只要不是太偏远的。</p><p><strong>hollybible2018：</strong></p><p>我给你解释为什么楼主推荐别墅了。看问题不是看短时间内，而是要看长远。</p><p>第一，中国富裕阶层追捧什么房型？别墅。要想富，先学会用富人的思维方式思考问题。</p><p>第二，随着中国经济越来越强，人均住房面积会进一步增加，人们选择的房型会由公寓逐渐转移到别墅。</p><p>第三，如果你有在欧美，日本这些发达国家的生活经验，你会知道，公寓是给穷人住的地方，而稍微收入可以的住的都是别墅型的房子。我国按照这样的发展趋势，是能达到这些发达国家的水平。我国曾经现在将来发生的事情都是那些发达国家曾经现在发生的事情。</p></blockquote><h2 id="货币贬值"><a href="#货币贬值" class="headerlink" title="货币贬值"></a>货币贬值</h2><p>刚从青岩古镇玩回来，饭前说说货币贬值。</p><p>货币贬值，来自于大量的印钞</p><p>可不可以少发点钞票。</p><p>对不起，不行。</p><p>这是我国的官有经济体制决定的。</p><h2 id="为什么美国人工高于中国，但大多数商品的物价却低于中国"><a href="#为什么美国人工高于中国，但大多数商品的物价却低于中国" class="headerlink" title="为什么美国人工高于中国，但大多数商品的物价却低于中国"></a>为什么美国人工高于中国，但大多数商品的物价却低于中国</h2><p>凡是去过美国的朋友，会惊奇一个现象 <br>除了人工服务行业，几乎大多数产品的绝对价格都低于国内。</p><p>从数码产品，到奢饰品，从矿泉水，鸡蛋到汽车，统统比国内的绝对价格（把美金换成人民币，再拿人民币进行比较）便宜。（美国的餐馆比较贵是因为包含了人工服务成本）</p><p>不仅仅是美国货比在中国卖的便宜，几乎所有made in china的商品在美国卖的绝对价格都低于国内售价（一件国内生产出口的服装在美国售价150人民币左右，但在国内售价竟然达到800-1000人民币）</p><p>贫穷的发展中国家——我们的物价却远远高于美国，这是什么样的原因呢？</p><p>我想主要还是我们的体制决定的：</p><p>1、高昂的行政成本</p><p>中国庞大的公务员队伍对货币的消耗达到惊人的程度。任何一种商品的销售都要分摊政府高昂的行政开支。不大量印钞票是无法维持正常运转的</p><p>2、过渡依靠政府投资。 <br>大家都知道，中国的经济发展，是依靠政府投资为主导的，全世界都知道，政府投资的效率是最底下的，1个亿的投资往好了说只能产生3000万的效益，剩余7000万损耗掉了。因此政府不得不持续增加货币发行量 <br>3、惊人的fb成本</p><p>一集中箱货物运到美国的成本甚至低于从北京运到深圳的国内运费。这是令人惊讶的事情，又是确凿的事实。中国高昂的高速费用使物流贵得吓人，从农民手中2分钱收购的蔬菜，运到了目的地，成本就变成了1元钱。</p><p>这中间不仅仅是高速费，当公路及铁路运输变得紧张的时候，你不得不花费比高速费更贵的支出用于打点关系。</p><p>关系的成本已经远远贵过商品本身。惊人的fb成本是物价上涨的重要原因，因为权贵贪心也是逐年增加的，fb成本越来越高。fb成本的每年高速增长，迫使印钞需求高速增长。</p><p>4、低附加值产品出口创汇</p><p>低附加值产品出口创汇是我国经济发展的主要支柱。</p><p>可以这样理解，我们的商品卖到了国外，换回的是外汇。国内的商品少了，就变贵了。换回的外汇，国家就会按照外汇的总金额依据汇率全都印成人民币，投放到社会。社会上不但商品变少了，每年还会多印出一大堆钞票，这就是通货膨胀。货币的购买力在持续贬值，国家通过货币持续贬值来收割普通劳动者的羊毛。</p><p>所以说我国高通胀，货币持续贬值，是官有经济体制所决定的。</p><p>是不可能改变的。</p><p>持有闲置现金的风险，比持有任何一种可保存的商品的风险都大。</p><h2 id="还能上车的赶紧上车"><a href="#还能上车的赶紧上车" class="headerlink" title="还能上车的赶紧上车"></a>还能上车的赶紧上车</h2><p>奉劝那些盼着zf政策出打击房产直到崩盘，以此得到高潮的同志们，真的不要等了，除非出现明末的极端事件，否则一辈子等不到高潮。</p><p>也奉劝希望房价能降个30%-50%好买套自己的房子的善良百姓，还是看有什么机会多挣点钱吧，等房价大降真的不现实。</p><p>百姓们希望领导们能给自己做个主，可是几千年以来，中国的上位者们从来都只考虑一个问题：“卧榻之上，岂容他人安睡。”真的没有时间管你们的那些小事儿。</p><blockquote><p><strong>中年不惑吗：</strong></p><p>大家应该知道所谓的康乾盛世，开元盛世都是什么样子了</p><p>上层阶级的盛世而已</p><p>底层老百姓在史书上连“某人甲，某人乙”都留不下</p><p><strong>dantez13：</strong></p><p>康乾确实是虚假的所谓“盛世”开元还是不错的</p><p>看历史不光纵向看 也要横向看</p><p><strong>kkndme：</strong></p><p>开元盛世留下巨大的隐患才导致玄宗悲惨的人生，不应简单的认为是杨玉环和安史之乱的原因。</p><p>首先是大量的土地兼并，大量的农民同志逃跑，社会的不安定为安史之乱埋下了隐患。还有就是节度使的权力太大，以全国之力供养节度使的军备，而内地养了一群废兵。</p><p>相当于老大把精兵干将派去边远山区收保护费，结果自己身边连个像样的保镖都没有。有个收保护费的领班突然不爽，自己想当老大，带着打手跑回去揍老大，准备上位。这时老大就光杆司令一个，看着自己的手下叛变之能干瞪眼</p><p><strong>dantez13：</strong></p><p>我说的看历史纵向横向的意思是指</p><p>康乾时期 纵向来看 还算是个稳定时期 但是17 18世纪 欧洲正轰轰烈烈的搞工业革命</p><p>乾隆却几下江南 还搞什么骑射乃满洲之本</p><p>而开元时期 ，虽然的确有很多隐患 但是大唐还是当之无愧的世界老大</p><p>唐朝也是那个时候达到的巅峰</p><p><strong>kkndme：</strong></p><p>呵呵，大唐当世界老大也不知道是好事还是坏事</p><p>欧洲经历了漫长的中世纪黑暗时代，结果由诸侯割据的封建社会直接进入了资本主义社会，并向国家社会主义过渡。</p><p>中国早在秦就结束了诸侯国林立的封建时代，进入了大一统高度集权的帝国时代，到现在也没完全结束。</p></blockquote><h2 id="武汉：城市发展空间的大小，往往和房价的升值空间成正比"><a href="#武汉：城市发展空间的大小，往往和房价的升值空间成正比" class="headerlink" title="武汉：城市发展空间的大小，往往和房价的升值空间成正比"></a>武汉：城市发展空间的大小，往往和房价的升值空间成正比</h2><blockquote><p><strong>dantez13：</strong></p><p>挨楼主好近 呵呵</p><p>请教一下楼主对武汉这个城市的看法 房价 以及将来发展的空间</p><p>今年刚在武汉出手两套房</p><p><strong>kkndme：</strong></p><p>对武汉的房价真没研究过，不敢妄言。但很看好武汉这个城市的发展。城市发展空间的大小，往往和房价的升值空间成正比，虽然不是绝对</p></blockquote><h2 id="权利让革族成为苗族的一支"><a href="#权利让革族成为苗族的一支" class="headerlink" title="权利让革族成为苗族的一支"></a>权利让革族成为苗族的一支</h2><p>刚从大山深处（枫香）出来，做了6个小时车，到榕江现城，居然赶上全程停水，狂晕。</p><p>枫香是革家聚居区，名族识别的时候本来应该定为革族，结果苗王（也是贵州shengzhang)一句话就把完全不同祖先的革族变成苗族的一支啊。这就是权利的力量。</p><h2 id="房价是否会跌，如果会，会怎么跌"><a href="#房价是否会跌，如果会，会怎么跌" class="headerlink" title="房价是否会跌，如果会，会怎么跌"></a>房价是否会跌，如果会，会怎么跌</h2><p>几天没有上来，发现来了很多比较鸡冻的同志。心情可予以理解。</p><p>但是鸡冻并不能让日子过的更好。</p><p>油价大涨小跌，我们鸡冻了，但是事实并没有改变。</p><p>高速费早就收回成本，可是依然雷打不动的收着，我们鸡冻了，可是事实也没有任何改变。</p><p>房价就能真如很多人所愿，使劲跌到人人买的起吗？今后的现实将告诉我们答案。</p><p>房价会不会跌？</p><p>我说在较远的将来一定会跌，但下跌的方式是完全不同的。不可能象大家所期望的由2010年的30000一平跌到2004年的6000一平。</p><p>下跌一定是另一种方式：当农产品价格以几年翻10倍甚至几十倍的速度上涨的时候，房产却相对滞涨。这是最有可能的下跌方式。</p><h2 id="通货膨胀是减缓灭亡最好的良药"><a href="#通货膨胀是减缓灭亡最好的良药" class="headerlink" title="通货膨胀是减缓灭亡最好的良药"></a>通货膨胀是减缓灭亡最好的良药</h2><p>最善良的意愿并不能阻止事务向邪恶的方向发展。</p><p>我们大家都很清楚却都没关注的一个常识，当我们满怀热情无偿献血的时候，有哪个贫穷的患者在需要输血时，能够因为广大群众的无偿献血而得到医院的优惠吗？</p><p>不能，无论你是穷是富，只要你是平头百姓，你都不得不因为需要输血而支付昂贵的医药费。</p><p>同样，zf并不会因为拆迁给你补偿的太低，而强迫开发商降低房价卖给群众。压低建设成本，抬高售价，中间的利润由商人和权贵进行分配，这是官商结合的通行做法。自古以来，能够赚大钱的都是红顶商人，而不是普通个体户。</p><p>对于很多鸡冻的群众，指着鼻子问我：国家会不管吗？疯狂难道不是导致灭亡吗？</p><p>我告诉你，通货膨胀就是减缓灭亡时间的最好良药</p><blockquote><p><strong>被忽悠的群众：</strong></p><p>请楼主解释一下</p><p>通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利，怎是良药？？？</p><p><strong>kkndme：</strong></p><p>通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利————没错，通货膨胀就是剪老百姓的羊毛，让权贵的财富更集中，中下层群众更贫穷。</p><p>但是，从国家的统治与巩固来讲，的确是良药啊（当然有一定限度）。</p><p>当大多数资源掌握在少数人手中的时候，占有绝大多数的金字塔下层的群众能够分配到的资源就越少，资源的价格就会越高，少数的金字塔中上层的既得利益者就会越富有。</p><p>大家知道，有些资源会变成富人间的游戏（比如现在的古董，字画），完全失去群众基础；而如果与生活密切相关的资源过度集中，一定会爆发极端冲突事件，造成社会动荡。</p><p>zf通过不断稀释货币的实际购买能力，并且对粮食等生活必需品实行平准制度，一方面保证了绝大多数人民的基本吃饭问题，另一方面让中下层群众手中的余钱基本消耗在特定的商品上，以至于不得不马不停蹄的劳作，这才能保证社会的稳定和向前发展。而上层精英就可以坐享其成。</p><p>让我们回顾一下过去</p><p>80年代，那时的人们靠省吃俭用积攒出节余，被消耗在自行车、手表、缝纫机上。通过不断的劳动，才能吃饱饭，才能攒点钱买三大件取媳妇。</p><p>80年代末，90年代初，人们的工资提高了，手里的结余增加了，彩电、冰箱的大规模普及又消灭了老百姓手中的流动性。</p><p>紧接着电话、空调又接过了彩电、冰箱的大旗。那时安装个电话可要5000大元啊。</p><p>随着工业化水平大幅度提高，经济高速增长，货币发行量也迅速增加，彩电、冰箱等工业化大规模产品已经不具备稀缺资源的特性，也无法吸收百姓手中庞大的结余资金。</p><p>汽车和商品房的发展成为消灭老百姓手中的流动性的最好工具。</p><p>在经济发展的大潮中，一旦对资源的支配权可以换取利益，贫富两极分化是发展的必然。随着贫富分化开始加剧，财富集中在少部分人手中，集中了大量财富的少部分人已经不满足于购买普通的消费品（汽车是工业化的产物，不具备稀缺性），对投资品的追捧造就了2005年房地产的崛起。</p><p>房地产具备了投资品和生活必须品的双重属性，即可以让金字塔中上层的精英群体依靠房地产保值增值，又可吸收掉中下层群众的未来若干年的结余资金。</p><p>大量印刷的货币还是有一定数量留到勤劳肯干的白领手中的，而这些货币又因为通货膨胀因素消耗在不断上涨的生活必需品上，必需品中商品房占了大头。</p><p>于是拥有大量房产的金字塔中上层精英可以坐享其成，享受房产升值带来的收益，而中下层群众不得不为房子打工。</p><p>发行大量货币满足经济发展的需要，同时通过通货膨胀来消灭广大群众手中的流动性，是zf稳定社会，发展经济的法宝，适度的通货膨胀当然是缓解社会矛盾的良药</p><p><strong>tjOOSAN：</strong></p><p>楼主！这段话，我不是很明白。</p><p>好像世界上，每个国家都是如此把？谁会不买东西？谁会不买生活必须品？</p><p>别忘了，中国发展到现在，百姓也没有能力购买一切生活必须品！当然，随着社会的发展，人民在一点一点的去完善基本生活。</p><p>这你却说成。。。精英和国家的阴谋。。。我。。。很难理解。</p><p>稳定粮食价格，这对每个国家而言，都是必须的啊！？？这最最基本了吧？</p><p>房子为什么涨价？？？国家决策！懂吗？间接取消了经济适用房政策。市场上百分之九十都是商品房！！你告诉我，房价能不涨吗？</p><p>房价涨了，受益人是谁？？？是政府！！不是你嘴里所谓的精英，他们只是傀儡罢了！</p><p><strong>kkndme：</strong></p><p>不是阴谋，我没提过一句阴谋，是国策</p><p>好比美国，以中产阶级利益为代表的美国，一个币值相对稳定的国家，主导借钱消费，这就是国策。</p><p>当08年的金融危机，多数中产却尝到了惨痛的教训。而在美国的华人，因为热爱储蓄的原因（这跟美国币值相对稳定、华人储蓄习惯都有关系），生活并没有受到太大影响。</p></blockquote><h2 id="货币供应不足是明朝的真正原因"><a href="#货币供应不足是明朝的真正原因" class="headerlink" title="货币供应不足是明朝的真正原因"></a>货币供应不足是明朝的真正原因</h2><p>明朝末年，可怜的崇祯皇帝面临的最可怕的问题貌似两个:一是努尔哈赤的入侵；一是大饥荒下，到处闹蚁贼。光是努尔哈赤的入侵，明末的关宁铁骑完全可以将满人挡在山海关外；光是蚁贼肆虐，凭洪承畴、孙传庭等名将镇压一群乌合之众还是易如反掌的；内忧外患才导致了明朝的灭亡。这是通行的说法。</p><p>明朝灭亡的真正原因，是经济原因。</p><p>当然，这也是句废话，无论是社会的稳定，还是国家的动乱，或者邻国间的战争，都是经济原因导致的。</p><p>明朝真正灭亡的原因是：货币供给不足。</p><p>不要说百姓的经济行为受到很大制约，即使是军队也发不出饷银。以至于除了关宁铁骑以外，明朝就找不出一支有战斗力的军队，甚至洪承畴、孙传庭打高迎祥、李自成、张献忠，居然靠农民军的馈赠过日子。</p><p>货币供给不足，明朝的经济崩溃了。</p><h2 id="经济问题是导致清朝灭亡"><a href="#经济问题是导致清朝灭亡" class="headerlink" title="经济问题是导致清朝灭亡"></a>经济问题是导致清朝灭亡</h2><p>再谈谈鸦片战争和那个满脑子浆糊的林则徐。</p><p>鸦片战争的原因，在于大清国与欧洲诸国之间存在的巨大贸易顺差。</p><p>大清虽然闭关锁国，丝绸、茶叶、瓷器通过民间和官员私下大量出口欧洲换取白银，却没有任何的进口需求。以至于英、法国家不得不世界范围开采银矿，但依然不能满足采购中国商品的需求。</p><p>英法诸国必须要与中国通商贸易，才能解决贸易顺差这个根本的问题。英国人实在不知道拿什么商品来进行贸易(貌似中国什么都不需要），于是不法商人想出了鸦片撬开中英贸易缺口的馊主意——这并没有得到英国官方的支持。</p><p>但是林则徐同志既不懂得经济，又不懂得外交，对欧洲人的认识也就停留在：我不给你茶叶，你的腿都站不直。 <br>不管洋人打算干什么，总之洋人就是邪恶的，就该抓起来打板子。于是，自然而然的一顿开打，结果可想而知。 <br>于是清朝官员施展出了村骗乡，乡骗县，一骗骗到guowuyuan，的传统技能，咸丰同志在故宫几乎自始至终听到的都是捷报频传。</p><p>清末，一会儿闹拳匪，一会儿闹白莲教，一会儿闹太平天国。然而，靠鸡冻的群众杀几个洋毛子并不能使中国变得强大。林则徐如果能够有点知识，不妄自尊大，能够说动咸丰开放正常通商贸易、拒绝鸦片，联军入侵圆明园的事大致可以避免。</p><p>经济问题才是导致社会动荡，战争爆发的根源。</p><blockquote><p>挑个刺 第一次鸦片战争清的皇帝是道光不是咸丰 白莲教不是清末的而是清中叶嘉庆年间的</p><p><strong>kkndme：</strong></p><p>确实是道光不是咸丰，笔误，特此道歉。</p><p>白莲教始于宋，最早可以追朔到南北朝时期，最早的名字叫“白莲社”。白莲教其实就是摩尼教，也就是倚天屠龙记里的明教，朱元璋靠白莲教得了天下，所以明代对白莲教的镇压异常残酷。清代的白莲教出现了许多分支，如八卦教、天地门教，先天教等等，总之白莲教从元代开始一直到清末都是闹得很凶的。</p></blockquote><h2 id="房产投资的几点建议"><a href="#房产投资的几点建议" class="headerlink" title="房产投资的几点建议"></a>房产投资的几点建议</h2><p>感谢大家的支持，不少朋友还提了一些关于房产投资的问题。</p><p>我觉得无论做什么样的投资，自己一定要做足功课。就房产来说，对于区域经济发展，要有深刻的理解，否则就不要轻易出手。</p><p>关于房产，我只是从大方向上说了一下自己的判断，并没有对区域的房产升值做过研究，所以没法给大家提供建议，请大家谅解。</p><p>不过，关于房产投资的方向，也有几点心得：供大家参考： <br>一、坚决不能投资自己不熟悉的城市<br>二、坚决不投资中小城市，一般省会及计划单列以上城市问题都不大，但中小城市即使房价上涨也存在变现困难问题。<br>三、坚决不投资距离大城市较偏远的旅游城市，比如山东乳山之类的，几乎无法变现。<br>四、慎重投资大城市的郊区，除非价格绝对低。如果外来人口比较多，zf又有发展规划，且价格与城区相比有较大的价差，才可以考虑</p><h2 id="人民币对外升值，对内贬值"><a href="#人民币对外升值，对内贬值" class="headerlink" title="人民币对外升值，对内贬值"></a>人民币对外升值，对内贬值</h2><blockquote><p>楼主，据sz的统计公布09年底的商品房存量4~5万套，33%左右的自由率，10年新建成面积在300万平米左右，应该不算泡沫吧？目前美元走强，人民币贬值会导致国外热钱以及权贵的钱逃走么？对房地产影响怎么看？</p><p><strong>kkndme：</strong></p><p>人民币对外是升值，对内贬值</p></blockquote><h2 id="南宁买房建议"><a href="#南宁买房建议" class="headerlink" title="南宁买房建议"></a>南宁买房建议</h2><blockquote><p><strong>showforme：</strong></p><p>LZ帮忙分析南宁的楼市情况，这边的房价均价是6000多，最近中央说要投资1.5万亿给广西发展北部湾经济，也许对南宁楼市有一定的刺激作用，我想近期买一套房自住+投资，现在入手合适还是等到年底合适？</p><p><strong>kkndme：</strong></p><p>自住+投资？</p><p>自住房首要考虑的还是生活方便，不要太多考虑涨跌，没有意义，如果手里有钱就可以买。</p><p>南宁的房价我不清楚。但南宁是一个经济高速发展的城市是毋庸置疑的。</p><p>相对于昆明，南宁在面向东南亚贸易方面，有着更得天独厚的优势——港口。</p></blockquote><h2 id="经济适用房都是内部分配的"><a href="#经济适用房都是内部分配的" class="headerlink" title="经济适用房都是内部分配的"></a>经济适用房都是内部分配的</h2><blockquote><p><strong>yjfsam：</strong></p><p>看新闻说,在经济适用房里提供一定数量的廉租房,而不是大量廉租房,经济适用房是可以购买的,而且是建在市中心附近,如果是我,我当然是想买经济适用房,而廉租房又不多,这会不会跟楼主的意思有点不一样?</p><p>另外经济适用房在高价房附近推出,可以打压附近房价?</p><p><strong>kkndme：</strong></p><p>你认为建在市中心附近的经济适用房是给普通老百姓建的吗？是低收入群众有资格购买的吗？</p><p>经济适用房都是内部分配的，但一旦走进市场就可以牟取暴利了。</p><p><strong>tjOOSAN：</strong></p><p>大哥！！我真服你了。。。。。。</p><p>你知道 定向分配吗？？？就是只有拆迁户才有资格买的房子。不存在收入的问题！！</p><p>你纯粹是胡诌啊！我发现</p><p><strong>kkndme：</strong></p><p>兄弟，你一直比较鸡栋，呵呵</p><p>拆迁户的定向房属于另外的问题，作为有产阶级的拆迁户来说，部分是城市扩大化的受益者，而部分又是受害者，不能一概而论。时机不同，城市不同，境遇也不同。</p><p>但是有一点可以肯定，拆迁的目的，不是为了拆迁户过得更好更舒服。开发商愿意支付高额的拆迁费（只限于超大型文明的城市，许多城市拆迁户的补偿是很可怜的）而是有更大的利润可图。</p><p>zf为主导建设的市中心经济适用房也不仅仅为了拆迁户回迁，拆迁户回迁比例最多占小区总放量的30%，而其余的基本上是权贵房</p><p><strong>tjOOSAN：</strong></p><p>我可不激动！就是闲的没事，来找事吧！还算是正事！</p><p>你说的什么给权贵房，固然存在。但是比例太太少了！！你说的话，根本没有依据！</p><p>现在买限价房的和经济适用房的人，都要在报纸上公布姓名和住址。</p><p>而且只要不是太穷的，基本都希望拆迁！因为第一，给的钱多。 第二 可以有定向分配。而且还是好地段的房子！！</p><p><strong>kkndme：</strong></p><p>兄弟你还是去了解一下体制内分福利房的真相吧。</p><p>福利房占用的都是经济适用房的指标啊</p><p>真正向社会公示的保障房才有多少呢？相对于数量庞大的福利房，可以说凤毛麟角。</p><p>不了解真相就没有发言权啊</p><p>特别是在二三线城市，房源比一线相对略为宽松，一个有点级别的公务员，通常都是分两三套房，这些房子占用的都是保障房的指标，都是要统计入保障房数据的。</p><p>不信你可以问问身边的公务员、银行员工、垄断企业员工。</p><p><strong>tjOOSAN：</strong></p><p>奥！你说的是，传说中的 国企员工啊！！</p><p>可你一开始却说得是 经济适用房！是你搞错了把？</p><p>国企员工分配房子的，也要够一定工龄！一定级别！不是谁都有的。好伐？</p><p>而且 现在中国地产，很大一部分就是国企投资的。</p><p>所以叫内部分配么！！国企分房，在中国的体制内是正常的！</p><p><strong>kkndme：</strong></p><p>传说中的上海人？</p><p>我没有搞错，体制内员工分配的福利房就是经济适用房。</p><p>我举个例子，昆明武警干部的福利房叫恒安新邻居，它的官方名称叫什么？</p><p>我告诉你，叫做“武警经济适用房小区”</p><p>你看到的内部分房，占用的都是经济适用房的指标，也就是占用的是：我们所说的为了解决民生问题的保障房的指标。</p><p><strong>tjOOSAN：</strong></p><blockquote><p>kkndme</p><p>你认为建在市中心附近的经济适用房是给普通老百姓建的吗？是低收入群众有资格购买的吗？</p><p>经济适用房都是内部分配的，但一旦走进市场就可以牟取暴利了。</p></blockquote><p>这可是您自己的原话啊？？对吧？？</p><p>市中心的经适，就是叫做定向分配。就是 在这附近拆迁的人，住的！！</p><p>你非要说，有人谋私，我也不反对！但绝对不会多。</p><p><strong>kkndme：</strong></p><p>我估计是你理解错了，谋私和牟取暴利是两回事。</p><p>假设你是某市科级公务员，分到两套房子，以保障房的价格购买，但是却可以按照市场价格出售，只要一转手就可以进账几十万甚至上百万。</p><p>这就是分房双轨制给体制内有级别的员工带来的暴力机会。这跟谋私没有关系</p><p><strong>tjOOSAN：</strong></p><p>我觉得楼主拿经济适用房 做例子。很愚笨。</p><p>中国房价高起的根本原因，不就是国企，制造业资金进入地产么。</p><p>经济适用，现阶段就是为拆迁户盖得。</p><p><strong>kkndme：</strong></p><p>晕，也许你们上海是吧，放眼全国肯定不是</p><p><strong>jellyoak：</strong></p><p>上海今年以前根本没有过经济适用房，恰恰相反，上海是商品房最彻底的城市</p><p>给动迁户的叫动迁安置房，绝对都是建在最偏僻的地方的，最近5年基本上没有原拆原回的安置。</p><p>那位激动的同志有点多动症的嫌疑，忽略算了。</p><p><strong>tjOOSAN：</strong></p><blockquote><p><strong>kkndme：</strong></p><p>我估计是你理解错了，谋私和牟取暴利是两回事。</p><p>假设你是某市科级公务员，分到两套房子，以保障房的价格购买，但是却可以按照市场价格出售，只要一转手就可以进账几十万甚至上百万。</p><p>这就是分房双轨制给体制内有级别的员工带来的暴力机会。这跟谋私没有关系</p></blockquote><p>你。。我不知道你说这个是什么意思？</p><p>贪污腐败是少数。这是肯定存在的现象。但我现在讨论的是大众现象！</p><p>而且内部分房的们都要够一定级别！就算他们一人分三套，那根本对楼市没有影响的</p><p><strong>kkndme：</strong></p><p>我说的是房产双轨制，是一种制度，不是说个人的以权谋私。</p><p>房屋问题实际上是土地问题，当一少部分人群能够以很低的代价占有更多的土地，市场上的土地就会变得稀缺，价格就会上升。</p><p><strong>jellyoak：</strong></p><p>可以说上海是最彻底的商品房市场化的城市。</p><p>没有小产权，没有福利分配，完全的市场化。</p><p>唯一的例外就是动迁户能分配到动迁安置房，虽然都是地处偏远但现在也都价值高昂。</p><p>lz说的那种公务员分配的安置房在很多城市是很普遍的。</p><p>情况绝非那位偏执狂TX所理解的</p><p>事实是庞大臃肿的公务员机构都有机会给这些公务员分配到一套住房，总数量很是惊人。</p><p>如果严控贷款的话，现在上海的房价是得不到长久支撑的。</p><p>看长期政策如何了。</p><p>现在没人相信贷款可以一直这样卡下去。</p></blockquote><h2 id="普通人怎么办：尽早买房，努力挣钱抵御通胀"><a href="#普通人怎么办：尽早买房，努力挣钱抵御通胀" class="headerlink" title="普通人怎么办：尽早买房，努力挣钱抵御通胀"></a>普通人怎么办：尽早买房，努力挣钱抵御通胀</h2><blockquote><p><strong>被忽悠的群众：</strong></p><p>楼主：我们P民怎么办呢？只有买房保住自己的社会地位！？</p><p><strong>kkndme：</strong></p><p>问题是房子将会是普通人越来越难以参与的游戏，门槛越来越高。</p><p>只有努力工作赚钱才是唯一能抵抗通胀的办法，这也是zf最希望看到的。</p><p>当然体制内员工，工资制度本身就可以抵御通胀。这些多发出来的钱是需要体制外广大群众创造出来的，因为体制内员工本身并不直接创造价值。</p><p>而体制外的广大群众要想抵御通胀，就必须努力工作，创造更大的价值来提高收入水平。</p><p>这也就是国家能够维持运转的根源所在啊</p></blockquote><h2 id="房价会出现很多上下波动"><a href="#房价会出现很多上下波动" class="headerlink" title="房价会出现很多上下波动"></a>房价会出现很多上下波动</h2><blockquote><p><strong>fengyu1218：</strong></p><p>楼主，你所分析问题透彻明晰，很受启发</p><p>但是立足于将任何问题都用P民跟精英阶层对立的观点，我觉得有点绝对</p><p>社会阶层的复杂性，以及相互之间的博弈会在特定的阶段</p><p>有特定的表现形式，比如，当房价太高，P民阶层抗议不断的时候</p><p>会有所谓的调控出来，尽管成效不大</p><p>统治阶层也不会任由社会矛盾积累到最大程度而不作为</p><p>所以房价的表现形式会出现很多的上下波动</p><p><strong>kkndme：</strong></p><p>你说的对，房价趋势是上涨，但一定会有短期的波动</p><p><strong>tjOOSAN：</strong></p><p>而且对于你所标榜的“暴涨” 你自己后来也改了，是在波动中上涨！</p><p>那还是暴涨吗？你都违背了自己的标题。</p><p><strong>kkndme：</strong></p><p>呵呵，短期的调控并不能改变长期上涨的趋势，</p><p>当资金的运作规律收到外力的压制，短暂低头的房价就会迎来暴涨。这是规律。</p></blockquote><h2 id="买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）"><a href="#买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）" class="headerlink" title="买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）"></a>买房时机的选择（真TM厉害，这竟然是2010年的建议，可恨的是2020年才看到）</h2><p>很多朋友都关心买房时机问题</p><p>对于自住需求者和投资需求者是要区别对待的</p><p>对于一线城市与二三线城市也是要区别对待的</p><p>对于自住需求者（仅指普通群众）来说，只要你还有钱能够买的起房，那你就买吧。</p><p>不要赌博和赌气，因为真的赌不起。</p><p>人人都可以买得起商品房，只是一个美丽的童话。</p><p>当然如果你赶上了国家调控的好时机，那你就要认真选房，做足功课，迅速出手。因为买到一套户型、位置、楼层都让你满意的房子，在商品房热销期，是很难的事情，根本没有给你挑选的机会，而在调控期，或许房价没怎么下降，但绝对给了你挑选的余地。</p><p>对于投资来说，问题就比较复杂，要考虑的问题就会更多，不同条件的人就有不同的需求。</p><p>总的来说在严厉调控期，需要关注以下几点：</p><p>一、当新盘的价格低于周边二手房的价格。<br>二、当看房的人不断增加<br>三、当kas拿地热情大减，以至于多处土地流拍</p><p>以上三点是提示你准备出手的信号。</p><p>对于一线城市，一定会有一段时期小幅下跌，及跌后滞涨。</p><p>对于二三线城市，多数城市会缓步持续上涨。但遇到大规模拆迁的城市，那房价就会忽视调控，选择快速上涨。近期，在二三线城市，无论自住还是投资，都是早买好于晚买。</p><h2 id="收入分配改革跟体制外的人没关系"><a href="#收入分配改革跟体制外的人没关系" class="headerlink" title="收入分配改革跟体制外的人没关系"></a>收入分配改革跟体制外的人没关系</h2><blockquote><p><strong>feifeilongdi：</strong></p><p>请问楼主国家的收入分配改革调整的是哪一部分人的收入？</p><p>我们底层p民如果真的连公租房都只能勉强供得起，那以后子女的抚养费用，夫妻以后的养老资金如何解决</p><p><strong>kkndme：</strong></p><p>工资收入分配改革应该只是个说法，对公有制经济是很有实惠的。但非公有制员工的工资是阳光雨露都撒不到的。</p><p>以前说涨工资基本都是公务员，收入分配改革后可能对事业单位及国企工资收入有明显改善。</p><p>至于体制外，无论打工仔和个体户都是自生自灭的</p></blockquote><h2 id="体制外的人要早早考虑养老问题"><a href="#体制外的人要早早考虑养老问题" class="headerlink" title="体制外的人要早早考虑养老问题"></a>体制外的人要早早考虑养老问题</h2><p>体制外人员养老确实是个问题</p><p>做生意的赚钱养老</p><p>聪明的下手早的以房养老</p><p>最惨的是没有混上去，且又没有特殊技能的私企打工仔。养老实在是个大问题。</p><p>所以东部地区才有宁挣老板1000元，不赚打工5000块的说法。</p><p>双轨制下，低层群众想翻身确实比较难。</p><h2 id="永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你"><a href="#永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你" class="headerlink" title="永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你"></a>永远不要和白痴争辩，因为他会把你的智商拉到和他同一水平，然后用丰富的经验打败你</h2><p>鸡冻先生</p><p>能够有资格跟你辩论的一定只有两种人</p><p>一种是智商极高，世间罕见的</p><p>一种是智商比较低的。</p><p>其他人跟你辩论那是自找苦吃</p><h2 id="当个农民也要懂政策，要顺政策而为"><a href="#当个农民也要懂政策，要顺政策而为" class="headerlink" title="当个农民也要懂政策，要顺政策而为"></a>当个农民也要懂政策，要顺政策而为</h2><p>刚从深山老林钻出来，终于找到地方洗澡了，我激动啊。</p><p>洗完澡轻松，讲一个刚从支书那里听来的故事。</p><p>大家普遍感觉很穷的贵州省榕江县栽麻乡宰荡村，在解放前却是有名的富裕村，他们靠勤劳开垦荒地，良田多到种不过来，直到土改后，zf将宰荡的良田分给了加所、林所等周围几个土地较少的村子的村民（这些村子土地少的原因主要还是周围几个村子的村民比较懒惰，宁肯受穷也不愿意开垦荒地），宰荡才穷下来。</p><p>因为宰荡村过去比较富裕，拨给的富农指标就比较多。有一户人家很富裕，按理应该划为富农，但这户人家很了解政策，知道评上富农就会挨整，于是走关系，成分改成了中农。</p><p>而其他大多数依靠勤劳致富的人家非常老实，也不懂评为富农有什么不好，认为什么成分都无所谓，还不是老老实实干活。结果可想而知。当上了富农接下来就是没完没了的批斗。</p><p>这个故事告诉我们，哪怕当个农民也必须了解zf的意图。</p><h2 id="存钱不如存资产，钱会贬值，资产会升值"><a href="#存钱不如存资产，钱会贬值，资产会升值" class="headerlink" title="存钱不如存资产，钱会贬值，资产会升值"></a>存钱不如存资产，钱会贬值，资产会升值</h2><p>去年在宰荡做了一段时间的田野调查，今年这次来算是回访。时过一年，发现去年村子附近的大多数农田，今年都变成了房子。</p><p>现在农民政策还是可以的，即使贫困如贵州山区，农民除了能够完全自给自足外，多余的粮食蔬菜也能换来一定的经济收入，随着家境变好了，对更大的房子的需求也就产生了，农民愿意把闲钱都用来盖成更大的房子，宁肯牺牲掉自有耕地。这其实是一件可怕的事情。</p><p>这次同样对村民做了入户调查，发现了一件有意思的事情。</p><p>村民最感到遗憾的事情就是早在2000年初，那时村里还没有电，村民为了想让全村通电，卖掉了所有山上的古树。电通了，当时的村民很高兴，而且认为古树卖了一个高价格（当时总共卖了6万块钱），换来了全村的生活方便。</p><p>大约在三年后，其他村寨，zf都给免费通了电。如果那些古树不卖掉，现在随便一颗的价格都超过了6万。现在那些古树至少值几百万。</p><p>村民们用最朴实无华的思想总结了一个道理：存钱不如存房子、存木头、存树</p><h2 id="房子越早买越好，zf想钱想疯了"><a href="#房子越早买越好，zf想钱想疯了" class="headerlink" title="房子越早买越好，zf想钱想疯了"></a>房子越早买越好，zf想钱想疯了</h2><p>全国人民都知道有个以雷厉风行著称的球书记</p><p>球书记曾说过一段著名的话，大意是：昆明的开发商拿地价格很低，卖的价格却很高，腐败才是高房价根源。</p><p>当时昆明的很多无房户都很鸡冻，以为这下可好了，找到问题根源了，昆明房价要降了。</p><p>可是我听到的意思却是：zf卖地卖得太低了，应该大幅提高土地价格。</p><p>果然不久就出台了54321政策，以前拿地没走招拍挂程序的，一律按照54321补交土地款，否则开发商不发放任何证件，以至于升级到已买了房的业主也拿不到房产证。</p><p>于是昆明的新盘由于手续问题都无法开盘，已经卖掉很久的老盘，开发商还要求业主补交房款，否则退房。</p><p>结果可想而知，昆明的房价以一环与二环之间为例，由去年下半年的6000多涨到现在的均价过万。</p><p>如果从民生着想，会做出这样荒唐的事来吗。</p><p>帖子里有朋友问昆明的买房时机，我只能说越早买越好，因为dfzf想钱已经想疯了</p><h2 id="利益才是zf行为的指挥棒"><a href="#利益才是zf行为的指挥棒" class="headerlink" title="利益才是zf行为的指挥棒"></a>利益才是zf行为的指挥棒</h2><p>北大朱晓阳用了十多年时间跟踪昆明城中村，对刚刚建好5年的宏仁村就要因为商业利益而拆迁已经出离了愤怒，结果这事捅到CCAV曝光了，拆迁的事只好暂停。</p><p>利益才是zf行为的指挥棒</p><h2 id="建议一定是建立在严肃考察的基础上"><a href="#建议一定是建立在严肃考察的基础上" class="headerlink" title="建议一定是建立在严肃考察的基础上"></a>建议一定是建立在严肃考察的基础上</h2><blockquote><p><strong>爱情就像跳恰恰：</strong></p><p>这两天全部看完了，深受触动，楼主是个睿智的人，赞一个~</p><p>想说下自己的情况，楼主帮我参谋一下，我在上海，女性，前几年由于一些特殊个人原因，导致一直没有自己的房子，这两年专注于事业，今年发展不错，进帐了260万左右，但是，通过几次看房，我发现 300万以内，已经找不到理想的房源！</p><p>我现在是租住的市中心高档住房，每月租金 8500块，100个平米左右，这样的房子大概售价 500万左右，所以，现在的情况是 我想住的房子买不起，买的起的我也不想住~</p><p>我本人对买房和租房没有太大感觉，从某种意义上说 我倒更喜欢租房，可以每两年换个区 换套新房住住 比较有新鲜感~但是，我手上也不想持有现金，由于物价上涨，通货膨胀，我觉得持有现金的风险也不小！</p><p>不知道楼主对扬州的房产怎么看，我想放弃上海，到扬州购入房产，处于保值或者以后升值空间大后再售出，比如在市中心购入两三套高档小户型，用于出租！扬州由于地理优势，一两年后可能开通上海高铁，这样考虑在扬州安个家也不错，再置入一套生活便利的大点房子，以后可以考虑自住~</p><p><strong>kkndme：</strong></p><p>你的想法显然是经过深思熟虑的，在扬州买房子自住，花更少的钱过更舒适的生活很好啊，当然前提是你自己喜扬州这个城市。</p><p>说到投资，其实没人能够取代你自己的判断。我也没法给你提供究竟有多大升值空间的建议，因为建议一定是建立在严肃考察的基础上的。</p><p>我只能说东部地区的城市房产保值还是没问题的，但在哪个城市投资更好，确实需要认真实地考察。</p><p>如果从全国范围看，仅对投资而言，我比较看涨西安和重庆。但我个人不会在这两个城市买房子，因为本人不喜欢重庆的酷热和西安的气氛。</p></blockquote><h2 id="石家庄"><a href="#石家庄" class="headerlink" title="石家庄"></a>石家庄</h2><blockquote><p>楼主，请评价下石家庄的楼市，是暂时的价值洼地还是长期？</p><p><strong>kkndme：</strong></p><p>石家庄的地理和经济上的位置都比较尴尬。山西和天津都比石家庄有更好的优势</p></blockquote><h2 id="投资最重要的是稀缺性，买房首选公务员小区"><a href="#投资最重要的是稀缺性，买房首选公务员小区" class="headerlink" title="投资最重要的是稀缺性，买房首选公务员小区"></a>投资最重要的是稀缺性，买房首选公务员小区</h2><p>说到买房子，无论投资还是自住，最重要的还是稀缺性，首选还是学区房。</p><p>自住最好买政府公务员小区，无论是商业配套，教育配套以及休闲娱乐配套都是商品房所无法比拟的。特别是商品房经过十几二十年，房子旧了，电梯很容易出故障，如果物业有问题或者小区里有人不交物业费，那么这个小区就很难住了。公务员小区则完全不用考虑房子老旧的问题，那都是zf包干到底的。</p><blockquote><p><strong>usstcai：</strong></p><p>怎么找这种房源呢？</p><p><strong>kkndme：</strong></p><p>每个城市的情况不一样，北京基本上是单位的老公房，老计委的房，中石化的房都有上市交易的，但新房很难找。</p><p>至于二三线城市，现在还存在大量的公务员、垄断企业的新小区，并且很多房源都在市场上交易。比如昆明，存在大量的权贵小区，比如金江小区是省政府公务员小区，月牙塘小区是市政府公务员小区。</p></blockquote><h2 id="远离垃圾人"><a href="#远离垃圾人" class="headerlink" title="远离垃圾人"></a>远离垃圾人</h2><p>关于流氓无产者，在宰荡村子里还听了个故事</p><p>说很久以前的事情。</p><p>宰荡村民都很勤劳很淳朴。但是意外的出了一个叫罗老黑的人。</p><p>这个人好吃懒做无所事事，看见人家地里庄稼蔬菜长的好就跑去抢，为此挨过几次打。有一天罗老黑路上遇到个大兵，骗了大兵的枪，于是开始在村子里耀武扬威，不但抢人家辛辛苦苦种的菜，遇到单身的姑娘还动手动脚。</p><p>罗老黑在村里到处宣传他的逻辑：村里的庄稼、蔬菜、猪牛应该见者有份。</p><p>村里一些年轻人受了罗老黑的感染，开始变得好吃懒做，谁家种的东西都跑去拿。于是，村里人都不愿意劳动了，宰荡村开始变穷。</p><p>村里有个人很憎恨罗老黑的行为，但不敢明着跟王老黑作对，就在晚上在王老黑家放了一把火。侗族人住的房子都是杉木的，一旦一家着火，很可能全村遭殃，那把火烧了整个宰荡寨子，连青石板都烧裂了。</p><p>罗老黑，这个典型的流氓无产者，他的光荣事迹被当作反面教材激励着世世代代的宰荡村民。</p><h2 id="高房价或许有天会崩盘，但你等不到那一天"><a href="#高房价或许有天会崩盘，但你等不到那一天" class="headerlink" title="高房价或许有天会崩盘，但你等不到那一天"></a>高房价或许有天会崩盘，但你等不到那一天</h2><blockquote><p><strong>zhuce010022：</strong></p><p>不合理的制度不会永远的存在下去的。。。正如国父当年说的一句“天下大势浩浩荡荡，顺之者昌，逆之者亡”。。。</p><p>现在的高房价是目前中国的政治、经济结构失序造成的。</p><p>楼主上面分析了那么多，确实是，在目前这种局面下可能一直冲到崩是唯一的选择，但是，你怎么知道这种失序的大局面会一直持续下去呢？</p><p><strong>kkndme：</strong></p><p>一个朝代从鼎盛到衰亡至少维持个一两百年。所谓天下大势分久必合，合久必分，由合到分，总还是有个时间跨度的。</p><p>侥幸能在有生之年平平安安就是最大的福气，身死之后，哪管洪水滔天</p></blockquote><h2 id="房子不仅要早买，而且有能力的话不要怕压力，争取一步到位"><a href="#房子不仅要早买，而且有能力的话不要怕压力，争取一步到位" class="headerlink" title="房子不仅要早买，而且有能力的话不要怕压力，争取一步到位"></a>房子不仅要早买，而且有能力的话不要怕压力，争取一步到位</h2><blockquote><p><strong>傻子也疯狂：</strong></p><p>楼主</p><p>你好</p><p>跟你的帖子已经两晚上了，还是没看完</p><p>不过已经到第六页了，我会继续跟下去</p><p>感觉你分析很有道理，也很深奥<br>以前在一个炒房人的终极预测也看到过类似的帖子<br>慢慢的也有所感悟<br>现在想请教你个问题，也是我自己面临的问题</p><p>人在深圳，想趁今年调控在武汉买套房子，因为有回武汉发展的想法<br>我毕业三年，收入不高，目前可能首付都不够（40万总价我想付10–15万，别笑我无能）总是在想是等我存够了首付再回去看房子还是现在就订下来，订下来吧钱不够，可能要问朋友借点，既要还债又要月供怕压力大，如果先不买等存够钱我怕那时候房价又上去了，所以想你帮我参考参考，给点建议，谢谢，诚信请教</p><p>另外，我和我女朋友月总收入8000左右，你觉得买总价40万的压力大吗<br>准备两年后结婚，再次感谢。</p><p><strong>kkndme：</strong></p><p>40万首付15万，贷款25万，月供1000多，你和女朋友月收入8000，你觉得有压力吗？</p><p>二三线城市往往早买好于晚买，特别是你是自住。</p><p>40万的房子要不然是比较小的，要不然就是郊区了，如果你们有8000的月收入供60万的房子是不成问题的，建议不要图便宜，首选还是位置，宁可买贵点买离城中心近的房子，因为将来能够买得起改善性住房的会越来越少，有能力的话还是尽量买到位。要特别考虑今后小孩上学的配套问题。</p><p><strong>傻子也疯狂：</strong></p><p>楼主可能还不明白我的意思</p><p>我的首付目前也就10万</p><p>如果买大了首付要三成，按你说的卖60万的好是好</p><p>可首付至少要18万</p><p>我没有这么多怎么办呢</p><p>如果借钱，还债又月供，还要考虑两年后结婚。。。。。。。。</p><p>你觉得怎么办好，或者你有更好的建议</p><p>谢谢</p><p><strong>kkndme：</strong></p><p>如果只差8万，家里支持一些，亲戚朋友借一些，一挺就过去了。很多刚开始买房的年轻人都是要咬牙买的，换来以后的轻松。甚至很多人因为今后收入的提高，几年就把贷款还完了。</p><p>当然，如果真的凑不上，还是量力而行，但买房还是买位置，首选离城中心近的，宁可买小一点。住在远郊区的大房子里花1个多小时的时间上班才是受罪</p></blockquote><h2 id="金融杠杆是炒房赚钱的放大器"><a href="#金融杠杆是炒房赚钱的放大器" class="headerlink" title="金融杠杆是炒房赚钱的放大器"></a>金融杠杆是炒房赚钱的放大器</h2><blockquote><p><strong>错误角色：</strong></p><p>其实个人觉得普通炒房者不一定就能获多少利，比如他买一套新房是三千每平，等新房价到六千时出手，他能卖到五千每平。看上去他每平赚了二千…但是，他要继续炒的话，就要再加每平一千的本金进去买新房…看上去他们是资产翻翻了，但是他们的二次投资也是翻翻的…也就是说他以前三十万买了一百平，现在卖出去是五十万，看上去赚了二十万，但是，他想再买个一百平的却需要六十万…他还得从老本掏十万买同样大小的房子…这样算我也不知道对不对…要是对的话，就说明炒房的人不是抬高房价的最根本原因和最关键因素…… </p><p><strong>kkndme：</strong></p><p>你没考虑金融杠杆的作用，真正的投机炒房是贷款炒房，而投资客更愿意一次性付清。一个炒房客用20万可以买100万的房子，等到200万卖掉，投入20多万，赚了170多万。然后用变现的钱又可以贷款买多套，这就是投机炒房比股市更吸引人的地方，但是一旦资金链断掉就会比较惨。</p><p>这种赌徒心态的投机炒客还是比较遭人恨的，这次调控提高首付比例，对这类投机炒家打击不小。小资金的纯粹投机客数量控制在一个比较小的范围内，房产市场才会健康发展，这个国家是有共识的。所以二套房首付比例提高后，有可能变成常态</p><p><strong>tjOOSAN：</strong></p><p>这话。。。让我肝颤！~~ 投入20万？赚170？？还贷了80万呢</p><p>还有利息呢！~~</p><p><strong>kkndme：</strong></p><p>09年初20万首付买的100万的房子，2010年初涨到200万卖掉，你认为1年能还多少利息。难道炒房客一套房子拿满20年再卖？</p></blockquote><h2 id="要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松"><a href="#要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松" class="headerlink" title="要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松"></a>要用发展的眼光看问题，只要努力，只会越来越好，越来越轻松</h2><p>要用发展的眼光看问题，只要你还年轻，即使你现在给老板打工只能赚4000块，并不意味着以后多少年都只赚4000块，随着经验和阅历的增长，薪水是会提高的，当然前提是肯学习，肯吃苦，提高能力和才干。</p><h2 id="性格决定命运"><a href="#性格决定命运" class="headerlink" title="性格决定命运"></a>性格决定命运</h2><blockquote><p><strong>错误角色：</strong></p><p>我只买得起4000元内100平的房子！哪怕住小点，住旧点…我也不愿意背着几十年的债度过我最美好的青年和中年时代、我更不愿意每天睁开眼就开始为了还房贷而奋斗。我不想短短的一辈子只是为了一堆只有七十年产权的砖瓦而奋斗。我只是一个平凡普通的人，我只想和老婆有一个快乐安逸的小家…但是“家”这个商品已经成了现在对我来说最昂贵的奢侈品。哈哈！</p><p><strong>kkndme：</strong></p><p>有一句话叫做怎么样付出就会怎么样的收获，看到许多人买房获利，另一些人坐不住了，心态变得鸡冻了，但是，当初人家咬牙买房的时候，另一些人还在追求所谓的生活品质。性格决定了命运</p></blockquote><h2 id="2012年不取消调控，还有房价维稳顺利换届考虑"><a href="#2012年不取消调控，还有房价维稳顺利换届考虑" class="headerlink" title="2012年不取消调控，还有房价维稳顺利换届考虑"></a>2012年不取消调控，还有房价维稳顺利换届考虑</h2><p>zf希望房价维稳，为2012年换届后上涨留出空间，所以调控政策不会轻易取消，但是在高通胀预期的背景下，能不能稳住房价是很考验zf智慧的。</p><p>换届后的老板不可能去接一个烂摊子，这是关键的地方</p><h2 id="洼地最终都会被填平，多数城市是早买胜于晚买"><a href="#洼地最终都会被填平，多数城市是早买胜于晚买" class="headerlink" title="洼地最终都会被填平，多数城市是早买胜于晚买"></a>洼地最终都会被填平，多数城市是早买胜于晚买</h2><p>目前传言与辟谣越来越频繁，如何透过重重的迷雾看到事情背后的真相。</p><p>这次调控zy盯的主要还是一线城市，从提高首付比例，直到监管预售款的准备推出，都是为了提高房地产进入门槛，踢出大量小资金投资客，让小开发商民营开发商知难而退，为国家队入场铺路，zy需要稳定一线城市房价，使2012年能够顺利换届，为换届后的上涨留足空间。有了国家队的后盾，zy无需因为调控导致部分小开发商资金链断掉而担心，相反这是zy希望看到的。</p><p>当然在政策和市场的博弈中，是否能够达到zy的预期，zy的心理也不一定完全有底，因为资金有他自己内在的规律。在打压房地产的同时，会带来农产品等生活必须品的价格全面上涨，这就需要xy做出一个权衡。因为填饱肚子的问题比房价的问题更重要。</p><p>多数二三线城市会在一线城市滞涨期间进行补涨，补足09年行情中远低于一线城市的涨幅。</p><p>作为二三线城市的刚需买房者，多数城市的情况都是早买胜于晚买</p><h2 id="西部"><a href="#西部" class="headerlink" title="西部"></a>西部</h2><blockquote><p><strong>mstsc_XP：</strong></p><p>楼主对成都的房子咋看？</p><p><strong>kkndme：</strong></p><p>在西部地区，重庆、西安、成都、昆明投资房产都不会有问题。西部的其他城市就要谨慎，不是因为房价不会涨，而是因为变现比较困难。</p><p>四川、重庆经济的高速发展是不容置疑的，但存在最大的隐忧就是三峡大坝对生态和环境的破坏根本无法预测。</p></blockquote><h2 id="短期波动属于正常现象，需要关注的是长期趋势"><a href="#短期波动属于正常现象，需要关注的是长期趋势" class="headerlink" title="短期波动属于正常现象，需要关注的是长期趋势"></a>短期波动属于正常现象，需要关注的是长期趋势</h2><blockquote><p>mobster6789</p><p>楼主的一番讲解真如拨云见日！</p><p>但是本人认为，在目前基本面疲软的情况下，成交会进一步萎缩，房价在短期内也还有小规模下调的趋势，请楼主评议。</p><p>kkndme</p><p>短期的波动是再正常不过的事情，把握政策可以把握趋势，但很难做到准确的逃顶与抄底</p></blockquote><h2 id="领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运"><a href="#领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运" class="headerlink" title="领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运"></a>领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运</h2><p>领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运。</p><p>精英社会相对于法制社会存在更多的不稳定性，更崇尚个人能力、才干与职业精神，如果刘备只懂得眼泪是不可能得到三分天下的。</p><p>精英社会的根本就是以人治国，就是要承认人与人之间的差别。</p><p>百年战争，法国拥有全世界最强大的重骑士军团，可是由于统帅的无能，被英国长弓兵打得落花流水。</p><p>而耶路撒冷王国的鲍德温四世，一个年轻的麻风病人，率领几百个骑士打得萨拉丁三万马木流克骑兵溃不成军，几乎全军覆没。</p><p>一个人很可能决定一个国家的命运。</p><p>也许任何一个国家，甚至中国历史上任何一个朝代都没有象现在那样金权至上。</p><p>无论中国的儒家思想还是西方的骑士精神，都告诉人们，人总是要有所追求的，不能仅仅盯着钱。</p><p>秦时，有个老头叫郦食其，70多岁了还跑到刘邦大营参与革命，当然最后下场比较凄惨，被齐王煮了。郦老头本事很大，只身到齐国说服齐王归降了汉王刘邦。韩信害怕郦老头功劳太高，超过自己，于是很不仗义，在郦老头人还在齐国的时候，带兵攻打了齐国。齐王很愤怒，后果很严重，把郦老头放在锅里煮了。郦老头的才能出众，本想做一番事业，可惜没有算到人类本性丑恶的一面。</p><p>当然韩信也没有好下场，这个军事上的天才，政治上的白痴，本来做了齐王，汉、楚、齐三足鼎立，结果向刘邦缴了枪，直接兔死狗烹了。</p><p>另一个喜欢没事找事的老头叫姚广孝，是个和尚，法号道衍。虽是和尚，但既无和尚的慈悲心肠，又无和尚的遁世清修，这个老头专门搞权谋，不玩阳谋专玩阴谋，背靠朱棣这颗大树，不图名不图利，专搞武装夺取政权。</p><p>姚老头的头脑比郦老头高得多，不但是牛叉的阴谋家，也是牛叉的政治家，此人协助朱棣夺权后，深味帝王权术的精髓。不立家室，不营产业，把一脑袋阴谋全都转向文化事业，跟大才子解缙纂修《永乐大典》，是为数不多投身权谋得了好死的大师级人物</p><p>另一个喜欢没事找事的老头叫姚广孝，是个和尚，法号道衍。虽是和尚，但既无和尚的慈悲心肠，又无和尚的遁世清修，这个老头专门搞权谋，不玩阳谋专玩阴谋，背靠朱棣这颗大树，不图名不图利，专搞武装夺取政权。</p><p>姚老头的头脑比郦老头高得多，不但是牛叉的阴谋家，也是牛叉的政治家，此人协助朱棣夺权后，深味帝王权术的精髓。不立家室，不营产业，把一脑袋阴谋全都转向文化事业，跟大才子解缙纂修《永乐大典》，是为数不多投身权谋得了好死的大师级人物</p><blockquote><p><strong>打工不易：</strong></p><p>我个人认为：个人的智慧来自对大方向的把握，否则再有才干也难有作为。</p><p>单位司机，工厂工人即便技术再好，工资也高不到哪去。</p><p><strong>kkndme：</strong></p><p>聪明智慧决定了人的眼界，有远见的人一定会未雨绸缪。刘邦身为区区亭长可以得天下，朱元璋一个穷和尚驱除鞑虏重建朝廷，一个司机未尝不能当富商，一个小姐也可能当局长</p></blockquote><h2 id="对于具备投资属性的商品，供求关系是指货币与商品之间的关系"><a href="#对于具备投资属性的商品，供求关系是指货币与商品之间的关系" class="headerlink" title="对于具备投资属性的商品，供求关系是指货币与商品之间的关系"></a>对于具备投资属性的商品，供求关系是指货币与商品之间的关系</h2><p>关于供求关系还是有必要解释一下的</p><p>一提起供求关系，马上口水就来了，什么空置率啦，闲置率啦，空置我心啦，电表显示6000万套房没人住啦。</p><p>实际上供求关系跟空置率和闲置率完全没有关系。</p><p>对于具备投资属性的商品，供求关系是指货币与商品之间的关系。当货币量大于商品供应量时，商品价格就会上涨，即使人为打压也是短期行为，这是铁律。</p><h2 id="早买的风险小于晚买"><a href="#早买的风险小于晚买" class="headerlink" title="早买的风险小于晚买"></a>早买的风险小于晚买</h2><blockquote><p><strong>fantabulouski：</strong></p><p>楼主给点意见吧，想在上海市内环内买套二手房，现在出手合适嘛？</p><p>等等的话可能跌点么？有没有什么风险吗？</p><p>多谢！ 因为首套房可以贷款七成，多谢！！</p><p><strong>kkndme：</strong></p><p>如果手头有钱，又是自住，到不一定非要考虑抄在最底部。</p><p>因为钱要贬值是毋庸置疑的，房价在一段较长时期上涨的趋势也是毋庸置疑的。</p><p>但短期，波段性的抄底和逃顶是很难把握的，尤其是自住，考虑太多实在没有意义。</p><p>持币要冒房价持续上涨的风险，买房可能会面临短暂小幅下跌，哪个风险更大，需要自己认真考虑。</p><p>一线城市如上海一定会有短期的滞涨甚至小幅的下跌，当新房的价格低于周边二手房价，并且成交量开始逐渐攀升就是买房的时机。 <br>我反复强调，这次调控期却是二三线城市的补涨期，对于一线城市正好可以仔细的挑选好房，这种机会在房价上升期是难以遇到的。</p><p><strong>fantabulouski：</strong></p><p>楼主再问一个问题，看看这一两天调控的信息满天飞，上海房产税的消息也到处都是，银行在不断的紧缩，感觉这次调控可是不同以往，是外松内紧啊，至少到年底前看不到放松的迹象，还什么情况下才可能会放松呢？难道要等到KQ 接班不成？</p><p><strong>kkndme：</strong></p><p>可以肯定的是首付款的比例是不会轻易放松的。房产税的推出就没那么容易了。</p><p>上海和北京城区的二手房价有点幅度的下跌几乎不可能，很长一段时间都会滞涨或者维持小幅度的上涨。</p><p>手里资金多的人全款买房的比例大幅提高，精英阶层的购买力基本能够维持一线城市的正常的成交量（09年下半年的高成交量zy认为是反常的，已经影响了金融秩序，是zy不愿意看到的。）</p><p>现在的状况是，zy对调控后一线城市的房价增幅及成交量基本是满意的。</p></blockquote><h2 id="小开发商的房子能不能买？"><a href="#小开发商的房子能不能买？" class="headerlink" title="小开发商的房子能不能买？"></a>小开发商的房子能不能买？</h2><blockquote><p><strong>mstsc_XP：</strong></p><p>楼主的分析让我明白了很多之前误解的东西，所以自己错过了买房时机也是有一定道理的O(∩_∩)O哈哈~</p><p>比如空置率、供求关系、当地房价和当地平均收入关系等的解释，非常感谢</p><p>想再请教一下，zy要挤出小开发商的话，到2012年，这些小开发商修的房子会不会烂尾?因为被挤出了，也不好好修了，或者干脆跑了…..因为我买的房子不是华润、中海这些有实力的开发商的楼….</p><p><strong>kkndme：</strong></p><p>如果不是经济危机，基本不会出现这种情况，当然排除个别不诚信的开发商</p></blockquote><h2 id="大兴土木搞建设的城市，房价都底不了"><a href="#大兴土木搞建设的城市，房价都底不了" class="headerlink" title="大兴土木搞建设的城市，房价都底不了"></a>大兴土木搞建设的城市，房价都底不了</h2><blockquote><p><strong>黛眉轻：</strong></p><p>LZ厉害，分析得很透彻。请教LZ，对于目前的合肥房价怎么看呢？做为皖江城市带的中心城市，合肥的房价目前中心城区已经到了7000，也有了超过万元的所谓豪宅。和武汉长沙比起来，经济上感觉合肥还是差的，可是房价却已经不差了。</p><p><strong>kkndme：</strong></p><p>凡是大兴土木积极拆迁的城市，房价都低不了，城市发展规划的资金都要得益于dfzf卖地。这是zf主导投资经济模式的必然结果。这也是二三线城市在这次调控中补涨的根本原因</p></blockquote><h2 id="北京老式砖混板楼的最终命运？"><a href="#北京老式砖混板楼的最终命运？" class="headerlink" title="北京老式砖混板楼的最终命运？"></a>北京老式砖混板楼的最终命运？</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>楼主我想请教一下：就是北京二三环甚至四环有不计其数的老式砖混板楼，年代分布从六七十年代到八十年代初的都有，这些房子都是北京城市发展的产物，也是北京留给土著们的天然福利，但是现在有个问题是它们的房龄已经超过30年奔着40,50去了，这些房子的命运如何呢？拆迁吗？在原址上盖回迁房或者重新规划把里面的居民赶到周围郊区？</p><p>因为随着政策的收紧，这类房子越来越不容易流通了，银行不给贷款，升值空间也逐渐放缓，但是地段都非常好。是不是随着房龄的增加，这类房子只剩下保值功能而最终无法流通了呢？</p><p>这批房子最终会大规模寿终正寝，不知道dfzf会怎么处置？很想听听你的看法。</p><p><strong>kkndme：</strong></p><p>这个情况比较复杂，因为大多数老房子是各大部委的单位房。原则还是谁的孩子谁包干，谁的孩子谁认领。所以说买房子买到公务员小区最保险，即使房子旧了也不会没人管，也不会存在物业跑路、小区沦为贫民窟的问题，即使老房子拆了单位盖了高楼，保证会在原址上还你一套。</p><p>至于说单位不行了或者单位不存在了的老公房也是有的，早晚会走拆迁的路子，那就没有原址回迁那么幸运了，肯定是搬到远郊区县，但补偿条件肯定不差，离开城中心到郊区就成了富翁。</p><p>位置决定了价值。北京郊区农民房拆迁补偿两万一平就算高的，但是城中心房屋拆迁，补偿款那都是10万一平起步的。愿意一掷千金全款买城中心老房子的人只会多不会少，说白了就是：哥买的不是房子，是位置。</p><p><strong>welldayzwb：</strong></p><p>现在貌似 还没有听说10万的，反而是听说政府给你的补偿比市价二手房价格还低不少，如果没有拼死斗争的话</p><p>前段看新闻说是北京要控制拆迁成本，估计就是为了这一步压缩成本来着</p></blockquote><h2 id="把房买在zf边，差不了"><a href="#把房买在zf边，差不了" class="headerlink" title="把房买在zf边，差不了"></a>把房买在zf边，差不了</h2><blockquote><p><strong>yy45678：</strong></p><p>楼主您好，想请教下，最近想买房，三线城市老住宅区（我们那里最早的商品房90年建的）附近一幢私房，上下二层半，120平一层,带地皮93年的房子，所有证件齐全，不好的是建在一个山坡上不能进车子。售价一起30W，另是城市新区，新市政府边，小区房。现在还很荒，什么都不方便,但环境很好。请问是买哪一个房子好？我们那里平均楼价2000左右。</p><p><strong>kkndme：</strong></p><p>2000一平的地方，好像算不上三线城市，大概应该是地级市或者县级市的房价。</p><p>一般来说房子买在市政府边上怎么也不会有问题，只要确定新市政府已经搬到你说的那个地方，该地的升值空间肯定是有的。但是如果仅仅是zf规划就要谨慎了，因为规划并不等于真的搬迁。</p></blockquote><h2 id="天子脚下：二手老房买得好，拆迁补偿少不了"><a href="#天子脚下：二手老房买得好，拆迁补偿少不了" class="headerlink" title="天子脚下：二手老房买得好，拆迁补偿少不了"></a>天子脚下：二手老房买得好，拆迁补偿少不了</h2><p>旅行中，上个网是很不容易的事情。</p><p>关于拆迁补偿的事，巨大的利益驱使，那真是鲜血淋淋的。所以二手老房买在哪里很重要。银行的房、zf的房、各大部位的房，有上市交易的，买下来肯定不会吃亏。</p><p>存在风险的就是弱势群体聚居区。但是北京，毕竟天子脚下，不能搞得太僵，最终该补的还是会补到位，至于外省就很不好说了</p><h2 id="3万入手北京四环，你也是幸运的"><a href="#3万入手北京四环，你也是幸运的" class="headerlink" title="3万入手北京四环，你也是幸运的"></a>3万入手北京四环，你也是幸运的</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>北京七八十年代的砖混老房有体制内的，也有体制外的。现在公房上市流通，好多央产房也易主了，也许过个十年二十年的这批房子的产权证上早已换了一波又一波人。除非像楼主所说的昆明那种大型的省市公务员小区，房子新，户型好，环境和地理位置都不错，一般公务员没个20年轻易不会卖。</p><p>北京的这些老楼，不管谁是房主，肯定值钱，房子不值钱，位置还值钱呢。</p><p>至于这些房子使用寿命到了以后怎么处置，谁也说不清，能不能回迁，要看dfzf和规划局的利益。比如眼下金融街西侧月坛的老房子就要被集体拆除，连中学都要搬迁，这些西城人很有可能被撵到昌平回龙观西去，那边已经在建大批安置房了。</p><p>所以说，这些老房子不管是体制内的还是体制外的，命运如何不在自己手里。即使体制内的比较不错的老小区（比如三里河的建设部小区），如果牵涉到地方的利益，肯定也是毫不犹豫全部拆除，除非那里面住着实权人物当官的不让拆。这个时候就要看这些被拆迁户的谈判能力了，谈判能力强的，当个钉子户，当然是要得越多越好。</p><p>我以前买房的时候，也想了这些，不过最后还是买了新楼。现在因为地皮的价值，北京新老楼的房价差距不大，这个在别的城市是不可思议的。</p><p>很感谢楼主发这么一个帖子，版主还给了个绿脸，要不然可能就错过拜读的机会了</p><p>其实有些问题平时自己也在思考，比如GDP为什么保八，房价和滥发纸币等等，但是关于炒房和房租这一块，思考的并不多，而楼主的帖子比较有条理和逻辑的分析了这些方面，真的是很感谢，我甚至不用自己写分析，只要把楼主的帖子稍微整理，就是一篇很不错的分析资料了。</p><p>关于zf收紧口子，抬高小老百姓炒房门槛这一块，天涯房观有几个高人和楼主的看法一致。我细细想了一下，这个提高首付到50%的政策，确实会成为长期政策保持下去，而其实即使没有这个政策，稳健型的小老百姓也会掂量自己的钱袋买房。没有谁想断供，因为刚需需要房子。</p><p>至于以后十年甚至更长时间，房价仍然会涨。因为城市的发展离不开勤劳的人民，zf在不断的修建地铁画大饼，就是为了土地能卖个好价钱，只有不断的卖地搞铁公鸡，才会有gdp，才会有政绩。统治阶级带着他的各种利益集团一起玩，而老百姓以后可玩之物会越来越少，只能老老实实的干活挣钱。</p><p>由于家人的优柔寡断和缺乏对北京房地产现实的认识，我直到今年初才在四环买了第一套房，3w多的均价，让家里背负了100多w的债务。我错过了07年1w的机会，和09年1w+的机会。世上没有后悔药，历史也不会重演，那些07年买房和09年买房的人是幸运的。我现在努力攒钱挣钱的同时，最希望看到的事情居然是房价尽快远离我的成本区，我知道没有买房的同学一定会抨击我这种想法，但是现实就是这样可笑，一方面希望房价能降，这样可以把老人接到身边，另一方面又希望房价涨，这样自己在还贷的时候心里稍微能好受点。呵呵，不知道自己这样是不是活得太累。</p><p>不管怎么说，希望大家都能住上自己称心如意的房子，这几年来，zf真把我们这些人折腾的够呛。我和家人都是传说中的体制内，体制内确实有福利，可惜要想自己的财富不缩水，还得靠自己。</p></blockquote><h2 id="君为贵，商人、技工次之，农民为轻，打工人为底"><a href="#君为贵，商人、技工次之，农民为轻，打工人为底" class="headerlink" title="君为贵，商人、技工次之，农民为轻，打工人为底"></a>君为贵，商人、技工次之，农民为轻，打工人为底</h2><blockquote><p><strong>傻子也疯狂：</strong></p><p>今天看到新闻<br>什么房产市场回暖啊<br>温州炒房团又出江湖了<br>成交均价上涨啊</p><p>请问这个是真的吗，房价会在短时间涨上去吗<br>如果是真的，那中央调控有什么用，在没有下降的基础上再涨10%<br>不是自己打自己嘴巴吗</p><p>很想听听楼主怎么看待这个事情。</p><p><strong>kkndme：</strong></p><p>维持在正常成交量，保持一个缓步上涨的趋势，是zy最愿意看到的。因为zy很清楚，除非体制上有大动作，否则让房价下跌只是唱给人听的口号。体制是不能动摇的根本，是国家稳定的基础，高房价是体制造成的必然结果。zy很清楚，最好的方式就是以一个平缓的速度增长。但是决策者是不是有此能力控制房价缓慢上涨，这是值得仔细研究的。</p><p>任何一个朝代，即使是我们在电影里常看到的奸佞当权，往往政策的初衷都是好的，但是执行效果却常常适得其反，领袖的智慧与执政能力对国家的命运起着至关重要的作用。</p><p>明朝朱厚照时期有个太监刘瑾，权势一手遮天，是个典型的奸佞。但他其实是很想做点事情的。</p><p>明朝开国时，朱元璋搞了个戍边屯田，相当于现在的军垦，因为军队自给自足，给国家省了大笔的银子。但是到了后来，军官们都变成了大地主，霸占了士兵的土地，把士兵当作佃农，依靠盘剥士兵来实现让一部分人先富起来的号召。这是与杀良冒功、贪吃空饷并列齐名的第三大快速发家致富手段。</p><p>我们说了刘瑾是个有雄心壮志，很想做点事业的高责任心人士。对于军官霸占士兵田产导致士气低下这件事很看不惯，很不满意。决定坚决打击这种行为。于是下令地方zf</p><p>清理军官霸占田产的问题。</p><p>军官霸占的田产不仅仅是士兵的，更多的是当地老百姓的。</p><p>按理说，这应该是个老百姓叫好的政策，而事实上这是老百姓头上的噩梦。</p><p>执行人是谁？地方官。</p><p>地方官执行的时候就实在为难了，军官老爷手里都是握着重兵的，你上门还没开口，兵大爷的刀已经架在脖子上了。可是刘瑾刘老板下达命令的同时，还是要下达任务指标的，没收的田产有任务指标，以前军官老爷占有的田都不交税，既然清理田产就要交税，交税也有任务指标。</p></blockquote><p>有些地方官比较聪明，不敢找军官大爷收，就摊派给了老百姓，结果老百姓又交田又交税，自然是连活路都没了。有些地方官脑子不清醒，真的跑去找军官老爷要田要税，结果造成军官勾结宁王造了反，最后刘瑾自己的脑袋也保不住了。</p><blockquote><p>历朝历代，统治者代表的都是地主阶级的利益。历朝历代的改革都只是为了缓和底层群众与地主阶级的矛盾，防止因为过激发生极端群体性事件。</p><p>调控也是为了缓和矛盾，要温水煮青蛙，而不要一把火把青蛙烧死。</p><p>关于自己打自己嘴巴的事，那是太多了，自古以来，统治者也从来不怕自己打自己嘴巴。古人就总结过，只准州官放火，不准百姓点灯。</p><p>以前的科举制度与现在的公务员考试制度基本目的都是相同的，让全天下的优秀的和不优秀但有出身的知识分子依附于官，这样就有了绝对的话语权。无法进入体制内的知识分子，有商业头脑和技术专长的人员，就相当于过去的商人、小作坊主，尽管也许还算富裕，但是没有任何地位，任人支配。要是没有一技之长，又不能经商，就基本上在社会的最底层很难翻身，相当于过去城市里的贩夫走卒，甚至无片瓦立锥，糊口都是困难，地位和稳定性反而远远不如自给自足，拥有宅基地的农民</p><p><strong>中年不惑吗：</strong></p><p>说到底空空太幼稚了 当年拖拉机之夜太学生怎么也想不到机关枪和拖拉机真的会招呼到自己身上 这和他们从小接受到的教育不一样 呀 主流宣传中party妈妈都是慈祥的温柔的全心全意为p民服务的</p><p>有皇帝大力支持的王安石变法到了地方法令也大变味 如今虎温的威权要远远小于当年的宋神宗和王安石 而且统治阶层从上到下的改革从来是为了巩固统治地位 至于p民收益那从来都是附属作用</p><p><strong>kkndme：</strong></p><p>这就是中西方的不同，西方的拖拉机是对外的，中国的拖拉机从来对的都是p民，对外基本比较忪。所以才有元和清，明明是外族入侵灭了国，还要把蒙古人和女真人一起拉进来统一叫中华民族，居然认为中华民族很强大，元朝时一直打到亚得里亚海。也不管蒙古人跟中华的两河文明有关系没有。</p></blockquote><h2 id="10年的调控和08年调控的区别、带来的影响、机会"><a href="#10年的调控和08年调控的区别、带来的影响、机会" class="headerlink" title="10年的调控和08年调控的区别、带来的影响、机会"></a>10年的调控和08年调控的区别、带来的影响、机会</h2><p>这次调控与08年调控后的结果是有所区别的。08年调控的结果是一线城市的暴涨；而2010年调控的结果是房价以二三线城市为主的全面上涨。不但是二三线城市，高房价甚至已经传到至四线及以下城市。</p><p>在二三线以下城市，无房户的需求其实并不大，真正的刚需来自改善性住房。城市升级使人们开始不满足过去老旧式住房的居住环境，开始追求大盘大开放商的品质住宅。房价也由此迎来全面上涨。这种全面上涨，不能理解为全面泡沫，而是有基础存在的。不能理解为全国炒房。特别是四线及以下城市尽管新盘价格高涨，老旧住宅却乏人问津，县级市二手房变现也比较困难。在2010年的调控的大背景下，却神奇的出现了二三线以下城市的刚需大量释放现象，不得不令人叹为观止。这神秘的幕后推手其实就是资金的规律。</p><p>对于在2010年初布局二三线城市的房开商和有远见的投资者，在这次调控中，无疑是受益者。</p><p>一线城市，这次调控给刚需买房者一个最好的入市良机，但是能够抓得住的只是少数。</p><h2 id="历史总是惊人的相似"><a href="#历史总是惊人的相似" class="headerlink" title="历史总是惊人的相似"></a>历史总是惊人的相似</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>其实，几千年来，唱的都是同样的戏，只不过台上的演员变换而已。</p><p><strong>kkndme：</strong></p><p>赞赏这一句，呵呵，历史规律是不变的，变化的只是时间、地点、人物、事件。</p><p>城头变换大王旗。</p><p><strong>tjOOSAN：</strong></p><p>历史规律是不变！但他妈世界变了！~~ 中国采用资本主义制度了</p><p>还只参考中国历史？</p><p><strong>kkndme：</strong></p><p>你知道什么叫资本主义制度吗？</p><p>首先基础是三权分立。</p><p>早在1748年，孟德斯鸠男爵发表了伟大的划时代的巨著“论法的精神”明确提出了三权分立。奠定了资本主义制度的基础。三权分立制度就是国家的立法、行政、司法三权分别由三个机关独立行使，并相互制衡的制度。讲的是法律精神，讲得是私人财产神圣不可侵犯。</p><p>而作为一个人治而非法制国家，怎么能说是资本主义呢？</p><p>建议个别（tjOOSAN）不读书，不研究，不了解中西方历史，不懂经济，对社会制度基本的理解基本是个白痴的同志，就不要乱发表议论了，惹人笑话。</p></blockquote><p>无论是中国还是西方历史对现在都是很有借鉴意义的。这就使毛说过的“古为今用，洋为中用”，毛建的武装斗争及建国思想其实很大程度来自于朱元璋。</p><p>古代君主统治国家征服世界靠战争武器，现在则靠金融武器。</p><p>西方，我们所熟悉的具备最纯正贵族血统的哈布斯堡家族，曾经的德意志王国和神圣罗马帝国的统治者，家族成员曾经统治过欧洲诸国：包括波希米亚王国 、匈牙利王国 、克罗地亚及斯洛文尼亚王国、伦巴第及威尼斯王国 、奥地利皇室领地 、萨尔茨堡公国 、塞尔维亚及塔米斯-巴纳特公国等等无数欧洲国家。</p><p>而现在，哈布斯堡家族控制着华尔街，继而通过华尔街控制着全球的经济。</p><p>历史是在继承的前提下发展的，特别是在西方，现在几乎每一个显赫的家族都能追根溯源。因为尽管西方也发生大革命，但是象文革一样彻底否定历史是完全不可思议的。</p><p>我们有点英雄情结的人听到最多的西方中世纪十字军三大骑士团：圣殿骑士团、条顿骑士图案、医院骑士团；直到现在仍有两大骑士团存在。条顿骑士团总部现在还在德国，专门从事慈善事业。医院骑士团后来改名为马耳他骑士团，也就是现在的马耳他，世博会还来上海参展。只有圣殿骑士团灰飞烟灭，但现在仍有大量的修士组织自称为圣殿骑士团的继承人。</p><p>完全不懂历史，就等于完全不懂得社会。</p><h2 id="关于房贷"><a href="#关于房贷" class="headerlink" title="关于房贷"></a>关于房贷</h2><blockquote><p><strong>四环四环：</strong></p><p>同意LZ。<br>刚刚父母帮忙首付、自己还贷，在北五环边买了个小房。<br>判断依据非常简单：一个是国家政策和我等屁民生活是两岔儿的，既然移民无望，就赶快站队；一个是力所能及、负担得起。</p><p>07年底和09年底都错过了机会，也是当时条件不允许，一次是自己嫌弃燕郊太远；一次是嫌弃通县太远。完后工作逐渐稳定，一狠心安了家，剩下的就是往体制外金字塔中层挤吧。</p><p>LZ所说，正是我说不清楚、但能判断大概的那些事儿。<br>哈哈。</p><p>请教LZ：</p><p>眼下商业贷款贷款46万。<br>分20年还，月供3066<br>分30年还，月供2562</p><p>朋友劝我贷款时间越长月供越少越好。<br>直觉判断我觉得也是这样。<br>有科学依据么？</p><p><strong>kkndme：</strong></p><p>你的朋友考虑是有道理的。<br>如果不考虑通货膨胀，当然是利息越少越好，20年还的利息要少于30年还的利息。<br>但是因为通货膨胀的因素，我国是高增长高通胀的国家，每年的通胀率远远大于实际公布的数字，更远远高于贷款利息，所以贷款时间越长越好。<br>至于月供是否越少越好，完全取决于个人的承受能力，有条件当然买大房子，宁肯月供多一点。但是条件不够就买小的，量力而行。</p><p><strong>四环四环：</strong></p><p>谢谢楼主指点。</p><p>假设通胀率有一个固定值（当然实际这是没有的，它也是个取决于经济规律和国家意志的不确定因素）、贷款利息有一个值。<br>完后不同的贷款年限。<br>就能估算出两个值此消彼长。</p><p>需要选择判断的是，通胀率这个值的数字。<br>但通过对国际意志不确定因素极端情况的估算，预计这个值。</p><p>完后把这变成一个数学题。</p><p>是这意思么？</p><p>那不用算了，按常识，知道该怎么选了。</p><p><strong>kkndme：</strong></p><p>银行贷款的年限越高，利息支出越高，但不会高过通胀。你能贷30年就贷30年，这是你年轻的优势。年纪大点的就只能贷25年，甚至20年了。</p><p>所以说40岁买房的人很不靠谱，首先40岁的人不一定有钱，反而错过了最敢买房的黄金年龄。其次是40岁贷款年限就短了好多，相当于月供压力更大了。</p></blockquote><h2 id="买卖商品房会逐渐变成富人的游戏"><a href="#买卖商品房会逐渐变成富人的游戏" class="headerlink" title="买卖商品房会逐渐变成富人的游戏"></a>买卖商品房会逐渐变成富人的游戏</h2><p>以后，商品房本来就变成了富人间的游戏，普通人将不能卖进参与的门槛。</p><p>到多数人真的买不起房时也就安心了，也不用关心房价的涨跌了。</p><p>但是现在，房价还没有到那个高度，很多人还觉得有希望，所以对房价的涨跌才会特别关注。这个时期应该就是普通人最后买房的机会。错过了，将不会再有。</p><h2 id="zf还是更在意农民问题"><a href="#zf还是更在意农民问题" class="headerlink" title="zf还是更在意农民问题"></a>zf还是更在意农民问题</h2><blockquote><p><strong>肖肖19850706：</strong></p><p>楼主虽然有很多观点写的很有道理，但是对于历史这块，并不太正确</p><p>引用一段楼主的话：<br>——————<br>自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。<br>因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。<br>农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。<br>而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。<br>——————</p><p>其实在当今政权建立之前，还有一个政权，叫做中华民国<br>这个政权是由民主革命带来的<br>他们所举的旗帜是资产阶级革命，所建立的政权是资本主义社会<br>为什么会失败？<br>这是一个值得思考的问题<br>让一个经历了5000年封建社会的国家经过一次革命就达到资本主义社会的境界<br>没有工业革命的基础<br>没有原始的积累<br>有的只是借鉴西方<br>想先变制度再进行调整，结果固然是失败<br>于是“农民起义”卷土重来，我想大家肯定明白“农民”所指的是什么<br>于是又了现在的这个政权<br>由工人阶级和资产阶级去推翻帝制<br>再由农民阶级把土地抢回来，最终回到封建政权来压迫资产阶级<br>他们最怕的还是农民么？<br>显然不再是了<br>他们最怕的正是资产阶级<br>其次就是你说的那些<br>“关心自己能否拥有一套产权房，除了呻吟一下意外，几乎是没有什么有效反抗的可能的都市白领”<br>攻占巴士底狱的不是农民<br>正是这些“几乎没有什么有效反抗可能的都市白领”<br>是工人阶级结束了地球上长达上千年的封建统治<br>而改革开放，市场经济的发展，给了这一切充足的物质基础<br>社会的转化过程有两种<br>一种是和平演变<br>一种就是革命</p><p>现在所存在的问题，不是他们更怕谁<br>而是他们选择面对哪种演变方式</p><p><strong>kkndme：</strong></p><p>最可怕的不是农民而是失去土地的农民。<br>为什么说新民主主义革命是工人阶级领导的？<br>那时的工人阶级是什么？就是失去土地的农民和破产的手工业者，除了体力一无所有，所以他们才具备脑袋掖在裤腰带上，为了抢土地而玩命的动力。解放战争时期，我军的宣传就是：“同志们，国民党要把分给你们的土地抢走，你们说怎么办？”于是广大失去土地的农民兄弟不干了，玩命了。<br>工农红军一四方面军胜利会师，在选择南下和北上发生了分歧，真的为了北上抗日吗？1935年抗日战争还没有打响，日本人在东北而不是西北。北上抗日的说法实在有些牵强。<br>我想真正的原因还是群众基础。<br>近几年多次在西南地区的乡村进行田野调查，发现一个问题：解放前，即使如贵州山区的偏僻乡村，农民自给自足吃饱肚子是完全没有问题的，更别说富庶的四川平原。<br>那时参加红军要有不要脑袋的玩命精神，对于多数能够填饱肚子的农民来说，主动参加革命显然是不现实的。红军在西南地区完全没有群众基础，战斗中的减员得不到有效的补充，所以人才会越打越少。<br>而西北地区完全不同，自然条件恶劣，农村耕地很少，存在大量食不果腹，无地可种的农民。李自成起义也是从陕西发起的，可以说具备了随时发动武装暴动的群众基础。所以毛选择了北上的正确路线。而张同志南下凄惨的下场印证了毛的正确判断。<br>北上延安的另一个重要原因是获得苏联的支持，没有强大的后援是无法取得决定性胜利的。</p><p>一旦农民失去了土地，而又没有去处，那是相当可怕的，所以农民工就业问题是zy最为关注的。甚至提出如何让农民工在城镇买房子置业，处理好农民问题，是社会稳定的重中之重。</p><p>将来，有地可耕的农民将会成为都市中的底层群众羡慕的对象，农民有地有住宅有粮食。进可以在城市打工，有聪明的甚至通过经商迈进富人阶层，退可以回乡种田，虽然现钱不多，但是吃穿住行都是没有问题的。</p><p>而真正一无所有的将是大量在都市中沦为贫困的人群。在打拼挣扎的打工仔，如果没有能力购置房产，也没有得到向上爬的机会，在都市立足将变得困难，而又毫无退路。</p></blockquote><h2 id="治国需要用贪官、反贪官"><a href="#治国需要用贪官、反贪官" class="headerlink" title="治国需要用贪官、反贪官"></a>治国需要用贪官、反贪官</h2><p>讲个故事，可能这个故事很多人都看过，并且曾经多次被转帖：</p><p>宇文泰是北周开国的奠基者。当他模仿曹操，作北魏的丞相而“挟天子令诸侯”之时，遇到了可与诸葛亮和王猛齐名的苏绰。宇文泰向苏绰讨教治国之道，二人密谈 三日三夜。</p><p>宇文泰问：“国何以立？”</p><p>苏绰答：“具官。”</p><p>宇文泰问：“如何具官？”</p><p>苏绰答：“用贪官，反贪官。 ”</p><p>宇文泰不解的问：“为什么要用贪官？”</p><p>苏绰答：“你要想叫别人为你卖命，就必须给人家好处。而你又没有那么多钱给他们，那就给他权，叫他用手中的权去搜刮民脂民膏，他不就得到好处了吗？”</p><p>宇文泰问：“贪官用我给的权得到了好处，又会给我带来什么好处？”</p><p>苏绰答：“因为他能得到好处是因为你给的权，所以，他为了保住自己的好处就必须维护你的权。那么，你的统治不就牢固了吗。你要知道皇帝人人想坐，如果没有贪官维护你的政权，那么你还怎么巩固统治？”</p><p>宇文泰恍然大悟，接着不解的问道：“既然用了贪官，为什么还要反呢？”</p><p>苏绰答：“这就是权术的精髓所在。要用贪官，就必须反贪官。只有这样才能欺骗民众，才能巩固政权。”宇文泰闻听此语大惑，兴奋不已的说：“爱卿快说说其中的奥秘。”</p><p>苏绰答：“这有两个好处：其一、天下哪有不贪的官？官不怕贪，怕的是不听你的话。以反贪官为名，消除不听你话的贪官，保留听你话的贪官。这样既可以消除异己，巩固你的权力，又可以得到人民对你的拥戴。其二、官吏只要贪墨，他的把柄就在你的手中。他敢背叛你，你就以贪墨为借口灭了他。贪官怕你灭了他，就只有乖乖听你的话。所以，‘反贪官 ’是你用来驾御贪官的法宝。如果你不用贪官，你就失去了‘反贪官’这个法宝，那么你还怎么驾御官吏？如果人人皆是清官，深得人民拥戴，他不听话，你没有借口除掉他；即使硬去除掉，也会引来民情骚动。所以必须用贪官，你才可以清理官僚队伍，使其成为清一色的拥护你的人。”</p><p>他又对宇文泰说：“还有呢？”</p><p>宇文泰瞪圆了眼问： “还有什么？”</p><p>苏绰答：“如果你用贪官而招惹民怨怎么办？”宇文泰一惊，这却没有想到，便问：“ 有何妙计可除此患？”</p><p>苏绰答：“祭起反贪大旗，加大宣传力度，证明你心系黎民。让民众误认为你是好的，而不好的是那些官吏，把责任都推到这些他们的身上，千万不要让民众认为你是任用贪官的元凶。你必须叫民众认为，你是好的。社会出现这么多问题，不是你不想搞好，而是下面的官吏不好好执行</p><h2 id="二线城市典型代表"><a href="#二线城市典型代表" class="headerlink" title="二线城市典型代表"></a>二线城市典型代表</h2><blockquote><p><strong>klid：</strong></p><p>LZ 成都属于您口中的二三线城市么？<br>那么这次属于补涨阶段？</p><p><strong>kkndme：</strong></p><p>成都、重庆、西安、昆明、武汉都是二三线城市的典型代表。</p></blockquote><h2 id="关于商铺和住宅投资"><a href="#关于商铺和住宅投资" class="headerlink" title="关于商铺和住宅投资"></a>关于商铺和住宅投资</h2><blockquote><p><strong>马甲马甲_马马甲：</strong></p><p>请教楼主：</p><p>因为种种原因， 错过了很多买房的好时期，现在租房住，（ 享受到了朋友提供的体制内的好处， 远低于市场价格租了一套房子）。</p><p>手上200万左右的现金， 在上海，想买房子保值增值，</p><p>1，有套著名大学附近的二手房子，57平米， 130万左右，估计租金大约是2.5万-3万 之间，<br>2，在市中心成熟的商业区有个店铺， 124万， 年租金现在是6.4万一年。</p><p>2个选择，个人倾向于投资店铺， 因为在上海店铺的涨价远远低于住宅的涨幅，况且店铺的资金回报率也达到了 5% ，不知道楼主是否有更好的建议？</p><p><strong>kkndme：</strong></p><p>很多人不愿意投资商铺还是在于风险大，好位置熟铺是很少有人愿意拿出来卖的，谁愿意放弃生蛋的母鸡呢？而新开发的商铺要不然位置比较偏，不知道能不能做的起来，要不然就溢价太高，超出了大多数人的承受。好的商铺是市面上很难买到的。</p><p>如果经过考察确认商铺没有问题，还是首选商铺，但是一定要经过认真的考察。</p><p>而住宅的风险就相对小多了，而且投资不需要很多的经验，更适合一般投资者。</p></blockquote><h2 id="关于房产调控"><a href="#关于房产调控" class="headerlink" title="关于房产调控"></a>关于房产调控</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>请问楼主，房价会在年底重新确立上涨趋势吗？如果再不涨，政府的地卖不上好价钱，地方财政就回吃紧，地方政府还会像去年那样出各种政策救市吗</p><blockquote><p><strong>九五二七八：</strong></p><p>全国各地 一线二线三线 情况都有不同<br>楼主预测时点 怕不好预测啊</p><p><strong>kkndme：</strong></p><p>不但是不同城市情况有区别，同一城市的不同区位情况也有区别。就拿北京来说，过渡爆炒的通州房山等远郊区县，房价一定会有所回调，但是城市中心，特别是学区房是没有下降可能的。</p><p>而对于多数二三线城市，均价下降的原因主要还是远郊区的房源投放量增加，城区内的房子不但不降，而且涨得还很厉害。</p><p>房产投资最重要的还是位置，当远郊区县的房价远低于城中心的时候，一定会有补涨的要求，但当远郊区县的房价向城中心接近的时候，一定会出现城中心的补涨，当然在调控期也会体现为远郊区县房价的回调。</p></blockquote><p><strong>kkndme：</strong></p><p>仔细看一下各地的房价，不要被公布的所谓均价迷惑，只有少部分城市价格下降或者持平，多数城市都在上涨，只不过幅度不大而已。现在成交量属于正常水平，不存在dfzf吃紧的问题，当然不可能象09年那样的疯狂，09年底甚至银行出现无款可贷，太高的成交量会被zy视为危险的信号，是达到危害金融安全的高度的。</p></blockquote><h2 id="关于房产税"><a href="#关于房产税" class="headerlink" title="关于房产税"></a>关于房产税</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>还有一问题请教楼主，目前我一共有三套房，一套自己住，一套父母住，一套是投资房，在大连最繁华的地方，租金回报是百分之六点五，请问房产税会很快推出吗？我的那套投资房是卖掉还是持有呢？卖的话能赚白分之五十</p><p><strong>kkndme：</strong></p><p>在卖掉之前，你要先问问自己，拿这笔钱打算干什么？如果没的可做，干等着贬值，那你为什么要卖呢？<br>如果你有更好的投资或者创业渠道，那当然立刻卖掉，不用犹豫。<br>至于房产税，第一：近两年一定不会征收，因为条件还不成熟。第二：房产税只是一项苛捐杂税，目的是补充财政收入，并没有降低房价和租金的功能，并且只能导致租金的上涨。怕房产税的应该是租客，而不是房东。</p></blockquote><p>任何税种最终都要转嫁到社会最底层群众身上。丛林法则实际就是大鱼吃小鱼，小鱼吃虾米。</p><p>上层人士的享受是靠底层群众勒紧裤腰带过日子换来的。</p><h2 id="老公房的拆迁问题"><a href="#老公房的拆迁问题" class="headerlink" title="老公房的拆迁问题"></a>老公房的拆迁问题</h2><blockquote><p><strong>wofuleyumin1：</strong></p><p>从头至尾，一口气看完了。。赞同之极。。。</p><p>也向楼主问些问题。。。</p><p>是否老公房都会拆迁？<br>在成都，一环，二环内还有非常多的老公房，总量比商品房还多，这么多的房子都会拆迁吗？<br>我在想是否先买套老公房。。因为价格也便宜。新的商品房一般八九千。。老公房才5千多。买了后灯拆迁。</p><p>但这么多老公房都会拆迁吗？我觉得可能很多房子是不会拆迁的吧？否则只要现在买这些房子，以后都发财了。</p><p>是否拆迁的只是很少部分？</p><p><strong>kkndme：</strong></p><p>将来多数房都会拆迁，这是中国体制和经济发展模式决定的。在城市拆迁改造升级过程中，大量的老房拆毁，大量的新房拔地而起。而随着拆迁改造的成本的上升，房子也越来越贵。<br>现在拆迁改造集中建设70-90的小户型，将来会沦为新的城中村，通过二手置换，这类房子会变成新的贫民窟，而将来的拆迁改造建设的一定是追求环境品质的大户型。<br>因为zf官员任期的限制，决定了官员的短视，决定了城市规划的短视。<br>但是市中心的房子，即使在将来人口下降的过程中，仍然是稀缺的，房价高不可攀的。如果手有余钱首选的是市中心的大户型。<br>关于市中心老旧二手房的购买，还是有一定学问的，一定要选择位置好，低密度的矮层住宅楼，因为密度低，便于拆迁。而密度高的塔楼拆迁非常困难，拆迁成本太高，开发商很难有利可图。现在住在市中心高层旧式塔楼的富裕人口，将来一定会二次置业，这些旧式塔楼逐渐会沦为新一代年轻中产阶层的过渡性住房。</p></blockquote><h2 id="投资新房还是老公房"><a href="#投资新房还是老公房" class="headerlink" title="投资新房还是老公房"></a>投资新房还是老公房</h2><blockquote><p><strong>wofuleyumin1：</strong></p><p>楼主。。谢谢你的答复</p><p>我接着问</p><p>你说现在投资是投资一套新房好，，还是找个老公房投资？</p><p>新房，，一切都好，但价格贵。。</p><p>老公房，一切都不好，但价格便宜。。主要是等拆迁。。但可能要等七八年。。（从我近2年的观察，一般都要这么久。。除非有内部消息）</p><p><strong>kkndme：</strong></p><p>有钱当然是新房舒服。</p><p>老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。</p><p>关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。</p><p><strong>wofuleyumin1：</strong></p><p>有钱当然是新房舒服。<br>老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。<br>。。。。。。。。。。。。。。。。。。。</p><p>楼主的意思是。。还是投资新房比较好？</p><p><strong>kkndme：</strong></p><p>还是量力而行，买老公房也比不买强，有条件当然买新房。</p></blockquote><h2 id="高端盘有房价带动作用"><a href="#高端盘有房价带动作用" class="headerlink" title="高端盘有房价带动作用"></a>高端盘有房价带动作用</h2><blockquote><p><strong>wofuleyumin1：</strong></p><p>楼主。。。又有一个问题</p><p>我附近的普通房子大概9000 旁边有个02年的别墅现在13000 现在又有一个新的楼盘开盘了。。是电梯 容积3 十多层的 是中海的高端项目，装修过的 居然卖将近2万。。。离谱吗？旁边容积0.8的老别墅才13000啊 </p><p>请问中海这个项目是否价格过高？ 另外，这个项目对我这附近的房价能拉动多少？</p><p><strong>kkndme：</strong></p><p>高端房产，开发商都是不急着卖的，而且也从来不乏有钱人慷慨解囊。你说的情况跟昆明的空间俊园完全相同。在市中心徘徊在万元关口的时候，空间俊园直接开出了19000的均价，之后市中心的二手房紧随攀升到15000.而一环二环间的房价在万元关口徘徊。</p><p>大盘高端盘对房价的带动作用是显而易见的。</p><p>自调控刚刚推出的时候，与一个朋友闲聊，说起调控将是二三线城市大涨的机会，还聊了聊昆明的发展，结果那个朋友头顶调控的大棒，去昆明投了n套房产，当时价格7000多点，时过几个月，现在看房价已经涨到9000.而且他买的位置周边先后有高端大盘推出，预计开盘价格在12000-15000，一旦高端大盘开盘将让他买的房子直接迈上万元的台阶。</p></blockquote><h2 id="买房和没买房的差距"><a href="#买房和没买房的差距" class="headerlink" title="买房和没买房的差距"></a>买房和没买房的差距</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>新穷三代。。。ORZ<br>我可不想做穷一代。。。。</p><p>房子真的让人抓狂，当跟你同样起点的人早你三年买房的时候，这种感觉尤为明显。</p><p>我老公是77年的，他一个女同学2007年底在清河新城买了一套房，一百多平100多万吧，找家里东拼西凑的全款。其实当时我老公也能拿出100w不用借钱的，可是他偏不听我的话，认为清河在五环外，那种地方还要100多万不可思议。结果北京经历了09年的疯狂以后他同学那套房子已经翻倍，借的钱也已经还清。</p><p>而我们呢，在犹豫和老公的优柔寡断中错过了时机，终于在2010年3月最疯狂的时候入手了，这时候即使首付160多万，还要背负100多万的贷款，生活质量比他的女同学差的不是一点半点。</p><p>这是真实发生的事情，犹豫和无知真的能让人付出很大的代价。</p><p><strong>kkndme：</strong></p><p>清河新城好像是50年产权吧。反正我对50年产权的都不感冒。<br>我一朋友06年买的水木天成，买时5000多，现在25000，调控都不带降价的。</p><p><strong>汝爱之罪：</strong></p><p>清河新城盘子还是很大的，分好几期，有70年也有50年，他们买的是70年的。07年底刚开第一期，相当于股市里的打新股了，基本上没什么风险。</p></blockquote><h2 id="房产交易历史"><a href="#房产交易历史" class="headerlink" title="房产交易历史"></a>房产交易历史</h2><p>最早的房产交易，出现在一个名字叫“盉”的西周青铜器上。在公元前919年农历三月份，一个叫矩伯的人分两次把一千三百亩土地抵押给一个叫裘卫的人，换来了价值一百串贝壳的几件奢侈品，包括两块玉，一件鹿皮披肩，一条带花的围裙。</p><p>周厉王三十二年又发生了一宗土地买卖。这宗土地买卖的交易过程也被刻在青铜器上。 </p><p>这次记录的是周厉王买地的事，周厉王为扩建王宫，买下一个叫鬲从的人的地，没有立即给钱。鬲从担心周厉王赖账，周厉王派人对鬲从说：“你别怕，我一定会照价付款的，如果我赖账，就让上天罚我被流放好了。”这是个很毒的誓。</p><p>周厉王买地花了多少钱，铭文上没写。不过李开周说，有人买地，有人卖地，说明当时除了有土地抵押，还存在土地买卖，房地产市场已经有了雏形。</p><p>隋唐时，有个叫窦乂的人，他生在陕西，很小的时候就死了爹娘，无依无靠，跟着舅舅一块儿生活。</p><p>他舅舅是个公务员，住在长安城。窦乂先通过卖鞋、卖树等生意赚了一些钱，后来有了80万钱的身家，于是开始向房地产行业进军。</p><p>当时长安西市有一个废弃的化粪池，面积不小，有十几亩，闲置七八年了，一直没人买。窦乂把它买了下来，雇人填平，在上面盖了20间店铺，租给波斯胡人做生意，平均每天都收上来几千钱的房租。</p><p>再后来，窦乂听说当朝太尉李晟喜欢打马球，于是斥资70万钱买下一块地，又花30万钱把这块地建成一片马球场，送给了李晟。</p><p>李晟很高兴，从此跟窦乂结成死党，有求必应。有这种靠山保驾护航，窦乂发得更快了，不到40岁就成了长安首富，人称“窦半城”。</p><p>除了像窦乂这样的开发商，古代的业余开发商还有一些是公务员、退休干部等，甚至官府自己就是开发商。 </p><p>比如在北宋，中央政府下面就有个专门搞开发的机构，叫做“修完京城所”。这个机构本来只能是修筑城墙和宫殿，后来城墙修得差不多了，宫殿也盖得够豪华了，这个机构就开始转型，开始给中央财政搞创收。</p><p>怎么搞创收呢？修完京城所向朝廷请示，划拨给他们大片地皮，他们在上面盖住宅盖店铺，盖好了，有的卖给老百姓，有的赁给老百姓，给国库做了很大贡献。</p><p>古代是没有专业的开发商的。做开发商最需要的是钱。买地、买建材、雇人、摆平关系，哪个环节都得花钱。尤其买地，流动资金不能少，钱不够，就得找同行拆借，或者找银行贷款。</p><p>古代没有银行，但有钱庄，可是钱庄规模一般很小，即使有一些大型的全国连锁的钱庄，他们也不做开发商的生意，都把钱借给别的老板了。</p><p>史料上有这样两个办理房地产抵押贷款的例子，一个是南北朝时候的梁朝郡王萧宏，让人家拿着房契去贷款，一张房契最多只贷给几千钱；还有一个是明朝嘉庆年间山阴县的一个富户，名叫求仲，最多的一次才贷给15000文。这点儿钱别说搞开发，吃一顿大餐都不够。<br>直到民国时期，外国银行纷纷到中国开展业务，开发商们才能贷到大笔的贷款。所以中国的职业开发商直到民国才出现。 </p><p>古代开发商如果大量囤地得挨板子</p><p>以唐朝为例。唐玄宗在位时，土地政策里有这么一条：“应给园宅地者，良口三口以下给一亩，每三口加一亩，贱口五口给一亩，每五口加一亩，……诸买地者不得过本制。”意思就是说，政府给老百姓划拨宅基地，划拨的宅基地大小取决于家庭等级和家庭人口，如果是平民家庭，每三口人给一亩宅基；如果是贱民家庭，每五口人给一亩宅基。另外老百姓也可以购买宅基，但是购买的面积有限，不能超过政府规定的指标。</p><p>政府规定的指标是多少呢？平民家庭买地，每三口人，最多只能买一亩宅基；如果是贱民家庭买地，每五口人，才能买一亩宅基。</p><p>在唐朝，商人也属于贱民，再有钱的商人也是贱民，贱民老板去买地，即使是上百口人的大家庭，最多也只能购买20亩地，用这20亩地搞开发，一两年就倒腾光了。而如果超标大量买地会怎么样呢？</p><p>唐朝法律规定：“诸占田过限者，一亩笞十。”意思是买地超过指标的，得挨板子，每超出一亩指标，挨10大板。</p><p>虽然古代开发商没有现如今的开发商这么“牛”，环境和政策对他们都不太有利，但是在拆迁问题上，始终还是开发商们占优势。就比如窦乂，他就知道要搞房地产，首先得朝上有人，于是傍上了当朝太尉。</p><p>古代拆迁过程更为暴力，因为普天之下，莫非王土，国家要用哪里就用哪里。</p><p>当然，在古代，也不乏一些民主的君主。例如北宋元丰六年(1083年)，开封外城向外拓展，规划中的新修城墙要占用120户居民的住宅，宋神宗让开封府制定拆迁补偿计划，开封府写报告说，总共需要补偿款两万零六百贯，平均每户至少能拿到补偿款171贯。</p><h2 id="契税的历史"><a href="#契税的历史" class="headerlink" title="契税的历史"></a>契税的历史</h2><p>关于契税、物业税或者房产税，其实也不是现在的创造或者纯粹的拿来主义。</p><p>早在东晋时期，就开始收契税，当时叫“散估”，这也是中国第一个有据可查的契税。其后，几乎所有朝代都有契税。</p><p>唐初魏征等人写出了房产税的实质：“其实利在剥削也”——当时“剥削”没有现今这么贬义，与“增加财政收入”是一个意思。</p><p>从税率上看，东晋税率为4%，隋唐税率是5%，宋代4%，元明清三朝基本是3%。我们现在的契税大户型也是3%。</p><p>万历三十三年，利玛窦在北京宣武门附近买了处房子，他在意大利、葡萄牙、印度都呆过，那些地方并没有“契税”这一说，所以他也没有去有关部门办理手续。</p><p>《大明律》规定：“凡典买田宅不税契者，笞五十，仍追田宅一半价钱入官。”好在利玛窦同志上面有人，托了户部官吏，最后交了一笔可观的滞纳金了事。 </p><p>相比之下，“物业税”这税种兴起较晚，而且断断续续。公元783年，唐德宗向长安城内拥有房产的市民开征物业税，叫作“间架税”，乃是按照房屋的等级和间架计税，上等房屋每年每间缴纳两千文，中等房屋一千，下等房屋五百。</p><p>结果民怨载道，当年深秋五万军兵哗变，口号就是“不税汝间架”。迫于压力，784年唐德宗废止了这个税种，也就是说，中国第一个正规的物业税仅仅活跃了半年就夭折了。</p><p>到了五代十国，梁唐晋汉周的每一代帝王都曾征收物业税，不过鉴于“间架税”惹过乱子，改叫“屋税”。</p><p>北宋物业税不是常设税种。南宋由于军费困难，每年两次向城乡居民征收屋税。元代，不叫间架税或屋税了，改叫“产钱”，按地基面积征稻米若干或折成钱若干。明朝，物业税不常设，江浙地区小范围征收过一段，叫“房廊钱”。清代，物业税也不常设，往往临时征收，比如1676年由于对吴三桂用兵，朝廷财政紧张，康熙下诏“税天下市房”，规定“不论内房多寡，惟计门面间架，每间税银二钱，一年即止。”算下来，是只对门面房征税，二钱税额相当于两斗大米或七斤白糖的价钱，不多。</p><p>总而言之，无论是间架税、屋税、地基钱、产钱、房捐，都是不折不扣的物业税。只不过，它们与国际上通行的物业税是不同的——不是为了调节需求，而是单纯地敛财。 </p><p>然而物业税在中国并不能成为常设税种，因为这个税是纯粹的苛捐杂税，税又比较重，很容易激化矛盾，直接结果是百姓吃不起饭，太容易导致大规模的农民运动，所以很难持续征收。</p><h2 id="廉租房的历史"><a href="#廉租房的历史" class="headerlink" title="廉租房的历史"></a>廉租房的历史</h2><p>言及公房和廉租房系统，最是宋朝搞得好。</p><p>宋朝原则上不分房，京官无论大小，一律租房居住，宰相那样的高干都是如此。偶尔有“赐第”，只照顾部级领导和有军功的将军。算起来大家的住房自有率不高。</p><p>南宋初年，大量流亡人口涌进杭州，三十平方公里的杭州城一度住了一百万人口，人口密度接近上海浦西。</p><p>因人多地少房价高，居民普遍租住公房。除了大规模公房出租，宋朝还有住房救济体制，一是灾年对租住公房的市民减免房租；二是政府建房（福田院、居养院）免费安置流民和赤贫民众；三是修建比公房条件要差的简易房，但是租金更低，堪称“廉租房”。此外，宋朝还有安济坊——慈善医疗，还有漏泽园——安葬无人认领的尸身，比较有人性。 </p><p>如果是公务员的话，生在元代也还不错。建国开始，就给半数京官和所有地方官分了房，叫“系官房舍”。一般分不到的市民以自主建房为主导，但是盖房不用买地，政府批给一块官地，然后每月交一次租金，时称“地基钱。” </p><p>满人刚进北京那会儿，也给领导们分房子。一品官二十间，二品官十五间，三品官十二间，四品官十间，五品官七间，六、七品官四间，八品官三间，不入流小军官每人两间。按照每间十五平方米估算，从一品官的三百平方米、到小军官的三十平方米不等。 </p><p>廉租房主要由寺观经营。土地由政府划拨，建房资金由民众捐献，房产维护可以从香火钱里冲销，僧尼道士理论上讲不以盈利为目的，再加上信仰需要，正适合执掌这项半慈善业务。大都市的庙宇常有上千间客房，供应试的学生、出门的商旅和遭了天灾的百姓临时居住。</p><p>《西厢记》里张生和崔莺莺在山西停留一整月，在那永济县普救寺里，莺莺住西厢，张生住东厢，该故事充分说明：在廉租房里也可能发生爱情。</p><p>到了明清两代，又多出个廉租房的来源，便是会馆。在这异乡人建立的聚会场所里，客房租金相当便宜。顺治十八年建于北京的漳州会馆，福建人来租住，只象征性地收取租金：每月三文钱！ </p><h2 id="历史上买房最好的朝代"><a href="#历史上买房最好的朝代" class="headerlink" title="历史上买房最好的朝代"></a>历史上买房最好的朝代</h2><p>历朝历代，哪朝买房最容易呢？</p><p>南北朝最不靠谱，贫富相差极为悬殊，普通居民收入只有几千，房价则是几百万。谢灵运那样的大财阀“左江右湖，南北二山”，房价都被他们给炒上去了。 </p><p>唐朝不用说啊，我们都知道“居长安，大不易”，而且士大夫时兴攀比，为了写诗题名好看，非得有个别墅不行。比如王维有辋川别业，岑参有南溪别业，杜牧有樊川别业，就是白居易本人，后来也在洛阳买了十七亩地，修了个“履道园”。</p><p>宋朝文人叶梦得说：“人未有无产而致富者也。有好便田产，可买则买之……勿计厚值。”这话一再被地主老财们重复。有点闲钱，买房子置地，不惜一切代价。</p><p>明代买房也不是件容易事。《金瓶梅》第五十六回，西门庆的结义兄弟要买房，朋友帮他算了算帐，“一间门面，一间客座，一间床房，一间厨灶——四间房子是少不得的。论着价银，也得三四千多银子”。小户型房子，要三四千两银子。而清河县县令，从七品国家公务员，每年薪水不过三百五十两。就是说，就算县长去买房，如果不贪污的话，需要十年不吃不喝才能攒够房钱。明代楼市虚火上延，与攀比之风分不开。尽管明太祖规定，任何人不得超越等级建房，例如居民门窗不得使用朱红油漆；庶民住房不得超过三间；功臣宅邸两边可以保留五丈空地；军民房屋不许建成五间或九间；寺观庵院不得使用斗拱。但如小说里所说，庶民西门庆“现住着门面五间到底七进的房子”，超标超大发了。</p><p>嘉靖年间，大家纷纷打肿脸充胖子，浙江人的房子必须带客厅了，江西人的房子必须带兽头了，江苏人的房子里必须摆上时尚家具和精美古玩了。明朝中叶，北京的地皮已经涨到每亩纹银两千两，就是折成人民币也有好几十万。</p><h2 id="未来房地产市场的发展"><a href="#未来房地产市场的发展" class="headerlink" title="未来房地产市场的发展"></a>未来房地产市场的发展</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>楼主旅行结束呢？</p><p>将来房租市场会如何演化？</p><p>房租涨的太多，如果大多数租客的收入承担不起该如何？</p><p>例如租客的平均工资4000元&#x2F;月，你让他和别人合租一个小两室要6000元<br>他们承担不起恐怕就只能离开这个城市了</p><p><strong>kkndme：</strong></p><p>公租房具有平准作用，zf要敛财，不能定价太低，但也不会高的离谱。有了这个参照物，个人普通房出租应该保持在比公租房稍高水平，当然位置好的高端房精装房也可能租出天价。</p><p>中国的房价在未来将成为多数群众遥不可及的梦想，也可以说大多数人都不再关心商品房的房价涨跌。</p><p>未来，租房将成为常态，所以房子的位置环境装修的档次不同，房租的差距将会非常明显。但好房子一定只有中等收入以上家庭才租得起。</p><p>而买房子是富人阶层的事，中等收入家庭想都不敢想。</p><p><strong>中年不惑吗：</strong></p><p>呵呵，将来，只要中等收入的家庭2个月的收入能买1平米，他们也会买房子的</p><p>难道将来的房价要涨到中等收入家庭半年甚至更长的时间才能买1平米？</p><p><strong>kkndme：</strong></p><p>除了房价高，贷款也没那么容易。而且除了房子，各方面的花销都会涨得离谱，这是太平盛世后期的普遍规律。</p><p>关键还在于体制外的中产，都是逆水行舟，一旦不能前进，就可能沦为赤贫。</p></blockquote><h2 id="房产到期"><a href="#房产到期" class="headerlink" title="房产到期"></a>房产到期</h2><blockquote><p><strong>不明真相的草民：</strong></p><p>向LZ请教</p><p>商品房的土地证年限有多重要？</p><p>现在一个二线城市的开发区，中心地段很多小区房子倒是新盖的，但地是90年代初拿的，有40年、50年的，还有30年20年的，大部分房子的土地证从现在算起只有10几年20几年，有的房子土地证已经到期了，但由于位置较好所以房价一点不便宜。按KFS的说法，土地证到期将来再续就是了，没有大的影响。</p><p>LZ给分析一下，这样房子将来的风险在哪？如果买来自住又如何？</p><p>谢谢！</p><p><strong>kkndme：</strong></p><p>其实有无土地证都无所谓，无论有没有土地证，最大的风险都在dfzf，人治社会法律文件其实就是一张纸，关键还是zf做得不要太过份。</p><p>即使你证件齐全zf想拆一定会拆，即使没有土地证拆的时候也会同样补偿。</p><p>这个东西实在没多大意义。</p><p><strong>不明真相的草民：</strong></p><p>感谢LZ答复。都是新建的高层，应该不会轻易拆迁，这么说自住还好。但如果将来要出手是否就存在困难？？</p><p>期望LZ继续指明。</p><p>Lz似乎没有看到这个问题，再次感谢Lz，望答复。</p><p><strong>kkndme：</strong></p><p>出手不存在困难。二手房交易国家不会对土地证进行严格限制，关键还是房产证。</p></blockquote><h2 id="买学区房问题"><a href="#买学区房问题" class="headerlink" title="买学区房问题"></a>买学区房问题</h2><blockquote><p><strong>开洋木瓜：</strong></p><p>楼主，有个问题想咨询一下。</p><p>家在南京，郊区有一套自住房，130平，市值大概150万左右。市中心有一套小公房，居住权，目前空置（刚分到的，还没有装修，而且单位也禁止对外出租）。现在宝宝一岁，想给宝宝买个学区房，很多名校都要求提前三年落户，所以必须要在2年内买房。一线的学区房单价在2万2-2万6之间。一线小学的分校学区房在1万5-2万之间。我想买的是一个名小的分校，近几年的小升初成绩都非常不错，可以进入南京前三名。</p><p>我想买的一个房子位于这个小学的学区，是拆迁安置房，97年的房子，小区环境比较杂乱，没有物管，停车也不方便。但是周围配套都非常齐全，菜场超市医院都很近，上学也不用过马路。今年年初，2月份的时候我本来在这个小区买了一套，但因为房价上涨房主违约。当时买的房价是12500，现在看中一套，房主要17000，挂了很久没卖掉，我出15000，可能有机会成交。</p><p>这个隔壁有个新小区，物管环境都很好，但价格也上到2万一平了，如果要在这个新小区买房，我们家里的钱就不够了，如果要卖掉现有的房子去买，老公也不愿意。</p><p>还有个问题是，房主要求净得价，12月的时候满五年，就不用付营业税。如果现在交易过户也可以，但要多付几万块。如果算上这几万的税，房价就差不多一万七一平了，我也不愿意现在过户多付这个钱。如果现在签约等12月再交易过户会不会有风险？另外现在是否是出手时机？请楼主赐教。</p><p><strong>kkndme：</strong></p><p>学区房即使在调控最严厉的时期也几乎不可能下跌。但是在上涨期就很难买到，因为房东会跳价。</p><p>12月过户有一定风险，如果到12月时，房价上涨比较厉害，房东有可能违约。</p><p>制约房东违约的方法就是签较高的违约金。</p></blockquote><h2 id="历史的结局"><a href="#历史的结局" class="headerlink" title="历史的结局"></a>历史的结局</h2><blockquote><p><strong>Peter_Takeshi：</strong></p><p>LZ写的不错，有些意见不敢苟同。<br>LZ既然熟读历史，又在安抚众人去接受被统治的命运，那能否告知最后的结局呢？<br>是否跟前几十个朝代一样？呵呵~<br>人性几千年从未根本改变，所以即使过程不同，结局仍旧是一样。<br>谁上台都改变不了这一切。</p><p><strong>kkndme：</strong></p><p>历史上的结局三条路：<br>和平演变——在中国好像没发生过，今后也不可能，没有土壤<br>大革命——哪次也少不了<br>外来入侵——这个也比较靠谱</p><p><strong>facetowall：</strong></p><p>对lz的深厚的历史功底十分佩服。lz说改朝换代的方式有三种：1.和平演变；2.农民qiyi；3.外族入侵。我觉得前苏联的解体看似像是和平演变吧，第2、3条好像不符合。lz说zhongguo无和平演变的土壤，但是前苏联好像也没有啊。这该如何解释呢？</p><p><strong>kkndme：</strong></p><p>苏联的文化背景与中国完全不同。我国是自秦以来进入帝国时代，是一个上千年大一统的国家。<br>而苏联是在近代革命后才出现的。俄罗斯的主要人种是斯拉夫人，在日耳曼民族眼中是奴隶的意思，人种低劣。中世纪叫做罗斯地区，由基辅公国、莫斯科公国、立陶宛公国等多个公国割据，在元代一直附属于拔都建立的金帐汗国。罗斯诸国在西方中世纪非常弱小，直到波兰立陶宛联军大破德意志的条顿骑士团后，才逐渐强大。俄罗斯于1721年彼得大帝时期才开始崛起，19世纪末才成为帝国主义国家，根本就没有大一统的土壤存在，这也就是苏联能够和平演变，而中国不行的原因。</p></blockquote><h2 id="人口普查"><a href="#人口普查" class="headerlink" title="人口普查"></a>人口普查</h2><blockquote><p><strong>平静的房奴：</strong></p><p>看来楼主今天比较空闲，一口气发了这么多帖子。</p><p>有个问题想青椒哈楼主，我在武汉，最近武汉在全免清理个人和家庭住房信息，晚上调查人员还上门登记、记录，请问这是何意？是否在为出台房产税做准备。</p><p><strong>kkndme：</strong></p><p>人口普查。不但武汉，连穷山沟里也在忙这个，穷乡僻壤的支书天天忙得不亦乐乎。这是第六次人口普查，前面查过五次了</p></blockquote><h2 id="昆山房价分析与买房"><a href="#昆山房价分析与买房" class="headerlink" title="昆山房价分析与买房"></a>昆山房价分析与买房</h2><blockquote><p><strong>買房難：</strong></p><p>樓主﹐麻煩你分析一下昆山的房價吧﹐先謝謝﹗﹗</p><p>昆山是一個縣級市﹐原先是屬于蘇州的﹐離上海很近﹐動車只要20分鐘﹐現在高鐵也開通了﹐原先房價還算便宜的﹐現在連鎮上也貴到五千多六千了﹐市中心最便宜的也要七千多八千﹐09年10月的時候一下子漲了很多﹐原先我看好的一套二手房32萬﹐現在要50多萬﹐太奇怪了</p><p><strong>kkndme：</strong></p><p>昆山不能理解为县级市，要理解为上海的卫星城。相当于北京的燕郊。所以房子八千多一点也不奇怪。</p><p><strong>買房難：</strong></p><p>謝謝樓主回復﹗昆山市中心的房子大一點的開發商開發的如世茂在一萬左右一平﹐這個價位算不算高啊﹖</p><p>買房子要在市中心好點呢﹐還是城東靠近上海方向好些﹖</p><p>昆山很小的﹐就那么几個鎮﹐現在火車站﹐汽車站﹐高鐵﹐人才市場都在城南﹐另外除市中心的玉山鎮外﹐其它的都是工廠很多﹐污染還是多。</p><p><strong>kkndme：</strong></p><p>买在哪里合适，你要看zf规划，跟着zf规划走。比如房山，zf打造的是长阳而不是老的镇中心，所以买房就应当买在长阳。道理是一样的。</p></blockquote><h2 id="为什么现在租售比这么低-amp-同小区买一套大还是两套小"><a href="#为什么现在租售比这么低-amp-同小区买一套大还是两套小" class="headerlink" title="为什么现在租售比这么低 &amp; 同小区买一套大还是两套小"></a>为什么现在租售比这么低 &amp; 同小区买一套大还是两套小</h2><blockquote><p><strong>我爱的飞飞：</strong></p><p>对待房子，我的看法是这样的，50-60年代的人，兄弟姐妹至少5-10个，2004-2020年之间正50、60、70、80、90年代共存的时代，人口达到了爆发阶段，现在好多小年轻70、80代人因为买不起房结不起婚，甚至晚婚索性不育，等50.60后在未来20-30年离世之后，将会有大量的房子空出来。而80后的子女2000后，人口根本不足以养活上一辈。</p><p>我在成都，我的父母是体制内的，我是体制外的80后，刚结婚，老公是体制内的。原家里有一套单位的集资建房，只有小产权，在二线城市的一环内，98年的房子，因为担心迟早有一天拆迁以后没有房子住，小产权也不会赔多好的地段或者得到较好的补偿，再加上以房养房的心理作祟，以及我参加工作以后想从家里独立出来，于是父母在08年底四川地震以后全国大降价赶上好时光在三环外买了一套140的房子，那会儿才买成2900，今年交房以后装修到一半，就有人以双倍价格想买入，父母不卖，留着养老。一年不到翻了一番起来，我结婚以后，也和老公一起在一环附近购入一套小户，8千多。老公家在外省某市有2套，这样算下来，我门要是生一个孩子，以后这孩子手里就有我父母在成都的2套加上老家的1套，我和我老公的1套，孩子爷爷奶奶的2套，一共6套，您说等我父母和老公父母都去世以后，房子嗖的一下就空出来了不少。所以我觉得80后到了四十岁左右肯定都能住上房子，那个时候房子也不再值钱，不过话又说回来，其实我的父母也是年轻的时候住在单位的公房，三十五近四十岁才有了第一套集资建房，而他们的第二套和第三套相对比较快了。所以我现在觉得年轻人还是应该多奋斗吧。但是我真的不清楚，到了房子不缺的时候，那个时候又会炒什么。</p><p>虽然我是土著，也不缺房子，但是压力也不小，特别是还贷，连车也没敢买。有时候我跟LG也想，为啥我们买的房子首付了二十几万，装修十万，我们每个月还还着2500的按揭款，租房客2000就租走了，那不是我们垫着钱给别人提供福利么？向楼主求解。</p><p><strong>kkndme：</strong></p><p>打个比方，假设你打算在某地开个游乐园，竞拍一块地，经过计算当时的门票定价10元一张，根据人流测算，你认为出500万投标这块地，5年可以回本，于是你出了500万，但是别人出到了1000万，你认为1000万要10年回本，风险太大了，于是你放弃了。你冷笑着认为那个傻子一定会赔钱。</p><p>结果过了2年，票价涨到100元一张了，人流量一点也没减小。人家5年就回本了，以后赚的盆满钵满。可是这个生意你却因为太能算计没有做成。</p><p>为什么房价租售比低？</p><p>其中原因之一是现在的房价预期了以后的租金。</p><p>另一个也是最重要的原因就是：现在的房价不够高，说明了很大一部分普通家庭都有希望买得起房，所以宁肯省吃俭用住合租房，为了攒首付。但当房价高到普通家庭不敢问津的时候，这部分中等收入的合租家庭就会放弃买房转而追求租住有一定舒适度的房屋，房屋租金就会上涨到合理的程度。</p><p><strong>welldayzwb：</strong></p><p>楼主在线啊，真好，这个道理大概也明白，不过现在出于”活雷锋”阶段，心里还是很不舒服<br>去年底在北五环投资的一套大一居，首付加税款超过60％，贷了30年的公积金，现在房租还是不顶月供，而且空租期很长<br>很怀疑自己的投资决策，好象不是一个很明智的选择，纠结中</p><p><strong>kkndme：</strong></p><p>当房价快速脱离你的成本区，你的心理就好受了。</p><p><strong>welldayzwb：</strong></p><p>再多问一句，有机会一步到位买个满意的大房好(也是老房，得房率高，三居)，还是买两套小房，一套凑合着住，一套放租好？</p><p>当然两套小房的总额比一套还是要多不少，帮忙分析一下，短期和长期来看的情况？谢谢！</p><p><strong>kkndme：</strong></p><p>其实买两套同一小区的房子是最好的，投资自住兼顾，可进可退。如果家里有老人，和老人分别居住，又在同一小区，照顾起来很方便。</p></blockquote><h2 id="买房难之回不去的乡-amp-拉美人过得比你想象的好"><a href="#买房难之回不去的乡-amp-拉美人过得比你想象的好" class="headerlink" title="买房难之回不去的乡 &amp; 拉美人过得比你想象的好"></a>买房难之回不去的乡 &amp; 拉美人过得比你想象的好</h2><blockquote><p><strong>九五二七八：</strong></p><p>楼主说的以后大部分人买不了房的论题<br>中美在这个方面的差距 怎么这么大呢<br>现在产业转移 一部分人就业就有回乡的趋势<br>今后再有一波转移 会不会再离故乡近一些<br>这样 分散置业 购买难度会不会下降</p><p><strong>kkndme：</strong></p><p>中美体制不同、文化不同、人口不同。一辆在美国2万美金的汽车，国内要卖几十万人民币。一件made in china的服装美国卖20美金，国内卖900人民币。</p><p>不管一线城市、三三线城市都是人满为患的，从一线城市逃离的也会驻扎在二三线城市，绝没有可能大中型城市向小城市回流。</p><p>返乡潮指的是家有自留地的农民工，如果工资待遇差不多，与其到沿海地区漂泊不如回乡打工或者种地。比如贵州镇远的油漆工一天工资是150，而在珠三角打工一天工资还不到150，这也是大量农民工返乡的原因。</p><p><strong>九五二七八：</strong></p><p>最难的怕是现在三四流的大学生和跟着打工父母生活在城里的二代<br>失去了农村生活本领<br>在城里也无法立足<br>楼主<br>难道拉美化真的不远了</p><p><strong>kkndme：</strong></p><p>很多人都丑化拉美，但是拉美的生活水平要高过我国。不说远超中国的巴西，即使是法属及荷属圭亚那(苏里南）这样的小国，人民的生活也很富足。</p><p>前几年有个援助项目去苏里南等拉美国家，去之前所有的人给我灌输的都是拉美国家如何贫困。但事实上，这些国家与中国完全不同，国穷民富，藏富于民，与中国正好是相反的，只要勤快点的家庭都还比较富裕。当然不排除也有很多穷人（美国也有很多穷人），穷人一般以当地的黑人为主，好吃懒做，整日无所事事。</p><p>这些国家的人民不如中国人勤奋，从不攒钱，只图眼前享受，我想主要原因还是由于币值不稳定，通货膨胀比较严重，所以没有人愿意攒钱。在拉美国家是无法炒房地产的，比如苏里南平均25平方公里有一口人，真的是地广人稀。所以才保留了世界上最高的森林覆盖率。</p><p>拉美人的懒惰会让中国人瞠目结舌，当地的蔬菜价格昂贵，尽管有大片肥沃的土地，当地却没有人愿意耕种，很多去苏里南种植蔬菜的中国人为此发了大财。</p><p>而相反中国人可以说是全世界最勤劳的民族，但是大量勤劳的中国人却过着低水准的生活。这与中国的国富民穷，藏富于国，与民争利的政策是分不开的。</p><p>拉美国家尽管有这样那样的问题，但是确实是法制国家与民主国家，私人财产神圣不可侵犯，这是与中国完全没有可比性的。</p><p><strong>九五二七八：</strong></p><p>一般对“拉美化”的定义是这个吧：贫富悬殊扩大、腐败严重、国有企业效率低下、社会治安恶化、城市人口过多、地下经济泛滥、对外资依赖性强、金融危机频繁和政局不稳定，等等</p><p>没去过拉美 不知道真实的拉美</p><p><strong>kkndme：</strong></p><p>看来拉美妖魔化后，深入人心了。好比在越南旅游，越南人自己说越南官僚太腐败，我笑了，能有中国腐败？</p><p>拉美的官僚机构，国企、医院、警察我都见识过。</p><p>说到官员的官僚，相比中国我真的觉得那里的官员很亲切。我曾经以一个游客的身份和苏里南的司法部长一起在街边小店喝咖啡。以一个陌生的外国游客身份在财政部长家里做客，逗他家的几个黑小孩玩。</p><p>说到治安，我在街边咖啡店坐了一下午，每二十分钟一辆巡逻车从我身边经过。里约热内卢的治安绝对不会差过广州。</p><p>国有企业效率低下恐怕是全世界的通病，况且拉美根本没有可能赚钱的行业全部由国企垄断。</p><p>政局不稳要看怎么理解，拉美国家是相对民主的国家，国家元首倒是常常因为民众的不满而换届（排除少数经常政变的军政国家）。但人民并没有感觉到不幸福。</p><p>拉美国家的经济基本被美国所控制，所以才会对外资依赖严重和金融危机频繁。作为一个主权国家我们看到的是国家财政贫困，但是作为拉美地区的中下层人民群众，生活水平和幸福感是要高于国内的中下层群众的。</p></blockquote><h2 id="租房的苦"><a href="#租房的苦" class="headerlink" title="租房的苦"></a>租房的苦</h2><p>说到租房举个活生生的例子。</p><p>我有朋友是个房产的死空头，一直租住着北京一套两居室的老公房，租金不高1000多点，所以没什么负担，对买方族恨不能理解。结果今年他租住的那片老公房要拆迁，限期20天内搬家走人，结果终于理解了找房子的辛苦，而且随便租一套两居室也找不到2500以下的了。</p><p>真是心态决定命运。</p><h2 id="北京西三旗"><a href="#北京西三旗" class="headerlink" title="北京西三旗"></a>北京西三旗</h2><blockquote><p><strong>bjwxw：</strong></p><p>楼主在线啊，今天几乎花了大半天的时间从头至尾的看了楼主的帖子，分析和解释的真的很实在到位，也许我了解的不是很多，但是确实觉得现实好多都是这样的，麻烦我现在有个问题，我住在西三旗，我租住的这个小区去年的这个时候价格是60-70左右，我失去了机会，可是今年这些房子基本都是120-140万之间了，我现在是在忍不住，也憋不住了，因为我是刚需，虽然心里是万分的懊丧和后悔，但是事情还的做，房子还是的买，可是我很担忧，我花140万买只隔一年就升值一倍多的房子，后果会是什么，我真的怕等了好久，可是等我出手了，房子真的跌了，尽管不会跌很多，但是把我的首付跌光那也是件很可怕的事，毕竟辛苦的攒了这么多年的钱，我是实实在在像楼主说的那样的底层奋斗着的接近中年的刚需外地人，挣钱太辛苦了，所以很害怕，楼主，我现在也很急，老婆看好了一套140万的房子，要我去买，我也知道她也很无奈了，可是我心里这关好难过啊，想听听你的指点，急盼回音</p><p><strong>kkndme：</strong></p><p>西三旗的房子与不远的立水桥相比，涨速是相当慢的，尽管离市区更近当房价跟回龙观相仿，并没有拉开差距。随着8号线的即将开通，8号线地铁站中央部位保障房项目的启动，西三旗房价上升空间还不小。</p><p>西三旗附近最值得购买的小区是枫丹丽舍，因为低密度将来必定稀缺，但是目前价格也高过其他几个楼盘，甚至高过新盘富力桃园。配套最成熟的小区当属育新小区。象硅谷先锋、森林大第也都比较好住。西三旗这片地区属于难得的价值洼地，值得购买。</p><p><strong>bjwxw：</strong></p><p>多谢楼主，看来您真的对西三旗了解的太透彻了，我真的很幸运，我就直接跟您说了吧，我说的房子是龙乡小区，您肯定也很了解，这个是个老小区，房子已经超过了10年，优点就是交通好，周边医院，学校，购物都极其的方便，因为钱有限的原因，只能买这里的，情况就这样，您能给我多说几句吗？多谢</p><p>一着急字都打错了，不好意思</p><p><strong>kkndme：</strong></p><p>龙乡小区的房价在西三旗片区相对较低，因为房子是90年代的，但是周围配套相当齐全，去超市购物也很方便。如果你在上地上班也算比较近，唯一的遗憾就是房子旧了点，户型与2000年后的次新小区相比，有点不尽如人意。</p><p><strong>bjwxw：</strong></p><p>确实是这样，今天通过从头看到尾您的帖子，基本心中已经有了概念，买吧，尽管我从这个小区的70万的房子如今花140万去买这个心理关很难过去，但是还是过吧，既然已经这样了，认命吧，不害羞的问一句，房子价格已经16000了，您说这个地段在将来是会升些，还是会跌一些，呵呵，实在不好意思，添麻烦了</p><p><strong>kkndme：</strong></p><p>这个地区的房价，两年内是可以看到25000的。</p><p><strong>喜欢8号线：</strong></p><p>楼主看好西三旗地区房价，本人深有同感。<br>西三旗地区的焦点不在京藏高速路口，也不在林翠路路口，而在西三旗东路。也就是地铁8号线西三旗站附近。<br>现在这附近已经有宾馆、饭店、百汇商品市场、中小学、3甲医院、银行。<br>到2012年，8号线开通，百汇市场新增电影院，龙旗广场新增写字楼2座和3星级酒店一座，<br>随着北新建材厂的搬迁，原厂区还会有更多的新楼拔地而起，西三旗东路将南延、拓宽至永泰。整个地区的房价将随着新楼盘的不断推出而节节高升。</p><p><strong>kkndme：</strong></p><p>西三旗地区一直相对滞涨主要还是缺乏大品牌开发商入住，没有高端楼盘的带动，涨幅偏低。但也正因如此，才形成了一块价值洼地，以后才有更大的上涨空间。</p><p><strong>跳坑的青蛙：</strong></p><p>没想到楼主对西三旗地区如此熟悉~<br>想问问楼主对于上地附近二手房的看法，如当代城市家园这样的地方，有没有升值潜力？<br>觉得这边交通还是有很大问题~</p><p><strong>kkndme：</strong></p><p>上地区域的房产在2008年之前，涨幅较快。但在2008年以后由于上地区域的产业以民营iT为主，属于充分竞争，利润下滑较快的产业，区域经济的发展前景远不如望京，所以上涨空间受限，涨幅趋缓。<br>区域发展是房价升值的动力，个人不太看好上地区域。</p><p><strong>汝爱之罪：</strong></p><p>对上地一点也不了解，不过今后北京的私企郊区化应该是趋势，好多公司因为成本问题已经开始向密云等地搬家。上地的价格若被炒太高，也难逃此运。</p><p>也许zf会注意到这个发展趋势，引导郊区，现在大力发展郊区地铁就是为今后的卫星城铺路吧。不过能不能成功，是另一回事。里面牵涉利益太多，比如海淀，主导还是高科技产业，如果全都搬家，地区zf就头大了。上地区域，可是海淀政府大力度发展的重点区域。</p><p><strong>kkndme：</strong></p><p>你说的很有道理，现在海淀的it产业基本就是以处于链条底端的制造业，毫无科技科研，急需产业升级，才能得到持续的发展。象联想这样的it公司完全沦为了90年代家电厂商的境遇，毫无未来。</p></blockquote><h2 id="买房争取一步到位"><a href="#买房争取一步到位" class="headerlink" title="买房争取一步到位"></a>买房争取一步到位</h2><blockquote><p><strong>hohowell：</strong></p><p>楼主，诚心请教下，从开贴开始就一直在潜水关注，终于坚定了买房的决心</p><p>现在在犹豫，一是买个80平米的小户型，开发商一般，房型尚可，这样贷款比较少，基本不影响供车，旅游和以后小孩的开销，不过考虑5到8年左右，这个房子就不能满足居住要求了，回头换，又是一大笔钱，而且城区内的好小区也会越来越小，另外一个就是保利的大户型，开发商物业都靠得住，基本上短期可以不用换，不过贷款至少贷100多万，短期内还会要小孩，压力会比较大，基本手里每个月都没有闲钱了，很容易回到赤贫线，一直犹豫不决，诚心请教楼主解惑，我在南京，一个一线以下二线以上的鬼地方，两处房子都靠地铁，周边商业中心配套齐全，谢谢！</p><p><strong>kkndme：</strong></p><p>买房子如果有能力还是要争取一步到位。将来改善，除非个人有较大的发展，否则将很难很难。而且买楼首选好位置，大开发商，大盘，升值空间才大。</p><p><strong>welldayzwb：</strong></p><p>看来楼主分析说购房应该一步到位，我就犯了一个错误，用投资的眼光来选择自住房，后来买的两居室比同小区的三居室性价比高很多，但是居住环境不好，临一条小街，所以现在住起来不是很爽，现在调控着价格先不说了，光是现在限制换房的一些条条框框感觉再置换就很麻烦<br>另外一套买的外面一点，小区环境非常棒，不过当时是被环境给迷惑了，放租的房子管那么多环境做什么，感觉两套房子操作反了<br>纠结中啊纠结中，现在唯一能安慰自己的就是，买上房子总比没买强，如果去年年底再犹豫一下或是赌气的话，那就真是悲剧了，一个好三居得活活等成质量差些的两居了</p></blockquote><h2 id="收入稳定的家庭如何买房"><a href="#收入稳定的家庭如何买房" class="headerlink" title="收入稳定的家庭如何买房"></a>收入稳定的家庭如何买房</h2><blockquote><p><strong>黑眼圈钱：</strong></p><p>请教楼主，买房子的事情，比较纠结。</p><p>1）夫妻两人均在西部某高校任职，一个教师，一个行政人员，年龄都不小了，37和35，两人每月总收入在8000-10000，1年算10万收入，应该会多一点。</p><ol start="2"><li>一个女儿，才两个多月。</li><li>3）每年给双方父母1万，双方父母均已60出头，一方父母城里的有退休金及医保。另一方父母农村的，得为他们准备点钱。</li></ol><p>4）目前租住单位两室一厅房，就在学校住宅小区内，除了小点，别的都好，房租100。</p><p>5）公积金两人很少，约1000元每月，未来1-2年内会有购福利房机会，估计90多平方的旧三室一厅（约需 10万元），可能有120平米的房子，但需要排队看单位建房情况（2000每平米）。</p><p>6）两人都有单位医疗保险。</p><p>7）孩子可以上学校的幼儿园和小学、初中，就在150米范围内。</p><p>8）对于车没有什么想法，每天步行上班用不到车代步。不过会买辆10万左右的。</p><p>9）现在没有任何投资和理财。银行存款1-2年期定期存款50万，这个傻了，已经存2年了，平时光顾着干活。</p><p>有没有必要买个商品房呢，周围的房价从08年的4500涨到现在8500，容积率还非常高，并且楼间距等等不理想，那种房子我不想住的。</p><p>其实在附近买套120平米的房子，首付后也供得起，买房子放那等涨价或者出租？ 不想放弃单位的房子，每天睡到自然醒再去上班还是挺惬意的，送孩子上幼儿园上学也方便。</p><p>买了房子后经济会紧张些，不像现在自由。财务自由也算一种幸福吧，我太太对于房子没什么要求，所以也不给我什么压力。</p><p><strong>kkndme：</strong></p><p>对于工作稳定，收入不错的体制内家庭，基本上的情况就是有闲钱就买房。主要还是由于收入稳定不用担心失业，钱放着只有贬值，不如置业。投资型住房与自住型住房在选择方向上有很大不同。</p><p>举个例子，昆明打造了个螺丝湾，几乎半个昆明做生意的人都聚集在哪里。如果自住没有人愿意选择在那里买房，实在是不好住。但是投资确是最好的选择，因为可以获取较高的租金的收益，将来升值空间也不会小。</p><p>假如在昆明一环附近买一套两居室，月租金一般在1500-1800，而房价在万元左右。而在螺蛳湾附近买一套两居室，月租金都在2000多，而房价在7000多。</p></blockquote><h2 id="北京回龙观"><a href="#北京回龙观" class="headerlink" title="北京回龙观"></a>北京回龙观</h2><blockquote><p><strong>baiyang11112010：</strong></p><p>LZ,你好，我2010年3月在回龙观买一复试房子120平米，户型不是很好，全部下来，161万，我尽量提前还贷，控制在3-5年以内，所以，这房加利息定能控制在170万以内，我想问的是，3-5年我想出手，会不会亏？</p><p><strong>kkndme：</strong></p><p>你的问题太短了，虽然问了几遍，居然没看见。<br>回龙观地区的配套设施齐全，积水潭医院入住将提升该地区的物业价值。随着中关村高新区北延规划的利好，回龙观地区的房价在未来两年内有50%左右的上涨空间。</p><p><strong>baiyang11112010：</strong></p><p>我觉得LZ你的分析思路不错，但是这种涨幅应该不会再有了吧？虽然我今年4月投资了一套，但是，我能回本就行，没敢过分估计，你这样有煽动别人之心啊</p><p><strong>kkndme</strong>：</p><p>首先投资房产不是炒股，不能有炒股的心态。目前说起投资房产是最安全的品种，指的是长线投资，而不是短线投机炒房。短线投机炒房还是因政策的不稳定有较高风险的，一旦资金链断掉，将万劫不复。</p><p>对于4月份，在山雨欲来风满楼的特殊时期，投资一线城市郊区房地产肯定是欠考虑的。</p><p><strong>对于房地产调控，主要针对一线城市，且一线城市在09年行情涨幅过大，郊区楼盘一定会受到调控影响，而资金的运作规律告诉我们，调控抑制住了一线城市的投资资金，一定有相当部分转向二三线房价相对不高的城市，大开发商对二三线城市的入住，将加速城市升级。所以调控征兆的开始，正是布局二三线城市的时机，而不是一线城市。：</strong></p><p>值得安慰的是，回龙观地区并没有遭遇疯狂炒作，表现比较抗跌，即使被套损失也不会大。从未来两三年看，回龙观的区位一定会有50%左右的涨幅，这是不用担心的。</p></blockquote><h2 id="贷款还是全款"><a href="#贷款还是全款" class="headerlink" title="贷款还是全款"></a>贷款还是全款</h2><blockquote><p><strong>jhjdream：</strong></p><p>楼主，请教一下，</p><p>也正是8月初看来楼主的帖子，坚定了我此时买房的决心</p><p>我在3月份卖了一套小房子，8月底买了套大点的，也是学区房，学校在建</p><p>现在考虑一个问题，是全款付清好还是贷款比较好<br>全款付清，欠亲戚10多万，没有还钱压力，年底可还清，但是手头没有余钱<br>贷款的话，手头会有20多万余钱，可以装修，或者等年底再攒点钱，投资其他的<br>所在省会城市房价8000多，偏一点的6000左右。</p><p>装修好出租2500左右，贷款月利息2000左右<br>也就是说我全款还清，一年相当于收益2.4万的利息及3万的租金，房款70万左右，<br>是否值得？还是贷款35万比较合适？</p><p>因为考虑到通货膨胀时期，应该是负债比较划算～～ 谢谢！</p><p><strong>kkndme：</strong></p><p>肯定是贷款划算，这是毋庸置疑的。当然如果你的余钱实在找不到其他投资渠道，也可以一次性付清。如有可能也可以贷款买两套，而不是买一套。<br>70万的总房款月租金达到2500，租售比还是很高的，贷款35万，租金抵月供完全没有问题，说明你所在地区的房价具备较大的上涨空间。</p></blockquote><h2 id="00后的买房需求从何而来"><a href="#00后的买房需求从何而来" class="headerlink" title="00后的买房需求从何而来"></a>00后的买房需求从何而来</h2><blockquote><p><strong>和风中的树叶：</strong></p><p>看了那么多 有点意思</p><p>不过在下有一事想不明白：</p><p>因中国的计划生育政策 往近了说 人口红利会在这几年消失 往远了说 80后基本都是独生子女 父辈在城市里都是有房子的 这些房子作为遗产 按理说 在未来应该使00后没有买房的需求。<br>LZ如何解释在这种情况下在未来房子仍然看涨？</p><p><strong>kkndme：</strong></p><p>前面已经说过了，你往前翻。</p><p><strong>和风中的树叶：</strong></p><p>LZ能不能再贴一次？或者说明一下在第几页？谢谢哈~</p><p><strong>kkndme：</strong></p><p>回去找了一下，居然被删了。<br>大意基本是讲中国经济未来的发展模式，城市升级与拆迁改造的关系，没想到这样也不允许说。实在懒得再长篇大论说一遍。<br>关键的意思就是一方面是富裕阶层对更高端产品，更大面积的追求，一方面是城市升级带来的大规模拆迁改造。下层群众将被挤出城市核心区。许多住房都会被拆迁置换。</p></blockquote><h2 id="意大利的住房模式"><a href="#意大利的住房模式" class="headerlink" title="意大利的住房模式"></a>意大利的住房模式</h2><p>我本人对意大利的住房模式还是比较赞同的。<br>有去过米兰的朋友可能很清楚，米兰城区的房屋居住的大多数是富豪显贵，一旦出了城区，则是大片大片鳞次栉比的公租房供普通工薪族居住。<br>以后的中国有可能学习这个模式，原市中心的居民被拆迁安置到郊区，城区居住的都是达官贵人。郊区将形成拆迁安置房、中产阶级商品房、公租房、廉租房混居的模式。</p><h2 id="中国的学术"><a href="#中国的学术" class="headerlink" title="中国的学术"></a>中国的学术</h2><p>97年我大学毕业的第一任老板就是在龙乡小区买的房，我还到他家送礼。那时从城里骑车到西三旗，花了我将近两个小时。一晃就十几年过去了，真是有很多感慨。</p><blockquote><p><strong>汝爱之罪：</strong></p><p>感觉您是学者型的啊，看您去做田野调查什么的。大学毕业送礼给老板。。。。</p><p>看您点评回龙观的那一段，估计很多人要捶胸顿足的后悔了。回龙观真是个奇迹，从2600涨到15000，让所有人大跌眼镜。</p><p><strong>kkndme：</strong></p><p>送礼也算学者型？晕</p><p><strong>九五二七八：</strong></p><p>他是说本以为你是学者型的 不需要送礼<br>现在看到你说送礼 觉得自己判断失误了 呵呵<br>现在这个时代 学者也需要送礼啊</p><p><strong>汝爱之罪：</strong></p><p>差不多这个意思，呵呵。我一直以为楼主是搞学术的。</p><p>其实吧，虽然大多数学者砖家都成了贬义词，但我觉得在北京这个大环境里，还是有土壤培养一些目光敏锐犀利的人，BBS的P民也需要这样有前瞻性的引导者，因为毕竟不是每个人都强大到能把这些东西娓娓道来，没有积淀，根本悟不出。</p><p><strong>kkndme：</strong></p><p>中国的学者是很难拿出点时间好好搞搞学问的，功利性太强。</p><p>以前跟一伙民族学者到元阳考察，这帮人没呆满两个星期就跑回去了，说是又要评职称了，人不能不在单位。而日本学者已经在元阳与当地人同吃同住了3年，还没有一次回日本。真不知道这帮民族学者研究了两个星期的东西能发表什么样的惊世论文出来。</p></blockquote><h2 id="北京远洋山水"><a href="#北京远洋山水" class="headerlink" title="北京远洋山水"></a>北京远洋山水</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>不知楼主了解远洋山水吗？在西四环外，我舅舅想在那买房，去年一万七没买，今年最高到过三万，现在两万六左右，能买吗？还有升值空间吗？诚心请教。</p><p><strong>kkndme：</strong></p><p>别提了，08年的那次调控，开盘才1万1，这是个让人悔得肠子都青了的楼盘。<br>北京的楼市前景，在未来的两三年，北四环西四环东四环达到5万，北五环西五环外到达3万应该不是什么难事，南面可能相对低一点。远洋山水的位置2万6不能算便宜，但将来只有更贵。</p></blockquote><h2 id="精英的资产"><a href="#精英的资产" class="headerlink" title="精英的资产"></a>精英的资产</h2><p>5万一平的房子对于中国的精英阶层真算不上什么。500、600万一套的房子一次性付清的人群在北京大把的存在着。这是很多工薪阶层一辈子都觉得不可能挣到的财富，但对于另外一些人却可以轻而易举的拿出来。平均工资的概念在中国是完全没有用处的。</p><h2 id="北京三环塔楼"><a href="#北京三环塔楼" class="headerlink" title="北京三环塔楼"></a>北京三环塔楼</h2><blockquote><p><strong>bluesyang2010：</strong></p><p>请问楼主，北京三环内的塔楼，80年代末的房子，以后会有什么走向，现在能出手吗？谢谢</p><p><strong>kkndme：</strong></p><p>三环内都是老公房，干嘛不买个板楼呢。这种房子老到不好住了，迟早还是要换。板楼还可以拆迁，塔楼拆迁就比较困难了。不过今后的北京可能存在一个相当奇怪的现象，一部分高端富裕人群居住在市中心老旧的小区，而令广大住在远郊的中产阶层羡慕不已。</p></blockquote><h2 id="普通人买房的未来"><a href="#普通人买房的未来" class="headerlink" title="普通人买房的未来"></a>普通人买房的未来</h2><blockquote><p><strong>baiyang11112010：</strong></p><p>直白说，我刚毕业一年，完全靠着父母资助，要完全靠自己根本买不起房，我一些同学在北京两人的话年薪也就15万左右吧，现在好歹还能惦念着买房，要是像您所说，“北四环西四环东四环达到5万，北五环西五环外到达3万应该不是什么难事”，那他们根本就没有盼头了，这是很可怕的事啊</p><p><strong>kkndme：</strong></p><p>将来年薪20万的中产阶层一定连北京6环内的房子都买不起。这一天，不会很远。</p></blockquote><h2 id="北京房价超香港"><a href="#北京房价超香港" class="headerlink" title="北京房价超香港"></a>北京房价超香港</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>金岩石说未来五年房价还得翻一翻，北京核心区域得到二十万一平，真会那样吗？请楼主说说</p><p><strong>kkndme：</strong></p><p>北京北四环，东三环，西三环，南二环内区域的房子，价格一定会超过香港。</p><p><strong>tianxiaobing11：</strong></p><p>香港怎么也得几十万一平吧，还是得早买房，早买早心安</p><p><strong>kkndme：</strong></p><p>香港都是按尺算的。富翁住的千尺豪宅相当于我们的大约100平米。现在香港的房价换算成平米大概是十五、六万一平吧。</p></blockquote><h2 id="中国的新闻不可信，精英的有钱是你想象不到的"><a href="#中国的新闻不可信，精英的有钱是你想象不到的" class="headerlink" title="中国的新闻不可信，精英的有钱是你想象不到的"></a>中国的新闻不可信，精英的有钱是你想象不到的</h2><blockquote><p><strong>bluesyang2010：</strong></p><p>搂主分析一下,现在的新闻都说房屋成交量的上升是因为kfs打折才上升的,但这个很不成立,为什么新闻这么懵老百姓.是不是政策上还有可能收得更紧?</p><p><strong>kkndme：</strong></p><p>中国的新闻最不可信，为了抓眼球不惜胡编乱造，不惜前后自相矛盾。我倒觉得这个成交量放大的背后的意义更值得深入研究。</p><p>在二套房首付50%，三套房首付更是严格控制的前提下，成交量大幅提升，中国的货币到底泛滥到何种程度，中国的精英阶层的绝对数量多么庞大，手里多么有钱。中国的贫富差距很可能已经达到了一般人不敢想象的程度。</p><p>这是一个坏的预兆。</p></blockquote><h2 id="40年的商住房没有70年的住宅有投资价值"><a href="#40年的商住房没有70年的住宅有投资价值" class="headerlink" title="40年的商住房没有70年的住宅有投资价值"></a>40年的商住房没有70年的住宅有投资价值</h2><blockquote><p><strong>klid：</strong></p><p>LZ 请教一下，市中心没有天然气的房子能买么？自住兼投资</p><p><strong>kkndme：</strong></p><p>商改住，40年产权？<br>不影响出租，但是变现可能不那么容易。</p><p><strong>klid：</strong></p><p>是70年产权住宅，但是不通天然气！<br>LZ请教一下啦，可以自住兼投资么</p><p><strong>klid：</strong></p><p>自住只要你觉得不用天然气也很方便，当然没问题。</p><p>投资首先是出租不存在问题，另外市中心的位置可以填补任何房屋设计方面的不足，70年产权具备投资价值。购买这样的房产还是可以的。</p></blockquote><h2 id="限贷对精英没用"><a href="#限贷对精英没用" class="headerlink" title="限贷对精英没用"></a>限贷对精英没用</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>楼主，我也是不明白，现在成交量确实上来了，按说现在贷款控制的这么严，第三套房都贷不到款，是谁在买房，难道都是第一套房的刚需吗</p><p><strong>kkndme：</strong></p><p>民币发行泛滥，有钱人绝对数量庞大。在北京上海等城市，手中拥有千万现金的人不在少数，都是全国的精英阶层啊。精英阶层的财富积累已经逐步完成，提高首付，严控贷款只能抑制小白领保值的需求，但对于精英阶层是没有任何作用的。</p><p>如果将来推出房产税就更好笑了。精英阶层谈笑风声，小白领神情紧张，最终结果是全部转嫁租房客。</p><blockquote><p><strong>bluesyang2010：</strong></p><p>我认为,这个跟kfs和政府之间的博弈有很大关系,投资人前段时间一直在观望或者投入到农产品等领域,我不记得是7月还是8月,突然听到热钱大量涌入国内房地产市场的传闻,之后成交量就上来了,这些信息之间有很大的关系,但我捋不清.<br>请楼主评评</p><p><strong>kkndme:：</strong></p><p>你说的很有道理，当资金泛滥无处可去，一定会找到一个出口。资金如洪水在于疏而不在于堵，资金一旦冲破调控所筑的堤坝，将一发不可收拾。所以屡次调控屡次暴涨。如果不能有效开渠，将注定调控政策的失败。</p></blockquote><p><strong>tianxiaobing11:：</strong></p><p>我现在就被抑制住了，现在是认房不认贷，我也不能贷款了，可现在动不动就得百万以上才能买房，真是力不从心啊，房贷新政看来是堵塞了中低收入的房产投资渠道了，对精英阶层反而是利好，这调控就搞笑了</p><p><strong>bluesyang2010:：</strong></p><p>zf倒是想调控精英层呢,但zf本身就是精英的组成部分,所以zf只能借砍掉投机者之名,开拓自身,抢占市场,特别是楼主说的租赁这个大市场,所以特别佩服楼主之前说的:zf找到了吃租赁这块蛋糕的最好时机,明着是抑制房价,其果却是让很大部分老百姓租着zf的房,zf的钱就更多了,到时候想拆哪儿拆哪儿,精英更精英,百姓更百姓….可悲呀</p><p><strong>kkndme:：</strong></p><p>估计给政府出这主意的幕僚熟读过宋史，宋代官府就是靠出租房给群众敛财的。</p></blockquote><h2 id="外汇管制决定了大部分有钱人只能在国内投资"><a href="#外汇管制决定了大部分有钱人只能在国内投资" class="headerlink" title="外汇管制决定了大部分有钱人只能在国内投资"></a>外汇管制决定了大部分有钱人只能在国内投资</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>还有一个问题始终不明白，请教楼主，现在五六百万的房子都有人全款买，这些人为什么不买国外的别墅呢？难道就因为中国的房子升值快吗？要我有那么多钱早移民了</p><p><strong>kkndme：</strong></p><p>我国实行的是外汇管制，人民币不能自由兑换，不可能大批人口通过地下钱庄转移资产。只有官员和少部分有背景的高端人士才能做到人民币资产顺利兑换转移。</p><p>一旦发现较多资金量的人民币兑换美元出境，国家将采取强制管制措施。</p><p>现在国家对外汇外流已经非常重视，携带价值50美元以上的商品入境都要交税，实际上国家给出了一个不希望人民币兑换成外币外流的一个强烈信号。</p></blockquote><h2 id="外国国籍在中国生活是更好的选择"><a href="#外国国籍在中国生活是更好的选择" class="headerlink" title="外国国籍在中国生活是更好的选择"></a>外国国籍在中国生活是更好的选择</h2><blockquote><p><strong>理财的猫咪：</strong></p><p>我有段动过移民的念头，但现在基本放弃了。不知自己的选择正确与否，想听听楼主高见。</p><p><strong>kkndme：</strong></p><p>移民不见得能够适应，毕竟文化差异太大，但是如果拥有一个外国国籍，在中国生活，是一个比较好的选择，至少，你的财产是受到保护的。</p></blockquote><h2 id="分期付款买房，如果房价上涨，很容易毁约-amp-自住要选大品牌开发商"><a href="#分期付款买房，如果房价上涨，很容易毁约-amp-自住要选大品牌开发商" class="headerlink" title="分期付款买房，如果房价上涨，很容易毁约 &amp; 自住要选大品牌开发商"></a>分期付款买房，如果房价上涨，很容易毁约 &amp; 自住要选大品牌开发商</h2><blockquote><p><strong>showcar:：</strong></p><p>楼主说的正确啊，除非世界经济再次崩溃或者朝内变天，否则的房价要跌，太难！</p><p>到处听说是纸币不受截至的发行，有点现金留在手上都发抖啊，是因为“贬值”发抖！</p><p>所以，出手了，淘一套保值去吧！！总价150万左右。</p><p>楼主请教付款方式：<br>1：分期付款，30%首付，6个月内付30%， 12个月内付30%，10%交房前付清（约24个月）；<br>2：商业银行贷款，需要50%首付，50%余款贷款，首付3个月后按揭，110%的贷款利息。<br>商业贷款的话，计划交房后就付清。</p><p>不知道哪个更合算？期待楼主解惑。。。。</p><p><strong>kkndme:：</strong></p><p>分期付款是你和房东的约定？这个比较不靠谱，如果是付清后过户，一旦房价上涨，很可能出现毁约。</p><p><strong>showcar:：</strong></p><p>楼主，忘记说了，是期房，我们这里是房子盖到一层高就预售了。房子结顶是按揭。结顶后1年半左右交付。</p><p><strong>kkndme:：</strong></p><p>貌似你们那里的房产商很不规范。我还是觉得投资自住都要选择大开发商、大体量楼盘，不仅配套好，升值空间也大，这样的楼盘几乎没有风险。</p></blockquote><h2 id="通货膨胀和房价的关系"><a href="#通货膨胀和房价的关系" class="headerlink" title="通货膨胀和房价的关系"></a>通货膨胀和房价的关系</h2><p>要解释通膨和房价的关系，我来建个简单的模型，跟大家说说</p><p>假设5年前，某个国家一共有10个一篮子生活必须品（包括吃，穿，住，行的所有的必需品），这个国家发行了100万货币，一共有10个人。那么这个国家的毎个篮子生活必须品价值10万。</p><p>假设这10个人每人得到了10万元收入，则每个人刚好分配了一个篮子。</p><p>实际情况是，这10个人中，有人得到了10万元，有人得到了8万元，有人得到12万元。那么这10个篮子通过在品质上的差别有所区分，卖给这10个人，刚好1人1份，只不过有的品质略好些，有的品质略差些。<br>时间过了5年，这个国家增加到20个一篮子生活必须品，人口还是10个人，但是发行了1000万的货币，那么这个国家的毎个篮子生活必须品价值50万。价格翻了5倍。如果每个人平均是100万，则每个人可以得到2篮子生活必需品，生活提高了。但实际上是，这10个人中，4个穷人每人还是10万，3个普通人每人是20万，剩下3个富人每人300万。</p><p>这3个富人共900万可以买掉18个一篮子生活必需品。剩下7个人只能分配到2个一篮子生活必需品。这样势必有人会饿死。而且无论是穷人还是普通人都买不起任何一个一篮子生活必需品。社会不可能只有富人才配生存，没有穷人，富人就不会存在。</p><p>因此必须有一项物品能够从一篮子生活必须品中剥离出来，吸收掉富人庞大的资金，同时也要让穷人和普通人能够买的起一篮子生活必需品中能够维持生命的最基本的生活品。</p><p>于是就要把一篮子生活必须品进行拆分。找到一项物品，不拥有不会饿死，但拥有能够让人过的舒服，具备高的使用价值，能够保存，具备稀缺性。</p><p>这个东西就是具备产权房屋（注意不是使用权），而一篮子生活必须品中其他的东西都不具备这个条件。<br>吃的不能保存，</p><p>衣服不具备稀缺性，</p><p>土地和房屋，是生产，居住，商业贸易的必需品，可以保存，具备稀缺性，富人拥有房屋土地的所有权可以租给普通人和穷人进行生产和居住。土地和房屋超过租金部分的溢价就变成了富人中吸收资金，炫耀财富的特殊品。</p><p>所以请注意，真正吸收大量发行的被富人拥有的货币的，是土地和房屋超过租金部分的溢价，所以房屋的租售比很低是货币大量发行造成的。房屋土地租金成为了新的一篮子货币中的必需品，而房屋土地所有权被剥离出来变成了富人之间货币再分配的游戏。<br>这样一篮子生活必须品进行了重新定义，本来包括的房屋，变成了房屋租金，而房屋所有权被从一篮子生活必须品中剥离出来，变成了吸收富人多出来的货币的奢嗜品。而一篮子生活品分成两大类，即最基本的和品质高的。</p><p>最基本的又变成了10万一个，保证这个国家的4个穷人可以每人得到一份。</p><p>品质高的，20万一个,3个普通人和3个富人每人得到一份就可以得到较好品质的生活。</p><p>多出来的840万，就是房屋的所有权，供3个富人拥有。房屋所有权的价格远高于租金，这是因为房屋所有权已经变成了富人炫耀的资本，身份的象征。<br>因此说，高房价的根本原因是由于货币发行泛滥和收入分配不公。这个根本问题不解决房价不可能下降。</p><p>而且单纯的依靠行政手段让房价下跌不但不能抑制通货膨胀，多出来的流动泛滥的货币得不到有效吸收，会推动生活必需品上涨，使穷人的生活更加艰难。<br>当然，有人的说，这多出来的840万为什么不投入到创新领域带动需求，增加一篮子生活必须品的品质。</p><p>这显然是不现实的，900万的财富集中在3个人手里，剩余7个人总共只分到100万，而平均一篮子生活必需品的价格是50万，7个人应该有350才能满足生活需要。购买力的不足一定会使远离生活必须品的任何东西都没有市场。</p><p>高房价，低租金是货币泛滥发行和分配不公的必然结果，而不是推动通货膨胀的，阻碍实体经济发展的原因。</p><p>货币泛滥和分配不公才是实体经济发展困难，房价高企的根本原因</p><blockquote><p><strong>fataltomato：</strong></p><p>有钱人的投资渠道一般都不是房子</p><p>房子最多是资产配置中的一项</p><p>开始投房收租，说明财富控制能力的下滑，往往意味着人生下坡路的开始</p><p>所以诸君，还是努力赚钱改变人生为第一要务</p><p>评来论去，于事无补</p><p>别人说到了，你不一定明白，你明白了，不一定有体会</p><p>你有体会，不一定能做到，你做到了，不一定能做好</p><p>你做好了，还不一定有机会呢，呵呵</p><p><strong>welldayzwb：</strong></p><p>对于不善理财的人来说，买房收租未尝不是一个选择，到没必要上纲上线，当然为了收租而买房，目前看起来不是很理想的一个选择</p></blockquote><h2 id="南京买房分析-amp-买房要做好调查分析工作"><a href="#南京买房分析-amp-买房要做好调查分析工作" class="headerlink" title="南京买房分析 &amp; 买房要做好调查分析工作"></a>南京买房分析 &amp; 买房要做好调查分析工作</h2><blockquote><p><strong>闲坐庭前也：</strong></p><p>楼主，一直跟帖，<br>觉得你的认识颇有见解<br>请教一下<br>最近看了南京奥体附近的仁恒楼盘<br>2万2左右每平方<br>不是自住，用做投资的话现在出手是否合适呢？<br>一直在犹豫中<br>望不吝赐教</p><p><strong>kkndme：</strong></p><p>尽管南京去过多次，但对于那里的楼盘并不熟悉，所以不敢妄言。如果能够提供更详细的信息，或许可以试着为你分析。但以你目前提供的信息，真的不好评判</p><p><strong>闲坐庭前也：</strong></p><p>恩，<br>详细的话就是南京河西奥体那块推出了仁恒G53精装公寓<br>简称高汤，90平方复式上下两层的，180万左右<br>我对南京不太了解<br>有人说2014青奥会召开，<br>有点升值空间<br>我不准备贷款<br>因为平时也不怎么会理财<br>全付可以95折<br>楼主，请问我能买进吗？<br>汗一个先，我买房好像总买在高点呢<br>泪奔<br>不知道这次怎么样<br>楼主不吝赐教哦！！！</p><p><strong>kkndme：</strong></p><p>房产毕竟是一笔相当大的投资，对于一个不了解的城市，就轻易购买，显得过于轻率。青奥会是噱头但不是利好，对于房产的长期升值没有任何促进作用，充其量也不过有些资金参与短线炒作。<br>经济的发展才是一个城市房价上升的驱动力。<br>建议在你购买之前，认真去南京进行考察。不但要考察周边楼盘，还要考察你所购买地区的经济发展状况、交通状况、商业和学校的分布。最好能够了解当地政府的规划。</p></blockquote><h2 id="北京华清嘉园"><a href="#北京华清嘉园" class="headerlink" title="北京华清嘉园"></a>北京华清嘉园</h2><blockquote><p><strong>dog19972009：</strong></p><p>请教楼主点评华清嘉园的房子以及上地一带的房子，谢谢楼主！</p><p><strong>kkndme：</strong></p><p>学区房，房价坚挺，配套齐全，环境也还凑活，紧邻轻轨，唯一的遗憾就是交通比较拥堵。如果有钱是可以考虑的。但是绝大多数人只能对华清嘉园的高房价兴叹了。我预计两到三年内，华清嘉园就将冲击5万关口。<br>上地可参加前两页的评述。</p><p><strong>dog19972009：</strong></p><p>谢谢楼主，但如果是上地的低密度低板房格局朝向及位置都较好的小3居可以考虑吗？另外知春路一带的九十年代的塔楼还有板房可以考虑吗？</p><p><strong>kkndme：</strong></p><p>北四环周围有许多不错的小区，都值得考虑，无论自住还是投资都还是比较合适的。比如志新村、塔院、牡丹园小区等等，配套齐全，居住舒适，特别是志新村还是学区房，这一片区位肯定是好过上地的。缺点就是户型较老，物业等于没有。</p></blockquote><h2 id="中国的朝代更替"><a href="#中国的朝代更替" class="headerlink" title="中国的朝代更替"></a>中国的朝代更替</h2><p>中国与西方最大的不同，是历次革命都要推倒重来，革命总是伴随着血琳琳的屠杀和破坏，无论是财富还是文化。每次建朝人民都要从一穷二白做起，所以才说中国人民苦难深重，几千年的历史，居然没有什么积累，有的只是统治者根深蒂固的帝王思想世代传承。<br>从项羽焚烧阿房宫到近代的破四旧，革命的都非常彻底，人民洗脑也非常彻底。所以帝国时代才能够一直延续。西方人贪婪对财富是占有和继承，东方人重义轻利所以破坏焚烧和屠杀。</p><p>西方的大革命产生了资产阶级新贵阶层，然而当时却不为普通群众接受，尽管他们有钱有势，但是却得不到群众的尊敬，直到资产阶级新贵们捐钱捐物，为群众做了大量的善事之后，才得到人民的认可。<br>而我们这个时代产生的新贵却太多的为富不仁。</p><p>而中国古代的乡村，通常族长就是村子里的大地主，族长是非常重视名胜的，一个族长必须有足够的威望，象修桥补路，借无米下锅的族人粮食，都是族长份内的事。去徽州旅游的人都知道，道路、桥梁等公益设施无不是富商修建。古人不但讲个人声望，还讲积阴功。假设你去贵州的深山中旅游，发现山径上常常有个亭子，不但有坐的地方，还有水井或者用水管从山上引来的泉水供路人休息。这都是周围的村里人为积阴功修建的，绝非政府投资。<br>时值社会主义的今天，反而一切行善积德的事都不讲了，全民金钱至上。没有文化建设的民族是悲哀的。</p><h2 id="中国可以无限印钞吗"><a href="#中国可以无限印钞吗" class="headerlink" title="中国可以无限印钞吗"></a>中国可以无限印钞吗</h2><blockquote><p><strong>tianxiaobing11:：</strong></p><p>中国可以无限印钞票吗？有没有个限度呢？我是请教楼主，肉食者会怎么思考呢？他们的幕僚能从历史中找到答案吗？楼主的历史资料库中有这方面的吗？</p><p><strong>kkndme:：</strong></p><p>如果你收集过铜钱，你会发现有一种大钱叫一当十五。这就是中国古代的铸钱方式。当铜不够了，zf用铸造2枚铜钱的铜铸造一枚大钱当作十五个大钱用。那时还没有纸币，所以采取了这种方法。<br>到了解放战争时期，物品紧缺，国军大量印制金圆券，今天用一捆钱没一斤米，明天用同样一捆钱却只能买一两米。当然这种金圆券无限制满天飞也和我军大量投放伪币有关。<br>当物质紧缺时，必然会通过发行纸币来缓和矛盾。小时候我常去买2毛钱的肉馅包一顿饺子，现在2毛钱仍在大街上也没人捡。肉馅从2毛钱涨到4块钱，货币贬值了20倍。为什么我们认可肉馅从2毛钱涨到4块钱的既定事实，但是却不能想象现在的物价会在未来的10年再涨20倍呢。<br>如果你收集过邮票，会发现50年代的老有票的票面价格都是500元一张，1000元一张，我们建国后的货币也并不是一开始就是圆角分的。50年代圆是最基本的货币单位，随便买个最小的东西，都是1000元起步的，很象现在的越南盾。<br>我们国家的印钞制度，主要跟外汇挂钩，在帖子里已经做过了描述，你可以在帖子里找一找。正是由于国内商品的内需不足，完全依靠低附加值商品出口创汇，才造成了人民币的外升内贬。</p></blockquote><h2 id="读史读的不是故事，还是找历史规律，以古鉴今"><a href="#读史读的不是故事，还是找历史规律，以古鉴今" class="headerlink" title="读史读的不是故事，还是找历史规律，以古鉴今"></a>读史读的不是故事，还是找历史规律，以古鉴今</h2><p>读史读的不是故事，还是找历史规律，以古鉴今，毛就是这方面的天才。<br>读史难在古人常常作假，事件往往扑朔迷离，必须象破案一样，从重重的迷雾中寻找真相，这也是读史的乐趣所在啊。<br>好比喜欢三国的度魏延，总认为此人天生反骨。事实上，魏延作为仅次于关张马黄（没有赵云，赵云的才能和级别都不能和魏延相比）的第五员上将，在关张马黄死后，成为了西蜀的军方顶梁柱，不但有极高的军事天赋，而且忠心耿耿，不足的是政治头脑不大灵光，结果诸葛亮刚死，就被小人杨仪给黑了，不但掉了脑袋，还被按上了背主的罪名。</p><blockquote><p><strong>汝爱之罪：</strong></p><p>《三国演义》里这一段完全是黑魏延来着。<br>我心里还想，其实魏延还是比较大度的，马谡刚愎自用的时候，诸葛亮很不爽，但是魏延还一个劲的替马谡说好话，我就觉得魏延一直忠心耿耿，怎么可能晚节不保呢？</p><p>唉，看来正史和演义，还是有很大区别啊</p><p><strong>kkndme：</strong></p><p>正史里很多信息都是极其可疑的，就更别说演义了，呵呵。<br>每次听评书赤壁大战一段，诸葛亮给关张布置任务就觉得好笑，赤壁大战时诸葛亮官拜军师中郎将，官职远不如关张，关张不可能直接听诸葛亮的将令。当时，诸葛亮顶多给刘备出出主意，调兵遣将还应该是刘备的事。演义一夸张诸葛亮，，就没刘备什么事了。</p></blockquote><h2 id="毛太阳往事"><a href="#毛太阳往事" class="headerlink" title="毛太阳往事"></a>毛太阳往事</h2><p>当年毛太阳发动文ge的原因是因为政府被刘奇和邓平的政经系所把持</p><p>当年要是老毛召开人大来决定谁去谁留，老毛肯定被PK掉</p><p>如此不发动底层，通过正常的程序夺不回权利</p><p>什么防止腐败，打到走资派都是借口</p><p>毛太阳比任何人都要腐败</p><p>死的时候存款有1亿多（不是工资积攒的，都是稿费，垄断市场的稿费）</p><p>70几年的时候，1亿多，确实恐怖</p><p>但是后来被邓平给没收了，讽刺呀，以这是全党的财富为由</p><h2 id="北京大兴"><a href="#北京大兴" class="headerlink" title="北京大兴"></a>北京大兴</h2><blockquote><p><strong>VVVMMMABC：</strong></p><p>楼主,现在大兴的房子新楼盘较多,某楼盘推出两次均卖光光.地理位置占尽优势,因为紧挨着将要建好的地铁.现在能出手买吗?首套,没有立马买房结婚的压力,但三四年内总得买吧.首付提高后也就刚刚好付首付.要是利率也真的不打折,真不知道如何是好.</p><p><strong>kkndme：</strong></p><p>通州、房山、大兴都是前期炒作比较厉害的区域，在楼市调控期要慎重购买，如果遇到明显低于周边二手房的楼盘可以立即下手购买，否则观望。</p><p><strong>VVVMMMABC：</strong></p><p>楼主圣明,楼主说得明显低于周边二手房的话是指大于多少一平的时候呢?现在的二手房和新房都互相盯着呢,都差不多</p><p><strong>kkndme：</strong></p><p>一般来说调控期内，郊区新盘比调控前的周边二手房大约低10-20%%之间，且成交放量，说明底部已见。</p></blockquote><h2 id="贵阳"><a href="#贵阳" class="headerlink" title="贵阳"></a>贵阳</h2><blockquote><p><strong>努力看透：</strong></p><p>楼主，谢谢你对贵州的关注！<br>我是贵阳的，想听听你对贵阳的看法，我07年在小河区2400买了120平方的新房子，今年八月初买了套市里的二手房，93年的，65平方，学区房，总价43万，送家具家电！<br>非常想听听你对贵阳房市的看法，还有金阳新区的看法，感觉金阳就是房地产撑起的，如果地产有个风吹草动，金阳会是最容易受打击的，不知对否？<br>另外93年的老房子以后卖时不好贷款，是不是会影响成交价格？<br>谢谢</p><p><strong>kkndme：</strong></p><p>刚从贵阳回来没多久，呵呵。<br>贵阳投资房产有一定的风险，主要是城市比较小，不好变现。如果我在贵阳投资，即使再贵也会选择喷水池附近市中心的楼盘，稀缺性较强，变现相对容易。<br>贵阳是一个城区尚未开始升级改造的城市，zf大力打造金阳花溪等外围区域，但是将来一定会遇到较大的交通瓶颈，城区的升级改造早晚都要启动。<br>关于金阳实际上就是政府的造城运动，因为市政府的搬迁对房价有一定的支撑力，但是随着人口的大量入住，从金阳到主城的交通可能出现瘫痪状态，谁又能保证政府不进行二次搬迁呢？<br>贵阳的美女确实很多啊，是这个城市最靓丽的风景，令人留恋。</p><p><strong>努力看透：</strong> <br>贵阳小了，为什么房子不容易变现呢？毕竟全省只有贵阳繁华点，地方小，人多，更应该容易变现啊！我指的是市区房，不含郊区</p><p><strong>kkndme：</strong></p><p>市中心中高档房屋变现是没问题的，但市中心老房变现也不是很容易。贵阳的城中心改造升级还没有启动，市区存在大量的老公房，而贵阳最需要的是改善型中高端住房。现在zf全力打造金阳等外延区域，大片的新楼盘拔地而起，二手房交易的活跃度远不如其他省会城市。</p><p>贵阳与成都、昆明这些西部城市略有区别，昆明、成都有大量的外地人口，这些外地人口构成了买房刚需，因此市区位置的稀缺性就显得尤为重要。<br>但是贵阳的外地人口相较昆明、成都要少，以本地改善型需求为主，所以城区楼盘的档次尤为重要。<br>作为相邻的省会城市，重庆的吸引力要大于贵阳，贵州许多地州的资金可能会被重庆分流。</p></blockquote><h2 id="富人越富、穷人越穷"><a href="#富人越富、穷人越穷" class="headerlink" title="富人越富、穷人越穷"></a>富人越富、穷人越穷</h2><blockquote><p><strong>我爱的飞飞：</strong></p><p>其实很多空军比较SB，天天叫着加息，说是提高收入就可以买得起房子，试问穷人手里10万，富人有100万，按照现在的利息，穷人每年整存整取10万不开税收是2250元，而富人得到的是22500，加息以后假设穷人每年收入是4000，富人是40000万，成千上万的富人每年多出40000，而生产资料和资源是有限的，当每个富人的4万流入市场，试问是不是又要通膨呢？所以加息是最愚蠢的均贫富方法。行之有效的办法其实是重新发行货币。但是除了改朝换代几乎不可能。<br>其实穷人一穷就注定穷下去，除了少数几个可以翻身，原因很简单，因为生产资料掌握在富人手中，富人为什么有生产资料的支配和拥有权，答案很简单，只有革ming。<br>由此则可以明白为什么房子可以按照富人的想法定价，就因为土地，建材等生产资料掌握在富人手中。<br>妄想房子降价其实是更愚蠢的想法，为什么？GCD拼命给公务员和arm加薪，这些钱用印刷机印出来发到公务员手里最终却让老百姓埋单？统治阶层当然首先第一位维护和最大化自己的利益，任何朝代都是如此，只有当民心涣散的时候才出台一些政策缓和民心。现在看CCAV，对社会主义这充满美好想象的词的强调都逐渐弱化了，你不得不承认，在GCD的领导下大家都有肉吃了，国家安定，在这里嚷嚷的，不过是对贫富不均不满而已。</p><p><strong>kkndme：</strong></p><p>今年朝鲜搞货币改革，重新发行货币，结果导致不可控的通货膨胀，财政部长给枪毙了。</p><p><strong>我爱的飞飞：</strong></p><p>所以民众还是愚蠢的，只看到了15元最后换成1元的落差和失落，没有看到除去附加值的生产资料的价值。货币改革是富人最不愿意看到的，跟加息是一个道理，因为改革让货币的附加值骤然缩水，富人的货币不再比穷人有更多的附加值，而统治阶级恰恰是富人，没人愿意搬石头砸自己的脚。所以为什么我说不可能。</p></blockquote><h2 id="通货膨胀的形成原因"><a href="#通货膨胀的形成原因" class="headerlink" title="通货膨胀的形成原因"></a>通货膨胀的形成原因</h2><blockquote><p><strong>我爱的飞飞：</strong></p><p>在谈谈通膨是怎么形成的。生产资料是有限的，生产资料其实一直都没有变，而货币只是一种虚拟附加值而已。像楼主所言，一个国家，有人手里有8元（假设他是建材行业的），有人有12元（假设是石油行业的），但是人心不足蛇吞象，建材行业的员工觉得不够用了，8元的想变成13元，石油行业的12元想变成20元。因此，建材行业把原来卖8元的水龙头提价成13元，对于石油行业的人，装修的时候拿着12元发现自己买不了13元的龙头了，于是琢磨着把石油卖到20元，由此各行业依次提价，物价越来越高，实际上水龙头还是水龙头，一桶石油还是一桶石油，生产资料始终没有变，稀少，远远不够人均分配，但是生产资料的价值变了，提高了。拿成都的房价为例，02年的时候成都人均收入800-1200，房价2000-4000，约为房价的3倍，现在成都人均收入2500-3000，成都房价7500左右，仍然为3倍比例，看似7500比2000翻了多翻，实际上房子作为所谓的生产资料，始终是稀缺的，在02年的时候，拿着当时的工资买4000的房子仍然不容易。任何时候，其实都是一种相对平衡的比例，而空军喜欢拿现在的工资跟过去的房价相比，但是那种状态太过理想，想明白的，就会觉得房子不贵。</p><p>什么时候房价会下降，一句话供求关系，人口减少是房价下降的唯一出路。即便是出台房产税，很有可能富人顶着房产税不卖，变相加租抵消房产税，特别当今租房市场存在中介的操纵，很多房子都是通过中介渠道才租出，垄断的中介忽悠房东集体涨价，房产税很容易就转嫁给租房者。ZF也不是完全不作为，当你开着车逛着公园坐着快铁地铁的时候，就应该加速印刷的钞票有一部分投入了基础设施建设，如果不通过税收和出让土地收入来建设，我们很可能还走在乡间小路上。</p><p>虽然瓷器国是中yang高度集权的国家，但是任何朝代都是诸侯之间相互制约，上面出台个政策，各个诸侯执行与否或者执行是否到位都可以影响房价甚至很大影响，且不谈上面是不是真的想降房价，即便是动真格，下面的诸侯听不听招呼是另外一回事。有心无力的事情不是不可能发生。共同富裕其实是一种美好愿望，因为人与人的竞争天性，不可能人人平等，只要有人还想凌驾于其他人之上，就永远不可能GC主义。</p><p>任何社会都是这样的形态，忍无可忍-geming-平稳-不满足-垄断与剥削-改革-改革失败-再次忍无可忍。为何历史反反复复如此？就是因为人的劣根性，因为人性的贪婪。所以周而复始而已。</p><p>人性的贪婪决定了社会进程，刚开始穷人只想平均，从富人手中夺取生产资料，当GEming之后，穷人开始不满足于仅仅是平均，穷人想要凌驾于其他人之上，想变成富人，于是利用geming占有的各种手段获取利益，最终变成了富人，被凌驾的穷人再次想通过变革改变自己的地位。。。。如此循环。。。</p></blockquote><h2 id="深圳-amp-昆明仇书记-amp-通货膨胀体制内高枕无忧、体制外自求多福"><a href="#深圳-amp-昆明仇书记-amp-通货膨胀体制内高枕无忧、体制外自求多福" class="headerlink" title="深圳 &amp; 昆明仇书记 &amp; 通货膨胀体制内高枕无忧、体制外自求多福"></a>深圳 &amp; 昆明仇书记 &amp; 通货膨胀体制内高枕无忧、体制外自求多福</h2><blockquote><p><strong>sprina0321：</strong></p><p>楼主真是高人啊，追了两天，终于看完了。也想向楼主请教下房事</p><p>不知楼主对深圳了解吗，我们来深圳七年了，结婚也好几年了，可是最近才去布吉买了首套，布吉的可园，二手，单价一万四。现在深圳关内10年的二手都一万六，好一点的两万，关内基本没新房了，有的都3万左右了。大量的新房都在关外，基本2万吧。我们本来也想买关内，可是想着同样的价格在关外可以买好点的，就买了关外，不知这个决定是否正确？按楼主的意思，还是要买市中心，可是市中心的话，只能牺牲面积，房子也旧，这样住着也不舒服啊。</p><p>另外，我父母就在昆明，他们本来在一环上有套房改房，挺方便的，就像楼主说的，可恨的仇书记要制造需求，现在他们的房子说是要拆了，他们现在想买，可是一环外的都8000多，他们觉得有点贵，买了以后，手上的钱就都用完了，又想干脆等回迁。楼主觉得要不要买呢？<br>我父母就我一个孩子，他们在深圳买过一套房子，就是市中心的塔楼，等我们不住了，这套房子要不要卖掉，还是留着出租好？</p><p><strong>kkndme：</strong></p><p>深圳不太了解，不过宁肯牺牲点品质也要选择市中心，这是无数人经过从市中心搬到郊区大户型再搬回市中心老房子而取得的宝贵经验，当然如果你在关外上班就另当别论了。<br>往历史人物上套，qh应该算作集酷吏与奸佞于一身，横施暴（）政早晚落到身败名裂的下场，不是不报时候未到。等拆迁主要是在昆明风险比较大，几年不知道能建起来，志远综合体就是很好的例子，如果有能力不妨先买一套。</p><p>至于说房子卖不卖关键你是否需要用钱，如果不需要，又没有更好的投资，不妨先留着。</p><p><strong>sprina0321：</strong></p><p>我有时候想，像QH这样的人应该不得好死，断子绝孙，老天还真是不长眼。</p><p>请楼主明示 志远综合体是怎么回事</p><p>我父母家就在东站，董家湾中间那里，原来厂里也在，现在厂子搬到开发区了，家里的房子也逃脱不了被拆迁的命运了。<br>现在家里在一环出去点看中一个房子，房子挺不错的，大社区，新房，算下来9000多，不便宜啊。一环内的估计我们买不起，家里人年纪大了，想住电梯房。</p><p>楼主对昆明现在的房价怎么看呢，会不会回调，感觉今年涨很多。<br>现在9000，难道以后涨到2万，和深圳现在价格一样？我和老公也工作很多年了，现在年收入30多万，我们都买不起2万的，我们去看过万科在深圳的新盘，房子没得说，带精装修，2万多一平，一套要300万，虽然很心动，也只能放弃，怎么现在昆明人这么有钱了？<br>按照通货膨胀来说，如果以后昆明的房子卖2万，那深圳的岂不是要卖4万，那我们的收入也会涨到60多万吗？哈哈，实在算不过来了。通货膨胀对我们的收入有影响吗</p><p><strong>kkndme：</strong></p><p>一环外9000多的新盘，昆明还真没几个，滨江俊圆9000多，但容积率太高，又有大量的回迁户，个人很不看好。翡翠湾达到了12000，云上城、翠园等要开的楼盘估计开盘价也要上万了。呵呵<br>昆明的房价，我预计市中心将达到2万，一环二环间15000，滇池板块将达到12000，北市区及世博板块将达到1万。东市和西市在8000-9000。螺丝湾板块最不确定，但未来不会低于9000。<br>志远综合体早在几年前完成了莲花池片区的拆迁，但迟迟不动工盖房，时隔几年一点动静都没有，拆迁户没有买房的现在还在租房住。</p><p>关于通货膨胀问题，体制内的职工工资一定会与时俱进的。体制外人员的薪水不取决于通货膨胀，而是取决于行业的利润率，企业的利润和个人的能力运气。对于多数竞争激烈，产能过剩行业内的民营企业一般员工，工资增长是很难抵御通胀的，而且由于通胀导致生产成本的价格上涨，减薪甚至裁员的可能反而更大。</p></blockquote><h2 id="长春"><a href="#长春" class="headerlink" title="长春"></a>长春</h2><blockquote><p><strong>wkzjx2008：</strong></p><p>楼主你好，请帮我分析一下，谢谢</p><p>我在长春</p><p>长春的市政府在前几年的时候搬到了城市的南部，南部因为是空地，所以盖的都是新盘，价钱现在7000多，而我工作的所在的位置是原来的一个商业区，这里原来都是学校，医院和一些机关单位，好企业的家属楼，因为原来的购买力强所以居民楼的一楼都变成了小店铺，所以形成了这个城市的一个没有大商场的一片繁华商业区，但现在随着原住民的逐渐迁走，这里租房的人多。但这里有一个优势是离市里最好的小学和高中都很近，这也是这里房价坚挺的原因。现在这里的二手房如果是大户型在5000左右每平米，小户型6000左右，基本都是八九十年代的房子，2000年以后的次新房很少，距离这个区域较近的一个新盘是商住两用的卖到9000多每平</p><p>孩子现在在这上幼儿园，堵车太厉害了，为了孩子我在这租的房子<br>我现在手里有20万现金，请问这片区域值得购买么，买大的还是小的，我已经贷过一次公积金贷款，现在已经结清</p><p>现在这个城市很远的地方新开的楼盘也要4000多一平米</p><p>请楼主赐教，不胜感激</p><p><strong>kkndme：</strong></p><p>政府所在地区域又是学区房，这样的房子优势还是很大的，但是由于有大体量的老房子存在，将来有可能大规模拆迁，而拆迁补偿却决于zf是否铁腕，如果遇到铁腕领导，补偿额一定不会太高。这是购房的风险。对于非一线城市，新盘的风险肯定小于老房。</p></blockquote><h2 id="佛山"><a href="#佛山" class="headerlink" title="佛山"></a>佛山</h2><blockquote><p><strong>爱佛僧傲瞪詹牧师：</strong><br>lz高人！<br>不知道来过佛山没有？佛山紧邻广州，两地的地铁即将贯通接轨，房价应该会快速飙升，但是另一方面，佛山是个制造业城市，村镇工业高度发达，外来打工的比较多，流动性很大，lz所说的，今后买房只是有钱人游戏，房租会高涨，这点对佛山这样的小城市不知道成不成立？村镇里还是有很多便宜的出租屋的，高端点的打工者，如果房租太贵，应该会嫌贵干脆回家发展，最后只能留下低端制造业产业工人吧？这样房租应该还是很难上涨。</p><p><strong>kkndme：</strong></p><p>佛山还真没去过，只去过东莞和中山，呵呵。<br>对于广州一带房价相对偏低的原因是广州并非全省唯一的大型繁华城市，而是广东省内形成了大片的都市群，使得城市的经济得到了均衡的发展。这是最健康的城市发展模式，但也制约了房价的上升空间。随着地铁的贯通接轨，佛山的房价将呈稳步上涨态势。</p></blockquote><h2 id="首付提高的逻辑"><a href="#首付提高的逻辑" class="headerlink" title="首付提高的逻辑"></a>首付提高的逻辑</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>请教楼主，最近有银行提高了首付，这是为什么？政府真要让中低层租房子吗？政府吃租赁的大蛋糕吗？</p><p><strong>kkndme：</strong></p><p>主要还是防范金融风险，政府调控的目的从来也不可能是解决穷人的买房问题。恰恰相反，金融风险来自于让穷人买房，所以提高首套房首付比例，杜绝穷人买房，才是防范金融风险的有效手段。同时可以推升租金上涨，政府推出的公租房才有市场，有钱可赚。</p></blockquote><h2 id="四线城市"><a href="#四线城市" class="headerlink" title="四线城市"></a>四线城市</h2><blockquote><p><strong>shs2009：</strong></p><p>楼主，我们这个城市离武汉60公里，四线城市吧。我打算在新开发的工业园区买一套房子，买的理由是认为工业区是人员比较集中的地方，应该有比较大的需求，无论租售都应该有潜力的。我的看法对吗？</p><p><strong>kkndme：</strong></p><p>四线城市一定要选择城中心或者高档住宅区买房</p></blockquote><h2 id="苏州工业园"><a href="#苏州工业园" class="headerlink" title="苏州工业园"></a>苏州工业园</h2><blockquote><p><strong>夏天来了我也来：</strong></p><p>我是昨天才看到LZ这个帖子的，一口气读完了，眼睛虽然有些累，但心里却是收获颇丰，今年四月ZY刚开始严厉调控的时候，我可是抱了一百分的信任，心想我们老百姓的好日子终于来了，终于可以用较低的价格买套属于自己的房子了，可现在都九月了，看着周围一直慢慢望上爬的房价，真的是失望极了！<br>我九月三号的时候刚定了一套二手房，是我们的第一套房子，不知道LZ是否了解苏州工业园区的发展前景和房价，我们这套房子在园区的中心位置，也相当于市区吧，位置还不错，可就是这个房子属于政府修高速路时的拆迁安置房，房龄有十年了，原来房东的两证上写的土地性质是“出让”，不知道这样的房子以后是否有升值空间？因为在苏州园区同样的地段，同样旧的拆迁房价格基本都快一万了（我们定的这个房子因为离马路有些近，而且在顶楼，户型是小户带阁楼，上下两层复式结构的那种，所以便宜一些，只有八、九千），附近的高档商品房价格也要一万五左右！苏州和上海离的这么近，如你所说，江苏的有钱人都跑到上海买房了，苏州的房价是不是很难涨呢，同时也担心以后房价再继续上涨，ZY会出重拳打击楼市，真到那个时候，房价是不是要暴跌呢？</p><p><strong>kkndme：</strong></p><p>土地性质“出让”没有问题，“划拨”才有问题。<br>zf初重拳打击的结果往往取得相反的效果，因为政府如果希望继续执政是绝不可能让房地产崩盘的，房地产的崩盘将同时埋葬现有体制，社会“和谐”将不复存在。如何让房地产持续稳定与gdP同步上涨是政府最大的难题，完全取决于领导的智慧，但是以现在的水平来看，是很难做到的。<br>苏州工业园区房地产不是很了解，但是一个工厂及仓储所在地，缺乏高科技与文化历史底蕴的支持，房价一定会涨，但涨幅一定有限。</p></blockquote><h2 id="住房公积金利率"><a href="#住房公积金利率" class="headerlink" title="住房公积金利率"></a>住房公积金利率</h2><blockquote><p><strong>facetowall：</strong></p><p>另一个问题啊，我准备用住房公积金购买首套房，在其它的一些帖子上看到政府将在某个时间点上加息，那么对住房公积金的贷款利息（3.87%）会不会同样上调呢？上调幅度会是多少？对这个比较关心，麻烦楼主给解答一下吧。谢谢了！</p><p><strong>kkndme：</strong></p><p>如果当年加息，再次年的元旦后贷款利率也会相应增加，但公积金贷款利率增加的幅度很小，不用担心。加息说明通货膨胀严重，如果不是连续过度加息，对房价没有影响。从长期看更是不可能影响房价上涨趋势，除非经济崩溃。如果经济崩溃，持有纸币也没有意义，等同于废纸。<br>90年代我国高度通货膨胀，银行存款年利率曾达到百分之十几，但并没有影响房价的上涨趋势。</p></blockquote><h2 id="济南-amp-大规律拆迁的城市房价不会下降"><a href="#济南-amp-大规律拆迁的城市房价不会下降" class="headerlink" title="济南 &amp; 大规律拆迁的城市房价不会下降"></a>济南 &amp; 大规律拆迁的城市房价不会下降</h2><blockquote><p><strong>facetowall：</strong></p><p>不知道楼主对济南的房市了解如何？去年接着全运会的东风，济南房价涨了35%到40%，让许多人措手不及。现在市区的新开盘的楼盘依据位置不同大约在8000到13000rmb每平方。济南奥体中心附近的房子在9000到13000rmb每平方吧。我和老婆都在济南高校工作，目前俩人月收入6000+，公积金1100多吧。相比于其它省市地区高校，无论工资还是公积金</p><p>都比较少。我感觉高校老师属于体制内的边缘群体，工作忙(很多人不认同这点)报酬少，并且目前已经没有什么福利分房了，都要到市场上购买商品房。我们的家庭情况是这样的：均为独生子女，目前有一个孩子，二岁了，双方父母均是事业单位退休人员，我父母退休金合计1万每月吧，她父母大约7000.由于我父母在济南有两套房改房，所以现在他们住一套，我们三口住一套，房产证上都是我父母的名字，所以我和老婆属于无房户。目前想买一套房子给岳父母住，毕竟我们俩是独生子女，将来接到济南来住是早晚的事。感觉济南的房价几乎没有下降的可能，因为全济南正处于最火热的拆迁阶段，山东省已经把济南的改造升级列为战略了，并且全国的知名地产商如绿地、中海、保利、绿城、万达(好像万科没有)都来拿地盖房并且已经推向市场了。目前看中了奥体中心附近的一套2005年的二手房，房子很新，毛坯房，环境物业都不错，大约120平米，单价得9100，总价110万。我们想拿出70万现金，再以公积金贷款50万(10万装修)&#x2F;20年，不知道这样有没有风险。一个是担心房价下跌，再一个加息。请楼主给出明示，指导一下，万分感谢。</p><p><strong>kkndme：</strong></p><p>大规模拆迁的城市，房价没有下降的可能，可以忽略政策因素。既然城市大规模拆迁，就晚买不如早买，这是本贴中一再提到的。</p><p><strong>facetowall：</strong></p><p>多谢楼主的解惑。感觉济南不像北京上海那样具有巨大的政经优势吸引全国的阔商巨贾和精英汇集，也不像昆明、杭州那样为渡假天堂，还不像西安、南京、武汉那样高校云集具有巨大的教育资源。也就是说济南不能吸引相当多的精英投资，始终是个不温不火的地方，所以济南的房价有点虚，再上涨的话就脱离了实际的承受能力。楼主对此有何看法？</p><p><strong>kkndme：</strong></p><p>济南的地理区位并不差，但城市搞的不好跟领导有关，济南的经济前景不错，而且房价的上涨是拆迁带动的，以后很多城市都会走这一步。</p></blockquote><h2 id="公务员小区牛逼"><a href="#公务员小区牛逼" class="headerlink" title="公务员小区牛逼"></a>公务员小区牛逼</h2><blockquote><p><strong>何金银银金何：</strong></p><p>不知楼主是否了解哈尔滨的房价？小弟有套小房子 想换大点的，现在可是时机？哎 早拜读你这文章 今年年六月份就能换套大的了，可惜现在搞得自己换不起了……杯具&amp;</p><p>哈尔滨的公务员小区是没有产权的，不知道这种房子买了做第二套之后要不要征税？而且也非常贵，按使用面积要1w多一平了</p><p>小弟小白，您有空给指点指点……</p><p><strong>kkndme：</strong></p><p>公务员小区比房产证和土地证还保险。我国不是一个法制国家，任何颁发的纸质文件的可信度都不高，反而公务员小区因为是特权房，信用度要远高于产权证。</p></blockquote><h2 id="房屋朝向只要不是纯北西就行-amp-买房首选市中心、公园地产"><a href="#房屋朝向只要不是纯北西就行-amp-买房首选市中心、公园地产" class="headerlink" title="房屋朝向只要不是纯北西就行 &amp; 买房首选市中心、公园地产"></a>房屋朝向只要不是纯北西就行 &amp; 买房首选市中心、公园地产</h2><blockquote><p><strong>pohangcity：</strong></p><p>楼主。兄弟在一北方省会城市太原，目前这里的商品房平均价为5000左右，上周看了市中心的一套房子，112平米，紧挨市区里的公园（有一大湖），周边就是万达广场，万达的房子均价8500，已经售完，这个房子售价7000，已经是现房，结构还可以，唯一的问题是不是正房，朝向向东，周边一片混乱，全是施工的、拆迁的，说以后要以万达广场为中心，打造太原的CBD，也不知道能不能实现。<br>房子总价74万，首付24万，按揭月供3400，现家庭年收入税后10万，不可以公积金贷款，我已有一套住房，不过感觉还款压力很大。<br>我的问题是：<br>1、楼主帮我房子一下这个房子值不值？我想以后自己居住，现在的房子可出租1500左右。<br>2、太原也有万达、恒大的楼盘，位置是在太偏，价格6000带精装，户型也好，如何取舍？<br>非常谢谢楼主~~~~~~</p><p><strong>kkndme：</strong></p><p>房屋朝向问题，随着城市房价的不断飙升，已经不那么讲究了。只要是不是纯北房或者纯西方，都可以接受。<br>建议首选还是城中心，特别是公园地产，未来将更稀缺。</p></blockquote><h2 id="zf搬迁"><a href="#zf搬迁" class="headerlink" title="zf搬迁"></a>zf搬迁</h2><blockquote><p><strong>xhyyhzy：</strong></p><p>楼主您好，从您的帖中收获很多。觉得以前真的被洗脑洗的很厉害，从天涯学到很多。非常感谢您，又让我明白了很多事情。</p><p>请教您，市政府从原来的市中心，搬迁到另外一个地方，相对较远，因为城市不大。好的医院，学校，各种好的资源都在市中心。现在搬到一个特别偏远，荒凉的地方，重新开始建设，政府这么做是什么意思阿？以后这些医院，学校也会搬吗？多浪费阿。另，您怎么看该城市未来房价的变化。（注，离上海很近的3线城市）</p><p>期待您的分析。</p><p><strong>kkndme：</strong></p><p>政府搬迁到郊区不仅仅是个别城市问题，而是大多数二三线城市面临的问题。政府的用意在于扩大城市规模，扩充人口，追求gDP的高速增长，但对于新开发出一块荒郊野地，没有政府的带头搬迁，是很难炒作起来的。政府的迁入是一个信号，告诉老百姓，政府都搬过去了，以后配套肯定不会有问题。于是概念将透支未来，房地产价格就会飙涨。但是未来建成后政府是否真的搬迁就不一定了。<br>医院和学校全部搬迁会加深社会矛盾，所以通常是在新规划的区域建分校。如果自住还是主城，如果投资投机，可以考虑新城。</p></blockquote><h2 id="俄罗斯"><a href="#俄罗斯" class="headerlink" title="俄罗斯"></a>俄罗斯</h2><p>有同志提起俄罗斯很可以再说一说的。</p><p>俄罗斯的前身叫罗斯公国。首都不在莫斯科，而在基辅。</p><p>建立罗斯公国的，是东斯拉夫人，日耳曼人眼中的劣等民族。有人说过，俄罗斯和西方国家的差别，并不仅仅是经济上的差别，而是民族和文化的差别。这种说法还是很有道理的。用我们现在的话来说，斯拉夫的人种有问题。善于侵略，欺软怕硬，野蛮无礼。这是斯拉夫人的特点。所以在罗斯的土壤，永远出不了骑士精神。</p><p>罗斯人信奉基督教，源于弗拉基米尔一世娶了东罗马帝国安娜公主为妻。所以我们看到的俄罗斯教堂全部是拜占庭式的。拜占庭帝国灭亡后，东正教的中心就搬到俄罗斯。</p><p>罗斯国并不是统一的帝国，而是象我们的西周，搞的是封建分封制（我国在秦以后就不是封建社会了，因为取消了封建分封制，丞相都是打工仔，这一点是与我们的课本不同的），到了十二世纪，礼崩乐坏，罗斯国分裂了，罗斯的周天子弗拉基米尔二世·莫诺马赫的统一大业未能完成，故罗斯的土地上居然出现了十八个公国，很有点象我们的十八路诸侯。</p><p>十三世纪，成吉思汗的孙子，术赤的儿子，英勇的拔都同志西征，一个强大的统一的蒙古帝国攻击分裂的罗斯诸公国，很有点欺负人的味道。于是强大野蛮的东斯拉夫人在金帐汗国的铁蹄下，当了孙子。<br>莫斯科公国的伊凡一世·达尼洛维奇以贿赂的方式从金帐汗那里获取了弗拉基米尔大公的封号，并把东正教罗斯教区总主教驻地从弗拉基米尔迁到莫斯科。</p><p>莫斯科大公是很有一手的，一面拍金帐汗的马屁，一面组织军队，终于利用金帐汗国的内部分裂，一举击败了马迈汗率领的大帐汗国军队，并且兼并了科斯特罗马公国、加里奇公国、白湖公国、乌格里奇公国、下诺夫哥罗德公国、木罗姆公国和苏霍纳河流域北部等广大东北罗斯地区。</p><p>14世纪，莫斯科大公依凡三世在乌格拉河战役中，迫使阿合马特汗撤退，终于结束了金帐汗国长达两个多世纪的统治。</p><p>直到1713年，莫斯科公国干掉了罗斯地区的绝大多数王公，才形成了统一的集权国家，正式命名为俄罗斯帝国。</p><p>罗斯公国打得最精彩的战役就是楚德湖战役。<br>对手是称霸普鲁士的赫赫有名的三大骑士团之一，条顿骑士团，欧洲强大到令人恐怖的军事组织。<br>罗斯的最高指挥官是亚历山大诺夫格罗德公爵。<br>俄罗斯联军一方有1.5万到1.7万，主要是步兵。而条顿骑士团的大约有1万人，以重骑兵为主，其中大骑士应该不下千人，这是一支让整个欧洲都发抖的军队。<br>罗斯联军的步兵排成密集队形，据守冰湖东岸。骑士团的重骑兵以楔形阵发起冲锋。按常理看这是一场毫无悬念的战斗，罗斯步兵在强大的世界第一军事组织面前应该不堪一击。<br>但是亚历山大诺夫格罗德公爵是军事天才，军事才能相当于中国的乐毅。这位乐毅公爵仔细研究了重骑兵的楔形阵，认为弱点在于两翼的防御力量有限，如果重骑不能迅速撕开步兵防线，重骑的两翼会慢慢被侵蚀。<br>亚历山大同志于是把联军中主要的轻步兵安排在中间，列成加厚的方阵，消磨条顿重骑的突击能力，然后把他自己的诺夫格罗德精锐步兵放在两翼。<br>条顿骑士团的攻击开始还是成功的，但无法撕开罗斯步兵的军阵。最惨的还是条顿骑士狂妄自大，非要在楚德湖的冰面上发起冲锋（冬天结了冰），可想而知重骑兵跑到冰面上冲锋是什么样的效果，战争逐渐陷入僵持。<br>亚历山大的精锐步兵攻击骑士团的两翼，骑士团被包围了。亚历山大同志果断的派出最精锐的骑士亲兵卫队，从右翼后方包抄攻击骑士团。<br>可怜的条顿骑士，拥有世界上最强悍的战力，但在湖面上根本发挥不出来，大量的重装甲骑士掉进冰窟窿里，条顿骑士大团长也被俘虏了。<br>每次看这段历史，都为条顿骑士团唏嘘不已。</p><p>条顿骑士团败的最惨的是另一场战役，塔能堡。是中世纪欧洲最大规模的战争。<br>对手是波兰、立陶宛联军。<br>著名的波兰小说“十字军骑士”就是讲的这段历史。<br>骑士团的大团长是荣金根，大概有投入1万多名士兵。<br>波兰、立陶宛联军大约有3万名士兵。<br>联军方面指挥官是波兰国王Jagiello和立陶宛大侯爵Witold。<br>条顿骑士大团长荣金根是一个位标准的日耳曼大骑士，开战前，骑居然给波兰国王Jagiello送去两把剑，表示要进行一场骑士之间的较量。斯拉夫人是不敢这么玩命的，立刻拒绝了日耳曼骑士的要求。<br>条顿骑士团的骑士拥有强大的武力，真不是盖的，荣团长挥动旗枪组织冲锋，立陶宛军立刻溃败，波兰的翼骑兵也根本无法抵挡日耳曼骑士强大的冲击力，准备开始溃逃。这时一个意外发生了，大团长兼倒霉蛋荣金根同志在奋勇冲锋时突然遭了冷箭挂掉了，骑士团缺了指挥官陷入混乱，无法阻止有效的进攻，波兰立陶宛联军乘机组织起冲锋，条顿骑士团莫名其妙的大败。<br>真是谋事在人，成事在天。强大的条顿骑士的惨遭溃败居然因为一个意外。</p><h2 id="珠海-amp-唯一自住房不只是投资-amp-调控是最佳的选房时机"><a href="#珠海-amp-唯一自住房不只是投资-amp-调控是最佳的选房时机" class="headerlink" title="珠海 &amp; 唯一自住房不只是投资 &amp; 调控是最佳的选房时机"></a>珠海 &amp; 唯一自住房不只是投资 &amp; 调控是最佳的选房时机</h2><blockquote><p><strong>期待艳阳天：</strong></p><p>楼主，想就以下问题请教：<br>1、珠海属几线城市？您对投资珠海的房产前景作何分析？<br>2、我一朋友刚出手一套自住的房，打算租房住一段时间，想抄底再入，他是坚信房价会跌派，考虑到目前他供房确实有困难，且对刚出手的那套房不是很满意，请问他的做法是值得借鉴？<br>3、我目前的对自住的房朝向及大小不太满意，也想倒手后再入，我目前的房出手的话比同地段的新房价略低10-30%（主要是小区及户型有差异），如果换大、好的承受不了借贷压力，但如果淘二手房的话，可以在附件找比我目前房价低20%左右的二手房，请问我是否可以考虑换个朝向、大小更满意的房？现在是好时机吗？</p><p><strong>kkndme：</strong></p><p>以上，请楼主不吝赐教！</p><p>珠海是个适合居住的城市，干净整洁，生活节奏不快，相当安逸。<br>将自己唯一一套自住房卖掉，跌了买回，这样做的投机性心理太强，风险很大，往往得不偿失。当然如果为了换更大更好的住房就令当别论了。</p><p>人的一生很短暂，在衣食住行中，住占了人生的大部分时间，有一个温暖的家，生活才觉得安逸。如果有能力确实应该换一套自己满意的舒适的住房。至于出手时机，我觉得房产不是股市，不能总想着抄底逃顶，只要房价的长期上涨趋势未变，调控时期正是选房的最佳时机。</p></blockquote><h2 id="经济崩溃，最后接盘的是老百姓"><a href="#经济崩溃，最后接盘的是老百姓" class="headerlink" title="经济崩溃，最后接盘的是老百姓"></a>经济崩溃，最后接盘的是老百姓</h2><blockquote><p><strong>vipboy223：</strong></p><p>看了LZ的帖子，受益非浅！谢谢！<br>有一个问题还请教下：就像LZ所说，此次调控是ZY布局，赶出炒房者和小的kfs，目的是实现房子的垄断。但从政策和执行看，停止3套房贷并没有真正打击到真的炒房者，至多是改变了预期；二套房首付比例和利率的提高，确实实实在在的把改善性需求排除在外了；现在有些银行对首套房的首付都提高到4成，利率优惠也没有7折优惠了。当然我很愿意相信这次ZF在保护LBX，阻止老百姓去接房产暴利的最后一棒；显然这不是真正的原因。当然，首付和利率提高可以让银行增强金融防范能力。<br>随意想请教LZ对这个问题的看法；</p><p><strong>kkndme：</strong></p><p>政府阻止老百姓去接最后一棒？晕，如果真的到了崩盘的一天，接最后一棒的一定是老百姓，而且zf会千方百计的让老百姓接最后一棒。<br>分析问题不能用喜羊羊的头脑。</p><p><strong>vipboy223：</strong></p><p>显然LZ没有仔细看我写的内容。<br>换种方式问下：改善性需求是否现在就入市？首付高就不说了，利率1.1倍可是很厉害的；</p><p><strong>kkndme：</strong></p><p>如果是忙于拆迁的二三线城市就要抓紧买了，利率高也认了。<br>如果是一线城市不妨再看一下，但是观望也是有风险的，一旦上涨就买不到合适的房子了。</p></blockquote><h2 id="命运之矛"><a href="#命运之矛" class="headerlink" title="命运之矛"></a>命运之矛</h2><p>荣金根团长的挂掉会不会跟命运之矛有关呢。</p><p>1189年，神圣罗马帝国皇帝红胡子腓特烈一世在与教皇和解后，与狮心王理查一世、腓力二世·奥古斯都开始了第三次十字军东征。然而，红胡子腓特烈一世在小亚细亚渡过萨列法河时竟然意外溺死。原因是他突然丢失了传说中的命运之矛。</p><p>命运之矛也叫郎基努斯之枪。</p><p>正是一个叫郎基努斯的罗马士兵用这杆抢刺入了十字架上耶稣的身体，这只枪因沾有圣血成为圣物。</p><p>传说持有命运之矛的人可以主宰世界的命运，但失去的人会即时毙命，神圣罗马帝国的皇帝红胡子腓特烈一世就拥有这只命运之矛。</p><p>二战时期，希特勒从维也纳博物馆夺取了命运之矛，差不多占领了整个欧洲。但是在1945年4月30日下午2点10分，命运之矛又被美军夺走了，不到2小时，希特勒便吞枪自杀而亡，死时是下午3点30分，这难道仅仅是巧合？</p><p>荣金根是否也拥有过这只命运之矛？</p><p>我以为我们每个人都有一把属于自己的命运之矛，当你得到它的时候，你的事业、家庭、健康、财富都相当不错，但是当你失去它的时候，你的生命也将完结。</p><p>每个人对生命之矛都有自己的理解，希望我们都能够找到它。</p><h2 id="除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘"><a href="#除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘" class="headerlink" title="除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘"></a>除非外族入侵或全国大饥荒，否则双轨制决定了房价不会崩盘</h2><blockquote><p><strong>戈者：</strong></p><p>不要枪，不要炮，我只要选票，有了票，谁不让老百姓好过，就让谁滚蛋</p><p><strong>kkndme：</strong></p><p>我们连依法治国都办不到，何谈选票。<br>我们是实行双轨制国家，在经济全球一体化的今天，内部并不与外部接轨。这个好比是互联网，我们重要部门的内网是绝不会跟外网联结的。<br>改变只有两个前提，一是外族入侵，二是出现全国性的大饥荒。否则期望房价崩盘重建一个新世界是没有可能的。</p></blockquote><h2 id="kkndme聊北宋、唐朝"><a href="#kkndme聊北宋、唐朝" class="headerlink" title="kkndme聊北宋、唐朝"></a>kkndme聊北宋、唐朝</h2><p>北宋时期，有个文豪及公务员叫苏东坡，一辈子也没能在首都开封买上房子，不得已，在外省小县城投资了几套房地产。苏文豪公务员的儿子在首都结婚的时候，居然都没搞到一套新房，苏公务员急眼了，最后想办法跟朋友借了一套房子，总算把喜事办了。北宋跟我们的现实还是有区别的，象苏文豪公务员这样的中层国家干部，在京城大都是有几套房子的。可见北宋时期公务员待遇还不如现在。</p><p>苏文豪公务员的弟弟苏辙就比较幸运了。该同志也是公务员国家干部，工作上兢兢业业，勤勤恳恳，熬了几十年工龄，在七十岁的时候终于买到了房子，但是买的位置还算不上首都开封，而是在开封南边的许昌买的，相当于首都的卫星城。就好比在北京买不起房的同志，跑到天津去搞了一套。<br>苏辙公务员同志专门为买房的事写了诗，“我生发半白，四海无尺椽”，我老未有宅，诸子以为言”诗的意思反正是比较愤青，很想现在的傻空</p><p>唐朝还有个白居易同志，也是个公务员，级别相当于正处级，工作是在中央办公厅负责校对红头文件。白公务员职务一般，但工资可不低，每月一万六千钱。但是白公务员却买不起房，在长安东郊常乐里租了四间茅屋，因为房租比较高，城区的租不起，所以上班比较远，很潇洒的买了一匹马，相当于我们买车。白公务员还是很懂享受生活的，雇了两个保姆，每月的总支出大约是七千五百钱。白公务员很象蜗居里的海萍，不肯高价租城里的好房子，而是把剩下八千五百钱存起来，一心要买套房。但是存了十年，他也没能买的起长安的房子，白公务员兼诗人的文学功底很高，但是不懂经济，不了解通货膨胀。</p><p>最后白公务员急了，很愤青的说：“你们局级干部在长安炒房子，我处级干部就去周边炒房子。”于是白公务员跑到长安城的卫星城——陕西渭南县，买了套房子，平时在单位蹭房子住，逢假期和周末回渭南的家里跟老婆叉叉呕呕。可见唐朝时处级及以下公务员待遇也就跟我们的都市普通小白领差不多。</p><h2 id="宋代房奴"><a href="#宋代房奴" class="headerlink" title="宋代房奴"></a>宋代房奴</h2><p>关于房奴，也是宋代就有记载。宋代有本书叫《白獭髓》，写的就是房奴生活：“妻孥皆衣蔽跣足……夜则赁被而居。”<br>大意就是所有的存款不够，还借来钱砸在房地产上，不得不节衣缩食还债，别说家里人买新衣服，就连被子都是租的。<br>不知此人炒房后来发财没有，那时买房可都是全款，没有银行贷款一说。</p><h2 id="ZG民主"><a href="#ZG民主" class="headerlink" title="ZG民主"></a>ZG民主</h2><p>只许州官放火，不许百姓点灯，这就是我们的民主</p><h2 id="王安石的青苗法之国家出政策的动机"><a href="#王安石的青苗法之国家出政策的动机" class="headerlink" title="王安石的青苗法之国家出政策的动机"></a>王安石的青苗法之国家出政策的动机</h2><p>关于呼唤国家出政策已达成自己买车买房心愿的空空们，有必要听听王安石变法的故事。</p><p>我国的官僚有几千的当官经验，最不怕的就是新政策，只要是新政策，无论目的是为了民生还是敛财，反正就找到了由头，就有办法敛财，有空子可钻。</p><p>王安石变法的初衷是好的，但是不了解中国的官僚体制，变法让老百姓吃饭都成为了困难，加速了北宋的灭亡。所以盼着出房产税的空空要认真的用脑子想问题，梗着脖子泄愤是没有用处的。</p><p>说说王安石同志的青苗法。</p><p>青苗法，按理说是一项最为民生考虑的政策。</p><p>在百姓青黄不接，缺少粮、钱的时候，让老百姓自己估计当年谷、麦产量，先向官府借钱，谷熟后还给官府，称“青苗钱”。</p><p>青苗法规定把以往为备荒而设的常平仓、广惠仓的钱谷作为本钱。每年分两期，即在需要播种和夏秋未熟的正月和五月，按自愿原则，由农民向政府借贷钱物，收成后加息，随夏秋两税纳官。</p><p>实行青苗法的目的肯定是好的，可以让农民在青黄不接时免受高利贷盘剥、并且让农民不至于在没粮的时候土地被大地主所兼并。同时,让政府获得一大笔“青苗息钱”的收入————单纯为了民生，政府收不到钱的事情王安石同志也不同意。 </p><p>按理说，出了这个政策，农民该欢呼了，zf出面了，农民们不用受地主老财剥削了，很多傻空老农民鸡冻的喊：“还是王领导的政策好啊。”</p><p>地方官员也鸡冻了：“太牛了，发财的机会来了，王领导这人人品虽然不怎么样，但是很给我们挣钱的机会啊。”</p><p>于是，王领导的青苗法一推行下去，完全走样了。</p><p>首先青苗息钱从王领导定的年息二分，本来就挺高的贷款20%利率，比我们房贷可高多了。但是就这个年息二分，在地方一下子变成了半年息二分，年利率高达40%：因为是春季发一次贷款，秋季发一次贷款，所以地方官每半年收回本利，还是按二分收，所以变成了半年息二分，年息四分。到了后来地方官想怎么收怎么收，甚至年息高达百分之几百。</p><p>傻空农民立刻傻眼，说反正自愿的，我不贷还不行吗？接着管地主老财借不行吗？</p><p>zf说了：不行。你贷也得贷，不贷也得贷，于是变成了强制高利贷。</p><p>王领导在推行青苗法的时候，还下了定额，贷款多少那是有任务的。任何朝代推行某个政策，只要涉及到收钱，都是有任务的。</p><p>王领导下达了任务，地方官必须完成，不然要罢官丢脑袋，扣个阻碍变法的帽子可不得了，同时本着无利不早起的伟大思想，不但要完成任务还要层层加码。</p><p>这下，傻空老农民彻底傻了，饭都吃不上了。</p><p>结果是王领导给zf增加了税收，官员闷声大发财，老百姓彻底崩溃。</p><p>所以请呼唤房产税的朋友，好好读一下王安石变法</p><blockquote><p><strong>tjOOSAN:：</strong></p><p>我想 这个 “房产税”出不出。不是什么决策问题吧？</p><p>是我们产权的解释问题！我们产权只有70年，换句话说就是租七十年，地和房子本身还是国家的！那么国家的房产再收税，是不是有点法理不通呢？ 这是 郎咸平说的</p><p>楼主！这个。你让我再次质疑你了</p><p>我其实 很想看进去你的文章！可惜。。。。唉 这成了您的历史秀了~~ 海</p><p><strong>kkndme:：</strong></p><p>连法制国家都不是还提什么法理。</p><p> 拆迁条例是违背宪法的，后来又违背了物权法，但是管用的既不是宪法也不是物权法，而是拆迁条例。一群人说要修改条例，牵扯到利益就没了下文。</p><p>有时间你不妨研究一下，看看我们的政策有多少是违反宪法的。<br>在中国拿法理说事就比较搞笑了</p></blockquote><p>读懂历史</p><p>对自己真没坏处。</p><p>王安石不但动员zf放高利贷。</p><p>还是我国搞中央政采、垄断企业和官倒的先驱。这就是王领导推行的均输法。</p><p>宋初以来，为了供应京城皇室、百官、军队的消费，在东南六路设置发运使，负责督运各地“上供”物质。 　　</p><p>发运司只照章办事，各路丰年物多价贱时不敢多办，歉年物少价贵时却又必须办足。物货运到京城后往往因不合需要而削价抛售，朝廷所需却又要另去搜括。这些做法给富商大贾操纵物价，控制市场，囤积居奇提供了方便。</p><p>王领导希望能够节省劳务费，减少政府的财政支出和减轻人民的负担，就想出了均输法，相当于中央政府采购。 </p><p>于是官府直接做生意，行政机构变成了大型国有垄断企业。</p><p>中石化、中石油、中国移动、电力等大企业的苦大家都吃过。</p><p>垄断企业的低效率，fb，强迫定价，强制消费，这些古今中外都是一样。</p><p>而且老百姓跟官府做生意，必须得上供。zf采购那是要多黑有多黑。<br>紧俏商品，官倒搞双轨制，体制内搞配额，体制外高价卖指标。<br>结果是zf闷声大发财，老百姓直接崩溃。</p><p>王领导的独断专行，刚愎自用还是很为大家所称道的，呵呵</p><p>张居正的一条鞭法从地主阶级的利益出发，反而成功了。</p><p>而王领导从民生的利益出发，搞改革，失败的很惨。</p><p>不能不说，历史是很搞笑的</p><blockquote><p><strong>中年不惑吗：</strong></p><p>符合地主阶级利益的张居正变法？？</p><p>怎么后来张被清算呢？</p><p>封建社会官僚本来就是地主阶级的代言人</p><p><strong>kkndme:：</strong></p><p>张同志的清算不是因为变法，而是把万历同志架空了，比皇帝还牛的首辅能活到寿终正寝已经算是奇迹了，跟他的变法无关。</p><p>这位徐阶先生的得意门生，政治上是青出于蓝的，无懈可击，贪污受贿大概也师承徐阶吧，呵呵</p><p>很多人只对张居正同志是否和太后有一腿感兴趣，呵呵</p><p>张居正通常是以正面形象出现，但是在贪污受贿方面是很有一手的。另一个贪污受贿的正面人物是戚继光。</p><p>我国历朝历代的体制，不搞点潜规则什么事都干不成。</p><p>比如一事无成的海瑞，光赢得了个好名，其实毫无建树。</p><p>关于写青词的严嵩搞掉了正值的夏言，忍耐力超强的徐阶搞掉了老奸巨猾的严嵩，心狠手辣的高拱搞掉了徐阶，而张居正又搞掉了高拱。</p><p>这是各机关、企业学习政治斗争的最好案例啊。</p></blockquote><h2 id="什么是社会公平"><a href="#什么是社会公平" class="headerlink" title="什么是社会公平"></a>什么是社会公平</h2><p>古今中外，任何一次武装革命，无论最终成功还是失败，上位者因为野心的极度膨胀，都变得更加专制。陈胜、李自成、朱元璋、罗伯斯皮尔、斯大林、 ，都是一个个鲜活的例子。</p><p>真正公平的社会并不是均贫富、等贵贱的乌托邦，也不是贵族享有领地少女初夜权的强权社会，而是法制社会，大家在一个完善的法律制度下，享有人身和财产自由，知道什么该做什么不该做，法典之下对于任何人都是平等的，无论是平民还是权贵。</p><p>作为爱好和平，小富即安的我等小民，最愿意看到的是社会的稳定而不是动乱。</p><h2 id="还是有很多有钱人"><a href="#还是有很多有钱人" class="headerlink" title="还是有很多有钱人"></a>还是有很多有钱人</h2><p>说起空空们们不买房是因为没钱，我还真不相信。</p><p>在某二线城市，调控重拳刚出的时候，我赶紧去买房，碰见一个大姐。</p><p>那个大姐很有意思，说从08年底看房，一直觉得房价高，所以坚决不买，结果等到了2010年，一直盼着降，但是调控政策刚一出就心慌了，害怕后面是大暴涨，赶紧把房买了，这位大姐买房是一次性付款。到现在房价涨了30%。</p><h2 id="双轨制之体制内的福利"><a href="#双轨制之体制内的福利" class="headerlink" title="双轨制之体制内的福利"></a>双轨制之体制内的福利</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>水木社区上有很多愤青打电话给北京建委，举报领秀慧谷捂盘内购的事，我跟了个贴子说不要太幼稚，结果被骂的很惨。今天他们接到建委电话了，说是没有违规。我在想：有这些不明真相的群众存在，房价怎么会跌呢？通胀怎么会停呢？股市IPO怎么会停呢？底层不被收割就奇怪了</p><p><strong>kkndme：</strong></p><p>让北京建委去查国资委就比较搞笑。北京的房优先安置各大部委，剩余很少的部分才用于商品房开发，所以才说北京四环房价5万一平都不算贵。</p></blockquote><h2 id="开发商思维"><a href="#开发商思维" class="headerlink" title="开发商思维"></a>开发商思维</h2><blockquote><p><strong>鼻使豆豆：</strong></p><p>高房价不可怕，可怕的是没有辩别是非的能力，明明是老百姓，却有开发商的意识，可悲</p><p><strong>kkndme：</strong></p><p>其实这个道理是很浅显的，你不买房并不能代表房价不涨，而你买了房不但可以住的舒适，还可以获利。反而是有开发商的思维才能有好日子过。</p><p>这个道理跟炒股票是相同的。大家知道，股票与房地产不同，并不能创造财富，只是财富再分配的工具，但是财富再分配，是庄家分配散户的钱，而不是散户分配庄家的钱。所以炒股要有庄家的思维才能挣钱。</p><p>道理都是一样的。</p></blockquote><h2 id="农民政权的缺点"><a href="#农民政权的缺点" class="headerlink" title="农民政权的缺点"></a>农民政权的缺点</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>请问楼主，为什么历史上的农民起义军领袖，一旦得势后比原来的统治阶级还残暴呢？像黄巢，张献忠等等</p><p><strong>kkndme：</strong></p><p>是因为缺乏一个纲领。</p><p>农民伯伯因为没饭吃拿起武器造反了，造反之后怎么办？——对不起，从来没想过。国家治理到底是怎么回事？——对不起，一概不懂。</p><p>比如陈胜，刚占了一块地盘就不知道姓什么了，老子天下第一，农民暴富后，就想拼命享受，自己的属下和革命战友在自己眼中就是一坨屎，就更别说老百姓了。武装还没胜利呢，就生怕别人夺权，大搞内部政治斗争。吴广挂掉最高兴的就是陈胜。太平天国表现的更是淋漓尽致。</p><p>朱元璋就不同，是个军事天才和政治天才，懂得治国之道，有做皇帝的野心，也懂得当皇帝需要的知识，朱清楚的知道靠均贫富等贵贱是不能坐天下的。</p><p>古代能够夺取天下的，基本都是贵族阶层，有野心有理想有知识。最典型的就是李世民。汉高祖刘邦同样不是单纯的流氓无产者，他幸运的娶了吕雉，一跃成为地主家族的一员。</p><p>历史上只有朱元璋是个异数。这也是毛为什么要推崇朱的原因。</p></blockquote><h2 id="郑州有前景"><a href="#郑州有前景" class="headerlink" title="郑州有前景"></a>郑州有前景</h2><blockquote><p><strong>larryzs：</strong></p><p>最喜欢看楼主评说历史了</p><p>呵呵，看来历史要重新好好读一下了</p><p>不知道楼主对河南郑州的房价了解吗？</p><p>希望楼主对郑州将来的发展分析一下。</p><p>现在郑州的房价均价也差不多快到6000了，郑东新区的一万以上。</p><p>市政府也在大力修建地铁，个人认为还是有发展前景的。</p><p><strong>kkndme：</strong></p><p>郑州的交通区位决定了经济发展的空间，同意你的说法，很有前景</p></blockquote><h2 id="公园地产是稀缺资源"><a href="#公园地产是稀缺资源" class="headerlink" title="公园地产是稀缺资源"></a>公园地产是稀缺资源</h2><blockquote><p><strong>klid：</strong></p><p>LZ，省会城市二环边公园边房产和市中心无天然气房产，选择哪个比较好？</p><p><strong>kkndme：</strong></p><p>公园地产未来是稀缺资源，市中心虽好，但是没有天然气毕竟不方便。两者相较还是公园边合适。</p></blockquote><h2 id="张献忠屠川"><a href="#张献忠屠川" class="headerlink" title="张献忠屠川"></a>张献忠屠川</h2><p>关于张献忠屠四川，尽管学术上存在争议，但大致是不差的，虽不见于正史，但《蜀碧》及《求幸福斋随笔》都有记录。很多学者也做了大量的考证。</p><p>张献忠此人曾经读过书，做过zf最基层公务员——捕快，但是被开除了。人格比较扭曲，不但好色，且好杀成性，是典型的流氓无产者。大明的苦难子民指望这样的有严重心理疾病的杀人狂拯救，那是毫无指望的。</p><p>张献忠每攻城略地特别喜欢把当地的妇女同志送进军营当营妓，并且乐此不疲，军队没粮了，就把美丽的少女切成块做成腊肉。把儿童成群的围起来用火烧，谁往外跑就用刀刺，也是张大义军领袖最喜欢的游戏。</p><p>对于张的行为，我们只能用有严重的心理疾病来解释。</p><p>一个仇视社会的愤青，掌握了军队，破坏力是相当可怕的，是人民的灾难。</p><p>张攻陷四川建立大西国政权，与柬埔寨的红色高棉政权简直是异曲同工。以至于清军进入四川受到了百姓的欢迎而不是抵抗。这跟越南入侵柬埔寨，越南军受到了柬埔寨人民的欢迎是多么相似啊。</p><p>人民的眼睛是雪亮的，违反人性的，即使打着爱国的旗号，也终将被人民抛弃。</p><h2 id="洪秀全、黄巢、李自成"><a href="#洪秀全、黄巢、李自成" class="headerlink" title="洪秀全、黄巢、李自成"></a>洪秀全、黄巢、李自成</h2><p>洪秀全同志，人生比较悲剧，人家好歹是个落地秀才。洪教主考了20多年，连个秀才都没考上，相当于小学都没毕业。</p><p>洪教主考试不行，搞邪教确是个高手，夜里做梦居然梦见上帝（形象大概是个白胡子老道）说洪教主是他的二儿子。这个梦确实不太靠谱。很可能是洪教主有意编的。</p><p>洪教主的拜上帝教应该算是白莲教的一支或者说是余孽。</p><p>洪教主搞革命，对解放劳苦大众却一点不感冒，最感兴趣的是一夫多妻制，娶了88个后妃。好像历史上的农民军领袖对妇女同志都有出奇好感，大概是小时候性压抑的结果。</p><p>太平天国攻下南京得了半壁江山，洪教主从41岁开始，直到11年后自杀，竟然没出南京城一步。大概是收罗的漂亮的妇女同志太多了，实在没有时间干别的。</p><p>比起张大义军领袖的变态，洪教主还是比较有人性。好色，人之天性。</p><p>不过洪教主进南京，并没有因为女性的爱情滋润，而让他变得温柔。虽然没有张大领袖变态，实行的也是三光政策：杀光、烧光、抢光。</p><p>“凡掳之人，每视其人之手，如掌心红润，十指无重茧者，恒指为妖，或一见即杀，或问答后杀，或不胜刑掠自承为妖杀，或竞捶楚以死。”大意是手上没长茧子的就是妖人，就要统统杀掉。</p><p>农民起义带来的不是均田地等贵贱的乌托邦，而是血腥恐怖</p><p>说起洪教主玩弄的美女确实让人流口水，除了88个妃子外，女官侍婢不计其数，算下来用了11年时间玩了2300名妇女。</p><p>有一本《江南春梦笔记》：王后娘娘下辖爱娘、嬉娘、妙女、姣女等16个名位共208人；24个王妃名下辖姹女、元女等七个名位共960人，两者共计1169人。以上都属嫔妃，都是要和洪秀全同床共枕的。天王府不设太监，所以另外还有许多服役的“女官”。以二品掌率60人各辖女司20人计算，合计为1200人。各项人数加起来，总计有2300多名妇女在天王府陪侍洪秀全一个人。</p><p>一个农民当了教主，就有这样的眼福。换做了傻空当教主，会怎么做？</p><p>黄巢比洪教主学问要高一些，但是屡试不第，当了私盐贩子。</p><p>从起义的第一天开始，黄巢的脑子里也从来没有过百姓该如何如何的。</p><p>他是一个彻头彻尾的投机分子，说是义军，不如说是强盗。</p><p>新唐书中说，贼军所过州县，老百姓皆烧杀殆尽。黄巢的兵可并不懂三大纪律八项注意，那是能抢救抢，抢不了就烧就杀。</p><p>无论是旧唐书、新唐书、还是资治通鉴，从头到尾，就没有出现过黄巢的一句好话。</p><p>黄巢攻陷广州，至少屠杀了十二万人，把皇帝气晕了。</p><p>皇帝还知道体恤子民呢，而黄巢就是彻头彻尾的强盗外加杀人犯。</p><p>黄巢攻进长安当了天子，充分显现了流氓无产者的本质，穷奢极欲，挥霍无度，治理国家的事彷佛就跟他没有一点关系。不搞建设就只能做吃山空，结果长安的粮食都被糟蹋完了。</p><p>长安没有余粮，黄巢就把长安老百姓抓来，煮着吃，十万大军靠吃老百姓过日子。</p><p>幸好老天开眼，官军打进了长安，结果是老百姓对官军夹道欢迎。<br>农民军真是义军吗？</p><p>不但中国的农民军领袖都是杀人魔鬼的化身，就是法国资产阶级大革命领袖罗伯斯皮尔，同样也是法西斯暴政的先驱者。最后被人民送上了断头台。</p><p>只有一个真正的法制化国家，人民在法律的制约下，享有人身与财产自由，才能够安居乐业。</p><p>李自成在军队纪律上，是要比张献忠高明一点的，所以李自成打进了北京。李自成到北京后，拷贝了黄巢进长安的淫乐经验，对美女极尽淫乱之能事，对百姓烧杀抢劫做的也很出色。</p><p>历代农民军对妇女的态度与《水浒传》中梁山好汉完全相反。</p><p>施耐庵笔下的梁山好汉们似乎对妇女有天生的仇视，动不动就把女同志劈死，李逵甚至终生不尽女色，就凭这一点，我们只能说梁山好汉是农民军中的异类。</p><p>但是梁山好汉不是为了起义，而是为了招安。一群由小公务员和渔民组成的社会最底层群众梦想通过拉山头再跳槽的方式走进金字塔的中层，但是这个梦想破灭了。</p><p>古代历史上，能够治理天下的穷苦人，只有一个：朱元璋。</p><h2 id="朱元璋"><a href="#朱元璋" class="headerlink" title="朱元璋"></a>朱元璋</h2><p>为什么朱元璋可以，而别人不可以。</p><p>经过仔细研究发现，朱元璋的人生际遇不像黄巢、张献忠和李自成，他有点像刘邦，但又有很大区别。</p><p>朱元璋是一个到处要饭吃的和尚，但是喜欢思考，见世面，交朋友，并且找到了自己的宗教信仰——明教（也叫摩尼教、白莲教）。</p><p>朱元璋走投无路投奔起义军的时候，娶了起义军濠州大帅郭子兴的义女当老婆，就是那个著名的马皇后。郭子兴并不是一个农民，而是一个大地主，所以朱元璋加入的这个新家族，思想完全不同一个扛着扁担造反的农民。</p><p>郭子兴作为农民军的统帅，却在逛街的路上，被其他的农民军兄弟（真正的农民）绑了票，大概是因为农民对地主阶级比较仇恨。最后被朱元璋救了出来。</p><p>郭子兴看见朱元璋比自己强，反而起了憎恨之心，一心想把朱元璋弄死。</p><p>朱元璋在丰富的人生经历中看到了农民起义军领袖们的鼠目寸光，要想成大事，必须有远大的理想和抱负，而这些是黄巢、张献忠、李自成、洪秀全都没有的。</p><p>朱元璋与那些个农民军领袖最大的不同在于，他熟读历史，因此他把汉高祖刘邦作为榜样。目标是建立一个基业长青的强大统一的国家。</p><p>朱元璋就懂得无论是得到天下，还是治理天下，就必须有能力的人来辅佐。嫉贤妒能的人只能被历史的车轮碾碎。</p><h2 id="曹参治国"><a href="#曹参治国" class="headerlink" title="曹参治国"></a>曹参治国</h2><p>人们最希望的，就是在一个良好的社会环境下，安居乐业，自食其力。zf的职责就是健全法制，维护一个良好的环境，剩下的事，交给民间去做。三天两头出政策，过度插手百姓如何过日子，甚至朝令夕改，就会让百姓的正常生产生活无所适从。<br>早在汉朝初期，曹参已经参悟了这个道理。<br>曹参是刘邦当亭长时的领导，也是刘邦最亲密的战友。萧何是文官，曹参则是武将，曾经在韩信麾下效力，除了披坚执锐外，最重要的工作就是监视韩信，防止韩大军事家谋反。<br>这样一个万夫难敌的勇将，却在革命胜利后被分配给齐王刘肥（刘邦的私生子）当相国，主抓齐国的政务。</p><p>曹参是一介武夫，只懂得军事，并不懂治理地方，就用厚礼聘请了精通黄老之术的盖公。盖公认为：治理国家很简单，只要按照律法办事，给老百姓提供一个安全的稳定的环境，其他的都不用管，官府千万不要好大喜功，追求政绩，过多插手百姓的事物，顺其自然就好了。<br>曹参很赏识盖公，并且按照盖公的话去做，九年的时间，齐国变得非常繁荣。<br>这时候，传来噩耗，萧何挂了，皇帝刘盈聘请曹参出任相国。曹参上任以后，几乎罢免了所有办事效率高、口才好，有追求有抱负的能吏，提拔了一群只知道按部就班，照章办事的老实巴交的官员，然后就彻底大松心，成天喝酒吃肉听小曲。</p><p>很多人对曹参不满就给皇帝刘盈打小报告，刘盈的表现是很愤怒。<br>曹参就问刘盈：是陛下你牛呢，还是先皇刘邦牛呢？<br>刘盈：当然是先皇牛<br>曹参又问：那我跟萧何比，谁牛呢？<br>刘盈愤怒的说：你比萧何差远了。<br>曹参做了个总结：您讲的太对了，先皇和萧相国拟定的法令已经非常清楚了，只要贯彻执行下去就好，我只要按照他们的法令办，不就行了吗？<br>刘盈虽然不事朝政，但应该算是比较聪明的君主，一听就懂：对于已经定下的治国方针大略，只要执行下去，一定会使人民休养生息，国家富足。如果大搞政绩工程，对于先皇刚死，吕后掌权时期风雨飘摇的大汉来说，将是灾难性的。<br>民间把成天喝酒吃肉听小曲的曹参称为贤相。司马迁在史记中也给了曹参极高的评价。</p><p>假设一个工程队要盖楼房，起初设计人员设计了20层，刚盖了两层，队长换人了，非要盖成30层，工人于是绞尽脑汁费劲办法改造。等盖到25层的时候，又换队长了，新队长说还是改成两层的别墅吧。刚把楼房都拆掉，别墅建了一半，又来了一个队长，说要建成比迪拜塔还高的大塔楼。这个楼建了n年也没建起来。<br>建房子跟治国的道理是一样的，我国汉代的相国曹参就已经明白了这个道理。</p><h2 id="晁错"><a href="#晁错" class="headerlink" title="晁错"></a>晁错</h2><p>刚才有人提到吴楚七国之乱，讲得是晁错。晁错其人是很值得讲讲的，一个有才能的人在错误的时间做了一个理论上正确的事，却导致吴楚七国之乱，汉景帝差点完蛋。结果是景帝砍了晁错的脑袋。</p><p>这个故事，几乎家喻户晓，蕴藏的道理却很深，大家如果懒得看史料，有兴趣可以参看易中天“帝国的惆怅”，还是很值得一看的</p><h2 id="民营小企业的老板和打工者"><a href="#民营小企业的老板和打工者" class="headerlink" title="民营小企业的老板和打工者"></a>民营小企业的老板和打工者</h2><p>糊涂人即使把道理说的再浅显，他也听不明白，呵呵。<br>现在我国已经进入高通胀期，但是地方巨额债务与人民币的升值又封杀了加息的空间，经济形式有可能恶化，民营小企业的老板和打工者只能自求多福了。</p><blockquote><p><strong>汝爱之罪：</strong></p><p>刚查了一下央行的数据，8月份的M2是68.75万亿，我没记错的话，7月份的M2控制的很好，基本没怎么涨，但是到了8月份，没想到有那么猛的涨幅，看来不到12月，我国的M2就要到70万亿了。2007年1月份，我国的货币供应量是35万亿。</p><p>今早去小摊买早点，原来一块五的加鸡蛋灌饼现在卖两块。如果涨工资，只会把通胀越推越高，如果不涨工资，P民就要忍受通胀的剥削。真是无语了</p></blockquote><h2 id="郭解"><a href="#郭解" class="headerlink" title="郭解"></a>郭解</h2><p>从古到今，小老百姓遇到不公，受了委屈，幻想最多的就是跳出一个大侠，劫富济贫，为自己伸张正义。所以金庸的小说广为流传，被称为成年人的童话。<br>我国古代，真有大侠，不过古代的大侠并不是会降龙十八掌的郭靖，也不是小李飞刀，而是黑帮的老大，相当于西方的教父。<br>最有名的大侠叫郭解，汉朝时有极高的威望，不然也不会写进史记。<br>郭解的爸爸是个职业杀手，非常有名，用古龙的话说，最厉害的杀手是没有名字的，郭解的老爸名声太大，注定活不长。有个米商请郭解的老爸到监狱里救出犯了法的儿子，郭老爸看在钱的份上去了，就再也没能回来。</p><p>郭解跟他老爸学过功夫，很有两下子，于是干起了抢劫和盗墓的这份很有前途的职业。因为功夫高，谁只要说句话让他不爱听，必然遭遇一顿暴打。本着流氓会武术谁也挡不住的精神，到了三十岁，郭解已经钱多的数不过来了。男怕入错行，女怕嫁错郎，看来抢劫和盗墓的职业选择对了。<br>30岁以后，郭解为了从强盗升级为教父，开始积累自己的名声，并且学习战国四公子，开始蓄养门客，但凡是哪个人有难，有求必应。俨然形成了一个严密的黑社会组织。在民间的声望，甚至超过了皇帝。<br>皇帝的权威是不容冒犯的，一个地方黑社会头子怎么能够这么嚣张呢？就把郭解抓了起来，虽然有大量的证据证明郭解作奸犯科草菅人命，但都是汉武帝大赦前的事情，没有办法定罪。汉武帝一筹莫展，人抓了不能定罪，又不能放掉，该怎么办呢？<br>这时，正好有个书生，骂郭解不遵纪守法。正巧被郭解的门客听到了，就把那个书生给杀了。<br>汉武帝听了哈哈大笑，正巧找这个理由把郭解灭族。<br>侠客的黄金时代，从此结束</p><p>剑侠情侣，快意江湖，听着是一个充满了浪漫的世界，而事实是完全不可取，一个没有法制的社会，奉行者赤裸裸的丛林法则，什么是对？什么又是错？理由就永远站在强者一边，强者可以随自己的意愿决定弱者的生死。<br>这个社会是可怕的。<br>郭解，就让他永远埋葬吧</p><h2 id="2010年的中国房地产"><a href="#2010年的中国房地产" class="headerlink" title="2010年的中国房地产"></a>2010年的中国房地产</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>今天跟家里人打电话，姨妈说了下近一年来老家云南东北方向一个地级市曲靖的变化。</p><p>主要就是：好些有资金的外地大佬大手笔拿地，开发酒店和商品房。都是市区的黄金地段。</p><p>其实房地产开发在中国的任何一个城市每天都在发生，不过令人感慨的是这样的“四线”城市也如此火爆，购买力之强令人感慨，她说最近几天曲靖正在举行房交会，人头攒动。<br>现在老百姓有钱都向往好的房子和户型了，已经不满足90年代的老旧房子了，而且通货膨胀也逼得大家不得不置业保值。</p><p>再回头看看北京，简直找不到跌的理由。那么多地铁要修，那么多优质生源每年涌向北京高校，那么多人口，每天要造就那么多富人。。。。</p><p><strong>kkndme：</strong></p><p>钱太多了，流动性泛滥，老百姓恐慌了。这次调控暂时抑制了一线城市房价的上涨势头，但是却直接导致了全国性房价的上涨，不光二三线城市，连四级以下城市都是如此。这就是领导水平。</p></blockquote><h2 id="房奴算不上不幸，相当当不了才算"><a href="#房奴算不上不幸，相当当不了才算" class="headerlink" title="房奴算不上不幸，相当当不了才算"></a>房奴算不上不幸，相当当不了才算</h2><p><strong>lanyu1121：</strong></p><p>普通老百姓都成房奴了。</p><p><strong>kkndme：</strong></p><p>成为房奴还算不上不幸，相当房奴当不了才不幸</p><h2 id="精英人群的平均收入决定房价"><a href="#精英人群的平均收入决定房价" class="headerlink" title="精英人群的平均收入决定房价"></a>精英人群的平均收入决定房价</h2><blockquote><p><strong>skysurfer2208：</strong></p><p>想请教一下楼主，对于很多的二线城市，比如武汉，市区房子的均价一万左右了，但当地的平均收入一般也就3000左右吧，难倒你不认为现在的房价里面有泡沫吗？特别是现在正处在调控期，对于我们这些近年打算买房的来说，是在等等看呢还是在在这个时期出手？多谢楼主</p><p><strong>kkndme：</strong></p><p>你所说的平均收入是什么概念？是人人都挣3000块，还是有人挣2000块，有人挣1万块。武汉的房价，要看湖北省包括各地市的人口，家庭收入上万的人有多少，如果你认为很少，几乎没有，那房价肯定存在泡沫。如果湖北省有20%的人口家庭月收入超过万元，那么武汉市区的房价就没有泡沫。</p></blockquote><h2 id="内地不是香港、海南"><a href="#内地不是香港、海南" class="headerlink" title="内地不是香港、海南"></a>内地不是香港、海南</h2><blockquote><p><strong>johny__：</strong></p><p>那香港97年的时候还不是一样跌了一大截，按LZ的说法，1）土地资源很稀缺；2）作为消费群体的白领收入也能买房；3）作为世界城市，更是汇聚了世界级精英的购买力，仿佛现在上海。最后，不是一样大跌？？中产都成了负资产了。就连林百欣的儿子林建岳97年以69亿港元高价购入中环富丽华，还不是赔得一塌糊涂。</p><p>楼价涨高了就要跌，哪都不例外，这个才是规律。什么通涨，精英购买力决定房价，都是涨了之后在找理由。</p><p><strong>kkndme：</strong></p><p>这就是体制上的不同啊，所以我们无法重复香港和日本。97年的金融风暴，还是中国以国家之力对抗索罗斯的量子基金，保住了香港，这种行为在西方国家是难以想象的。一个国家动用全国人民的外汇储备与美国的民间资本打一场战争，这是令全世界震惊的。索罗斯因为不了解中国的体制，悻悻而归。</p><p>人民币不能在世界流通，依照我国实行的货币制度，货币只不过是一种符号。如果有一天我们的人民币能够自由兑换，香港发生的事也一定会发生在我们身上，但你认为我们的人民币能够自由兑换吗？</p><p><strong>johny__：</strong></p><p>那92年的海南崩盘有从何说起？从7000多掉到了几百元，这难道是海南体制？发币行是海南银行？同样是国内，同样的外汇管理制度，不是日本也不是香港，是中国海南。</p><p>–据《中国房地产市场年鉴（1996）》统计，1988年，海南商品房平均价格为1350元&#x2F;平方米，1991年为1400元&#x2F;平方米，1992年猛涨至5000元&#x2F;平方米，1993年达到7500元&#x2F;平方米的顶峰。短短三年，增长超过4倍。</p><p>–海峡对岸的北海，沉淀资金甚至高达200亿元，烂尾楼面积超过了三亚，被称为中国的“泡沫经济博物馆”。</p><p>[经验交流]92年海南房地产泡沫始自于“击鼓传花”(转载)<br><a href="http://www.tianya.cn/publicforum/content/house/1/163988.shtml">http://www.tianya.cn/publicforum/content/house/1/163988.shtml</a></p><p><strong>kkndme：</strong></p><p>全国的资金去炒海南、北海，炒的纯粹是概念，没有实体的支撑，就是一种博傻游戏。今年年初海南房地产的爆炒，同样积聚了巨大的风险。买房并不是全无风险，好比通州、燕郊，经历疯狂的炒作一定会理性的回归。但是如果指望北京四环内房价下跌，也只是痴心妄想。</p><p>房产投资也不是随便买套房就只涨不跌，比如说山东乳山的房子，开发商疯狂炒作旅游地产概念，但如果真的想投资升值，那就成了天大的笑话，因为根本无法变现。</p><p>什么样的房产适合投资，投资者不是傻子，都会有理性的判断。</p><p>90年代初的强硬调控让海南和北海的经济崩盘，对全国来说不可怕，毕竟只是一隅之地，但是如果用粗暴手段搞崩了全国，zf一定会好好掂量的。</p></blockquote><h2 id="历史是一面镜子"><a href="#历史是一面镜子" class="headerlink" title="历史是一面镜子"></a>历史是一面镜子</h2><p>如果以为本帖讲的历史故事，那就完全理解错了。</p><p>本帖讲得不是历史，而是总结前人的经验，讲得是故事背后的道理。<br>如果毛不是熟读历史，也不可能取得胜利。毛在进京的时候，说过一句话：我们不学李自成。</p><p>只有认真总结过李自成失败的教训，才能够做出正确的选择。</p><h2 id="买房一次性到位比较好"><a href="#买房一次性到位比较好" class="headerlink" title="买房一次性到位比较好"></a>买房一次性到位比较好</h2><blockquote><p><strong>包容会通：</strong></p><p>我老婆是长春人,岳父母退休,都有退休金.我和我老婆现在都在国外,准备3年以后回长春工作,我们现在有40万的现金,放在银行也没什么用,也担心3年以后,长春的房价还要涨.</p><p>因此,现在准备用其中的20万作首付买套70平的小户型的,让岳父母住(岳父母有住房,但很快就要拆迁了).等3年以后回长春,把这套小的卖了换成大的.不知这样的计划是否可行?贷款如何弄?<br>　　　　　　　　<br>谢谢兄弟.</p><p><strong>kkndme：</strong></p><p>既然是自住型需求，何不买套大点的，70平（建筑面积）的房子无论是自住、父母住还是合住，都比较拥挤。既然有40万的闲钱，还是一次到位比较好，3年后长春的房价一定要比现在高的多。</p><p>只是贷款比较麻烦，你的父母是无法贷款的，除非你们夫妻能够回国，这种事用别人的名字办肯定是不行的，房价上涨后就有可能会陷入扯皮甚至打官司的境地。</p></blockquote><h2 id="外汇管制"><a href="#外汇管制" class="headerlink" title="外汇管制"></a>外汇管制</h2><blockquote><p><strong>tianxiaobing11：</strong></p><p>楼主，这个tj连人民币不能自由兑换都不知道，可见他的水平也太差了，就不用和他计较了，从上个月开始人民币换美圆好象收紧了，是怕民众把人民币换美圆出逃吗？</p><p><strong>kkndme：</strong></p><p>外汇外流趋势比较严重，zf开始严管，包括携带50美元以上商品入境必须征税等措施，都是限制外汇外流。富人从穷人身上赚了钱，换成美元在国外消费，这是zf不愿意看到的，zf不在意富人搜刮穷人，但肉一定要烂在锅里</p></blockquote><h2 id="一线和二线"><a href="#一线和二线" class="headerlink" title="一线和二线"></a>一线和二线</h2><blockquote><p><strong>yamazaki28：</strong></p><p>楼主好，小弟有问题请教，本人所在二线省会城市，存款40w,近来看中本市CBD区域高端住住宅一套，各方面条件十分优越，面积100左右，均价18000。但通过观察，又看中觉得北京五环附近的待建地铁房，均价16000，想贷款弄小户型60左右，不知哪个升值潜力大，本人已有房一套。谢楼主指点。</p><p><strong>kkndme：</strong></p><p>短期来看，二三线城市的房产升值速度要高于北京，这是这次调控造成的结果，从长期来看，北京房产的升值速度要高于二三线城市。五环附近地铁房，还是很有优势的。</p></blockquote><h2 id="吕后篡权"><a href="#吕后篡权" class="headerlink" title="吕后篡权"></a>吕后篡权</h2><p>大凡是60年代末，70年代初生人，小时候肯定看过一本小人书：吕后篡权。<br>在那个时代推出这本书，很有寓意，起到了很好的宣传效果。<br>吕后真的是十恶不赦的妖妇吗？让我们还原历史的真相。<br>我们读到的吕雉，通常的形象是蛇蝎心肠的女强人。<br>大家感兴趣的，首先是关于吕雉在项羽大营和审食其是否有一腿。<br>然后看到的是吕雉协助刘邦诛杀异性王、与倾国倾城的戚夫人争宠、帮助儿子刘盈与戚夫人的儿子刘如意争夺太子、杀害戚夫人和刘如意、提拔吕氏家族成员。<br>但是因为宣传的需要，几乎所有人都忽略了吕雉的另一面</p><p>刘邦见上帝以后，吕雉掌权期间，对待老百姓还是很够意思的。<br>俗话说嫁出的女就是泼出去的水。吕雉可不同，吕雉非常照顾自己的娘家人，想把自己的娘家人都提拔起来。<br>秦始皇把分封制改成郡县制，搞天下大一统，意识比较超前，结果政权不稳定，秦朝很短时间就完蛋了。高祖刘邦吸取了这个教训，仍然搞分封制，不过分封制做了重大的改革:首先是分封的诸侯王必须是皇族，也就是说必须姓刘。其次是从中央派丞相给诸侯王，丞相掌握诸侯国的军政大权，防止生变。<br>吕雉提拔娘家干部最大的障碍就是：高祖说过，诸侯王只能姓刘。</p><p>吕雉是一个极其精明的女人，她追尊自己的老爹吕公为宣王，吕公是刘邦的老岳父，追尊皇帝的老岳父，旁人自不能有异议。既然有了先例，剩下的事就好办了，吕雉趁机把自己吕姓家族的成员封为吕王。<br>吕王吕嘉这个人很嚣张，仗着外戚的身份，飞扬跋扈，不尊法纪。<br>吕雉是一个出色的国家领导人，不是黄巢李自成之类的强盗流民，是很关心民生的，所以很生气，把吕嘉给废了，让吕嘉的叔叔吕产当吕王。<br>吕雉掌权后，做了很多亲民的好事，减免老百姓的税赋，加强建设健康的人民文化娱乐，最受百姓欢迎的是废除了“三族罪”和“妖言令”。<br>三族罪的意思很直白，就是一人犯罪株连三族。<br>妖言令有点象后来的文字狱，哪里出现统治者认为的妖言，就把那个地方的所有百姓全部处死。这是一个伟大的历史进步。<br>吕雉还是女权运动的先驱者，在吕雉时代，女子也可以封官封侯，可以随意离婚再嫁。那个时代是中国古代史上，女人最幸福的时代之一。<br>吕雉，一个柔弱的女子，在残酷的宫廷政治斗争中表现的异常凶狠，然而权力的斗争本身就是你死我活，在治国方面，吕雉却无愧于一个贤明的统治者，可谓巾帼不让须眉。吕雉与后来的老佛爷完全就不是一个等级，毫无可比性。<br>吕雉执掌朝政十五年，直到病死后，吕氏家族才土崩瓦解。<br>还原真实的历史，我们不应该对这位叱诧风云的女政治家，致以深深的敬意吗？</p><h2 id="小产权房"><a href="#小产权房" class="headerlink" title="小产权房"></a>小产权房</h2><blockquote><p><strong>大水牛跟水牛仔：</strong></p><p>楼主,可以谈谈小产权房的看法吗?父母是珠海的原居民且拥有两套小产权房,无房产证只有村里所发的使用证,是村委会卖给原居民的,离市中心约半小时车程,近河边,而一路之隔的位置己建有大型高尚住宅小区,在售价一万二以上,请问这些小产权房可靠吗?听说往后政府对这些小产权房采取放宽政策,只需补一点钱就可改成商品房,你觉得有可能吗?</p><p><strong>kkndme：</strong></p><p>这个补点钱就改商品房的可能性不大，如果是大片的小产权房，拆的可能性也不大。这个问题很让zf头痛，城乡双轨制的结果，所以zf能拖就拖。</p><p>但是对于片区不大的小产权房，风险就很大</p><p><strong>大水牛跟水牛仔：</strong></p><p>谢谢楼主回复,父母手上的两套小产权房在同一小区,小区比较大,这类小区有好几个,由于村内将进行旧村改造,规划成高级住宅片区,那此类小产权房如遭迁拆的话会得到赔偿吗?</p><p><strong>kkndme：</strong></p><p>这个会比较扯皮，最坏的情况是按照原价退赔，最好的情况是回迁安置。如果原价退赔损失就很大。</p></blockquote><h2 id="商铺和住宅"><a href="#商铺和住宅" class="headerlink" title="商铺和住宅"></a>商铺和住宅</h2><blockquote><p><strong>deeplp：</strong></p><p>kkndme 兄，你好。</p><p>从这个帖子一开始就一只跟着，每天必看。受益良多。</p><p>你对广州感觉如何？请教一个问题，不知你对商铺是否有研究？你觉得眼下投资商铺好呢，还是继续投资房产。<br>本人已有2套房产，都在广州市区且近地铁但不带很好学位。现有如下两个想法，</p><ol><li>分散投资，投资一个商铺，目前看中一个广州北京路拐弯处二楼商铺一个，靠近地铁。</li><li>继续房产，买一个130以上大户型且带学位房，方便以后小孩读书。（计划明年要小孩，现在就做打算是怕以后买不起阿。）<br>麻烦兄台给些意见。十分感谢。</li></ol><p><strong>kkndme：</strong></p><p>找到合适的商铺是很难的，因为商铺投资风险大，所以非常考验个人的眼光，属于高风险高回报，找对了，将财源滚滚，找错了很可能血本无归。<br>如果你有眼光，首选商铺。如果不具备这方面的能力投资住宅比较保险。</p></blockquote><h2 id="体制内外"><a href="#体制内外" class="headerlink" title="体制内外"></a>体制内外</h2><blockquote><p><strong>tuzi1976：</strong></p><p>kkndme兄，你好。上周提了几个问题，可能你没看到，再请教一次，请抽空指点一二。<br>看到楼主说过“人民币对外是升值，对内贬值”，我认识到“人民币对外是升值，对内贬值”这一点也有一年多了吧，主要是从生活经历、经济新闻中得到的结论（本人学工科、不懂经济）。虽然看到了表面现象，但对其发生的根本原因、对群众生活的深刻影响、“中产阶级（勉强算是有这么个阶级）”的应对之策等等尚没有深刻的认识。楼主看到我提的这些问题恐怕也觉得范围太大、难以回答？难道体制外的“中产阶级”只有任人宰割、移民海外、钻营往上爬这几个选择？诚心求教，风险自担（呵呵，楼主也不是神仙）</p><p><strong>kkndme：</strong></p><p>普天之下莫非王土，决定了今天的土地国有<br>万般皆下品，也决定了以后知识分子的前途必须进入体制内。<br>不能考中进士的明清两代知识分子，即使经商发了大财，也一样让人看不起，不能光宗耀祖。今天的知识分子将面临同样的命运。<br>体制外，凭个人的本事和运气，自生自灭。</p></blockquote><h2 id="2010年的上海"><a href="#2010年的上海" class="headerlink" title="2010年的上海"></a>2010年的上海</h2><blockquote><p><strong>youme5845：</strong></p><p>看到LZ的帖子真是太及时了！因为要解决小孩子上学，我最近开始密集型的看房子.</p><p>感慨房价高的同时后悔没有早点考虑买房。头痛啊！！！</p><p>说说我们的情况：目前现金40W,家庭收入1W5,住上海，目前看的房子为周边世纪公园地铁10分钟老公房(新房很少)，81P 190W,地段很好，但房子都是95年左右的了。算下来除了首付家里帮助外每个月供5K还30年(扣除公积金还款),我们现在可以出手么？还是等十一新政策出来后买？</p><p>还是在交通稍微不便的地方买低价的房子？</p><p>请LZ给个意见~ 在线等~<br>多谢！！！！</p><p><strong>kkndme：</strong></p><p>月供5k,收入1万5，说明的你的压力不大，完全可以承受。如果地段好，可以不考虑房子的新旧。一线城市的买房时机最不好拿捏，因为一线城市是调控的目标，你要仔细观察，如果发现中介的铺面里看房客越来越多，建议赶紧下手。</p><p><strong>youme5845：</strong></p><p>多谢！！！ 那我最近关注多一些！<br>还有这块小区同时是学区房，是否可以买个100W出头的出租，然后自己租房住(我们长期租住房租很便宜 1700两室户)，这样即使以后出现金融危机等情况也不会担太大风险，是这样么？</p><p><strong>kkndme：</strong></p><p>对自己好一点的就会自己住，对钱看的比较重，可以买房出租，自己租便宜的。因人的性格而已。<br>不过人生苦短，在短短的有生之年，还是要对自己好一点。自己买的房子住起来跟租房子的感觉是完全不同的。</p></blockquote><h2 id="收紧住房贷款"><a href="#收紧住房贷款" class="headerlink" title="收紧住房贷款"></a>收紧住房贷款</h2><blockquote><p><strong>welldayzwb：</strong></p><p>顶楼主，越读越觉得受益良多<br>楼主分析一下，最近几年一线城市是否会一直收紧贷款，想改善住房是否也得必须全款了？一想起这个就很郁闷，去年机会没利用好，后面不仅仅是经济成本的问题了，又面临和无房空空类似的问题，攒钱永远赶不上房价了。。。</p><p><strong>kkndme：</strong></p><p>收紧住房贷款起码在未来的一段时间会成为常态。由于货币泛滥，一次性付款的人群数量庞大，收紧贷款虽然不能降低房价，但可以抑制房价上涨的速度，防止商品房卖给穷人，以规避金融风险，对社会稳定和经济平稳增长都是有利的。</p></blockquote><h2 id="买房：物业与房贷"><a href="#买房：物业与房贷" class="headerlink" title="买房：物业与房贷"></a>买房：物业与房贷</h2><blockquote><p><strong>fallenleafe：</strong></p><p>关注本贴多日，非常欣赏楼主的睿智和理性。<br>小女子也是上海众多买房人之一，目前所谓单身剩女，得家人支持有一百五十万的首付金。基本确定买在内环交通方便的次新房（老公房停车太成问题）。<br>对上海浦西内环内的诸多区位和楼盘做过研究，发现离地铁近的同时能有苏州河景观的房源最具性价比，满足交通性和景观稀缺性的双重优势（上海内环内几乎没什么安静同时又具有自然资源的地方）。<br>现在基本确定了两个小区，比较纠结的问题有两个。<br>第一个问题，一个是小区管理和区位优势明显单价在3万3左右，另一个区位和管理比较差，名声不好，但是面苏州河的独一无二景观，单价在3万左右。从小区管理的角度，我也认可楼主的看法，管理好的小区升值空间大，管理差的小区由于群租问题严重，目前价格偏低，但是这个软件问题在日后随着自住率的提高貌似也能解决。究竟我该选一个景观资源非常稀缺的管理和配套相对较差的小区，还是一个相对成熟价格稍高同时综合配套比较好的小区？那个小区比较有保值和投资优势？<br>第二个问题，目前的月收入税后刚过万元，如果拿150万的首付买一房大概80平左右，是比较轻松的，月供不成问题（目前租的一室一厅租金3500，已经可以做为还贷资金了）。但是考虑长远问题和一些小户型的局限性，非常想投资一套能长久居住的两房甚至三房（众所周知，一个小区里好的位置总是留给最大的户型）。这样的话，大概一套就要在320万甚至350万，我需要每月还贷1万2左右，基本和我的月工资持平。从个人观点来看，我比较想冒这个风险，比较合适的做法是首付降低到3成左右，留出三十万左右的还贷资金用以应付前面两至三年的还贷。由于目前单身，两至三年后也许家庭收入就可以完全承受这个月供。即使还是单身，目前事业发展良好，对2年后的收入在2万以上很有信心，因此还是认为可以目前阶段多点勇气，目光长远，以保证日后生活安康。<br>不知道楼主怎么看这个问题？如果是房价持续上涨的情况，也许更该相信我的工资也会持续上涨，是否我看问题太乐观？贷款200万的风险是不是会太大？</p><p><strong>kkndme：</strong></p><p>第一个问题：物业管理对于小区的价值起着至关重要的作用，好的物业管理才能让人居住舒适，这一点是非常重要的。软件的提升往往比硬件的提升难度更大。物业很差的景观楼盘，可以比喻为鲜花丛中的一坨屎，周边环境再好，它也是一坨屎。一坨屎能否脱胎换骨变成黄金，存在着较大的不确定性。<br>第二个问题：是否承受较高月供，取决于你对未来的预期，所以你要仔细分析你的行业前途，如果你所处的行业告诉成长，或者你的能力职位将得到进一步提升，你可以承受较高的月供。<br>一般来说月供不要超过全部收入的70%，如果超过这个边际，就会有较大风险。</p></blockquote><h2 id="奸臣蔡京"><a href="#奸臣蔡京" class="headerlink" title="奸臣蔡京"></a>奸臣蔡京</h2><p>现代的纸币发行成本很低，拿着印钞机印就是了。古代就没那么好办，金银的开采量是有限的，别说金银，就是铸铜钱用的铜，也不是想要多少就有多少。</p><p>古代要想制造通货膨胀，最绝的办法就是拿一个铜钱当十个铜钱花，叫做当十大钱。搞当十大钱，扰乱货币秩序的领导，最有名的就是蔡京。</p><p>蔡京这个名字并不陌生，不爱读历史的人也一定看过水浒传。就是这个领导，被宋史称为六贼之首。大家一提起他，就自然把他跟奸臣划了等号，恨不得在他脸上踹几脚。</p><p>蔡京的确是个奸臣，但很多人可能不知道的是：蔡京是王安石的最得力干将，他的很多祸国殃民的政策，竟然是源于恢复王安石的变法。</p><p>王安石可以说是一个品德高尚的人，但是变法的流毒，竟直接导致了北宋的灭亡。王安石是一个在历史上有争议的任务，但是他的得力骨干蔡京同志，却是不折不扣的奸臣。</p><p>蔡京领导的罪恶，大家一致公认的就是那么几条<br>第一、花石纲，水浒传有精彩的描述，这个纯属于皇帝的个人爱好，似乎都推到蔡领导身上比较冤枉。<br>第二、大兴土木，大搞基础设施建设拉动内需，顺便搜刮点民财，以至于百姓怨愤<br>第三、恢复王安石时期的方田法，并且更改盐法茶法，国库和官员一起大肆搜刮民财，与民争利，结果租税混乱，富人把负担全部转嫁给穷人，穷苦百姓的负担更加沉重。<br>第四、就是当十大钱，制造通货膨胀，严重扰乱金融秩序和金融安全，北宋的经济崩溃了<br>蔡京，一个王安石变法的坚定执行者，最后成为祸国殃民的奸贼。</p><p>关于蔡京的奸臣形象，到了现在，有人企图为他翻案。但终究声音比较弱小。<br>因为在中国的古代，肆意敛财、大兴土木、搞官商垄断，与民争利，以至于人民不堪重负的领导，都被称为奸臣。对于减轻人民赋税，不胡乱插手民间生产和贸易，让人民修养生息的，被称为贤臣。<br>中国的古代，奸臣远远多于贤臣。</p><h2 id="体制内的28原则"><a href="#体制内的28原则" class="headerlink" title="体制内的28原则"></a>体制内的28原则</h2><blockquote><p><strong>facetowall：</strong></p><p>有人说，高校里20%的人掌握着80%的资源和财源，本人深有同感。所以经常想怎样才能成为20%里面的人。每天也很努力工作着，科研教学也可以，但是总看不到希望。</p><p><strong>kkndme：</strong></p><p>从一个小吏变成中高级干部，是需要深入研究中国古代政治斗争史的。否则就变成了宋江，企图另立山头通过跳槽达到目的，最终的结果只能是失败。宋江是一个政治上的白痴。</p><p>还有一个白痴叫贾谊，我们所熟知的“过秦论”的作者，才高八斗，政治却很白痴。被文帝做了棋子。如果贾谊同志知道晁错的下场，是无论如何不会仗着有才胡说八道，口无遮拦的</p></blockquote><h2 id="贾谊"><a href="#贾谊" class="headerlink" title="贾谊"></a>贾谊</h2><p>贾谊的粉墨登场，是有很深的政治大背景的。<br>首先要从吕雉死翘翘，以陈平、周勃为首的功臣集团铲出了吕氏一党说起。<br>吕氏一党灰飞烟灭，小皇帝是个吕雉制造出来的傀儡，甚至跟高祖刘邦都没有任何血缘关系。<br>难题是让谁当皇帝呢？<br>于是中国历史上最为搞笑的一幕发生了，在高祖刘邦的子孙中要搞最弱外戚选举。</p><p>大概是被吕雉专权搞怕了，大家推举皇帝，专门看哪个皇子的外戚弱。于是众人的目光投向了刘邦的第四个儿子，代王刘恒。原因是刘恒的母亲薄氏出身低微，为人又很低调，堪当最弱外戚之名望。<br>提起薄氏，野史里记载的很香艳，很可以拍三级片</p><p>野史里说，楚汉争霸时期，高祖刘邦大败。<br>薄氏还是个姑娘的时候叫薄姬，逃难的时候占领了一个无人居住的民宅。忽然有一天看见一个浑身是血，穿着盔甲拿着兵器的男人闯进了自己的屋子，这个人就是刘邦。<br>薄姬听到后面有追兵，就把刘邦的盔甲和兵器藏了起来。然后放了一大桶洗澡水，把自己和刘邦脱光光，洗起了鸳鸯浴。追兵闯了进来，惊奇的看了一通三级片，然后走人。<br>这个只是野史，可信度不高，但是说明了薄氏的低微出身。</p><p>不管怎麽说，有着最弱外戚称号，并且做事很低调的刘恒当了皇帝。但是对于刘恒来说，陈平、周勃等功臣集团有着很高的声望，齐王刘襄是高祖长孙并且在铲除吕党是很有功劳，声望也很高，受到了很多人的支持，而刘恒却毫无功劳，因为功臣集团平衡关系，天上掉下了皇帝的帽子，砸在自己脑袋上。<br>所以刘恒必须提拔自己人，这个人不能有很高的功劳，也不能有结党的嫌疑，最好比较有本事能治理国家，于是大才子贾谊粉墨登场了</p><p>贾谊同志很有口才，一腔热血，要到现在来说最适合搞传销或者卖保险。<br>贾谊同志激愤起来甚至说：自己完全可以带兵打仗，灭了匈奴，把匈奴王象狗一样牵回来。”刘恒很贤德，但也很老谋深算，当然认为贾谊同志满嘴喷粪，所以一笑置之。<br>贾谊同志的胆子不是一般的大，向皇帝刘恒提供了一个深的帝心的建议：让所有的诸侯王滚回自己的封地。<br>为什么说这是深得帝心的建议？因为朝里功劳大的人太多，居功自傲，而自己却没有什么威望和功绩，如果功臣集团和齐王、淮南王联合起来造反怎么办？<br>所以，最好的办法就是让诸侯王滚回封地。汉代的诸侯王可跟周朝不同，周朝的诸侯王是有实权的，有自己的军队。而汉代的诸侯王只能收收领地的税，军政事务全说了不算。<br>这个事，从贾谊嘴里说出来最好不过。</p><p>汉代的京城是最繁华的，有全国最好的教育、医疗、商业，有钱人的天堂，大臣们都可以花天酒地。让诸侯王回到封地，大家都不干了，回封地有什么好？房价又低，又没什么娱乐，漂亮姑娘也不好找，偏远的地方气候还不好，梅雨一来全身都要发霉。<br>首先带头反对的是功臣集团的领袖周勃（陈平已经死翘翘了）。在历朝历代，多数皇帝并不是想干什么就干什么的。既然所有大臣都反对，那就先暂且作罢。<br>但是贾谊，已经为刘恒种下了希望的种子，给自己埋下了祸根。<br>贾谊注定了只能是一颗棋子。</p><p>贾谊的建议没有被采纳，估计很郁闷，成天滔滔不绝的演讲，甚至建议刘恒削藩，要是贾谊知道晁错的下场，一定不敢这么建议。<br>这时候，贾谊已经得罪光了朝中几乎所有的大臣。于是大家的不满全部转移到贾谊的身上。<br>刘恒要的就是这个效果。</p><p>随着政权的逐渐稳固，刘恒把矛头指向了周勃。给予周勃最高的赏赐，却经常在治理国家方面，询问一些周勃不可能知道的问题。让周勃很尴尬。<br>周勃有个门客，就对周勃说：“皇帝经常给你很多赏赐，您就安心的接受，这很危险。皇帝给你的赏赐越多，说明皇帝对您越不放心啊。”<br>功高震主，弄不好会有杀身之祸，周勃不是傻子，立刻明白了这个道理。所以周勃才能称的上除曹参外，最有政治头脑的武将，最后得了善终。<br>于是周勃就上表辞职，表示年老体病干不动了。周勃还期望皇帝能挽留一下，但皇帝一点挽留的意思都没有，立刻同意了。<br>刘恒让周勃起个带头作用，回到自己的封地去吧。并且赐予了大把的金银。其他诸侯王看周勃都走了，也扛不住了，只好都回到了封地，这叫射人先射马，擒贼先擒王。<br>刘恒为了安抚大家，把遭人恨的贾谊明升暗降，贬到了长沙，从此离开了政治中心。<br>后来有一天，刘恒想起了贾谊，找他来中央谈话。贾谊一见皇帝立刻滔滔不绝，把皇帝立马侃晕了。<br>刘恒想：我靠，这厮死不悔改，留着没用，有多远滚多远吧。<br>再次把贾谊贬到了梁国。<br>贾谊不多久就死了。</p><p>关于魏豹和薄姬是否有一腿，也不好就肯定，也是个悬疑。因为记载薄姬的版本太多，我国古代人也比较八卦，呵呵。</p><h2 id="kkndme-推荐的历史书"><a href="#kkndme-推荐的历史书" class="headerlink" title="kkndme 推荐的历史书"></a>kkndme 推荐的历史书</h2><blockquote><p><strong>welldayzwb：</strong></p><p>这个帖子最大的感受就是应该认真读一下历史了，麻烦楼主给列个入门级的书单，鉴于我的历史水平只有演艺级的，书单请尽量入门级，当然演绎过的就免了，别读历史还别人顺带洗脑，比较郁闷了</p><p>先再次表示感谢！</p><p><strong>kkndme：</strong></p><p>比较浅显的是“史记”，入门级基本都读的懂。如果开始觉得部头太大，觉得累，刚开始可以从“古文观止”入门。逐渐增加难度。<br>入门以后，很多古文就好读了。<br>现代翻译的一般都加工的比较多，同一部历史可能有无数个解释。象易中天和当年明月，都是写的不错的。</p><p>关于古文观止，很多文章都曾被节选进中小学课本，篇篇堪称经典，其中就包括贾谊的“过秦论”。不看过秦论真的不知道贾谊的才华呀。所以想读读历史的童鞋，不妨回过头再温习温习古文观止，边品茶边看，真是一种享受。</p><p><strong>EchoMa9999：</strong></p><p>楼主晚上好！<br>我看之前有跟贴的朋友提过，请楼主列个史书入门级的书单，我不求列了很多书的书单，只请楼主推荐三本，佛渡有缘人，楼主，望不吝赐书名，先谢了！</p><p><strong>kkndme：</strong></p><p>我觉得读史最基本的就是古文观止，读了古文观止，有了功底，再读其他的就好读了。<br>开始读的时候，通史类是很难看得进去的，象“资治通鉴类”的也不好读，因为“资治通鉴”应当算评史算不上史书。<br>入门开读的话还是选择文学性强的比较好读，故事性趣味性都高，比如“史记”“三国志”“汉书”。<br>有了兴趣再读大部头的“宋史”“明史”<br>现代编写的中国史纲之类的就不要读了，纯粹洗脑，很多加工过的历史类读物就是瞎扯。</p><p>特别是： 千万不要读“中国通史”那样的垃圾!!!!!!!!</p><p>一定要读懂原文，跟中国通史讲得完全不是一回事。读不懂原文宁可不读，也不要让中国通史洗脑。</p><p><strong>打工不易：</strong></p><p>请问楼主，范文澜的《中国通史》也不值一读吗？</p><p><strong>kkndme：</strong></p><p>从始至终以唯物主义角度阐述的历史，可信度究竟有多高？</p><p>唯物主义要很深的理解，比如子虚乌有的抢渡大渡河，就是唯物主义的杰作。</p><p>范对封建社会的理解，也很有问题，是唯物主义的需要，不能还原历史的真实</p><p><strong>welldayzwb：</strong></p><p>这个唯物主义的定义是什么？</p><p><strong>kkndme：</strong></p><p>我只能用唯物主义这个词，再直白就和谐了，呵呵</p><p>我们的历史教科书很多都出自中国通史，但是你真正熟读了史官的著作以后，发现那有多扯，歪曲的有点太不靠谱。中国通史我把它定义成政治类书籍，是政治需要产生的，专门用于洗脑，不能当史书读。</p><p><strong>EchoMa9999：</strong></p><p>楼主，简单研究了一下古文观止&#x2F;三国志&#x2F;汉书&#x2F;后汉书&#x2F;史记，古文观止，以目前的水平，看起来着实吃力，决定还是先从史记开始看起吧</p><p>淘宝上搜了一下，史记 （全四册），北方文艺出版社出版，2007年9月1号出版的，萧枫主编，绣像本，盒装， 这个版本的买来自读加收藏，可以吗？请楼主点评，谢谢！</p><p><strong>kkndme：</strong></p><p>古文观止可以买带注解的，但不要带译文的，看译文对读原文是有害的，可以通过注解提高古文水平。</p><p>史记买太好的版本，我是舍不得拿出来读，不能勾勾画画，我一定会把它高束焉,庋藏焉。读史记，最好买个普通本，带注解的，方便阅读，可边读边勾画，以提高阅读水平。</p></blockquote><h2 id="年轻人要早买房"><a href="#年轻人要早买房" class="headerlink" title="年轻人要早买房"></a>年轻人要早买房</h2><blockquote><p><strong>GGKMM：</strong></p><p>看了三天，终于看完了。。有些是一眼带过的，有些是比较认真的看下来的；</p><p>感觉回帖的筒子大多数都挺有钱的啊，至少相对我来说。因为都在计划一二百万的房子了。</p><p>本人在福州，目前月薪只有4K，但是福州市区的房产均价已经越过一万了，市中心的更是到了1.5万这样高不可及的地步。我就那楼主口中那种民企私企的体制外的P民了，属于自生自灭型的。但也还是得活下去啊，今年也二十五了，过两年也要结婚了。房子成为不可避免的头等大事；</p><p>不知道楼主对福州这样一个三线或者四线城市的房产怎么看待？平均工资水平约2000，有钱人据自己观察应该不少，至少超过20%的福州人口（有关这个，从大街上越来越多的好车做判断的，或许数字不准，但有钱人不少是肯定的）。如果在郊区能找到六千左右的小户型（65平左右），首付（还得存两年或者去借钱）自己掏，剩下的做货款，因为家里实在是没办法再支援了。这样的话应该还可承受，前提是付房贷的这二十年或者十五年里不失业。。</p><p>希望楼主给分析分析，写得有点乱。。。</p><p><strong>kkndme：</strong></p><p>25岁不是考虑失业的年龄，35岁体制外没有混出来的群众才应该考虑失业问题。<br>所以房子一定要趁年轻买，刚开始钱不够，就不要计较太多，先买个小的，以后有能力再换，如果没混出来，以后起码有个自己的窝住。不至于租房子被人赶出来。</p><p>福州是有点尴尬，明明是省会，又比不过厦门，不过市区1万左右的房价，在省会城市里真的谈不上高。你是自住，你又不打算去厦门生活，所以你该买还是得买。福州的房价也许涨得没那么块，但是也不可能跌。</p></blockquote><h2 id="不要低估通货膨胀"><a href="#不要低估通货膨胀" class="headerlink" title="不要低估通货膨胀"></a>不要低估通货膨胀</h2><blockquote><p><strong>someway2010：</strong></p><p>跟楼主请教一下：<br>楼主怎么看知春里小区的房子？那边连着双榆树小区，有大片的老房子，都是6层的板楼，都是上世纪8、90年代建的。环境看起来有点乱，以前的老公房，原单位早就没了，物业基本等于没有。将来拆迁的可能性有多大？值得买不？</p><p><strong>kkndme:：</strong></p><p>只要是4环内保值升值不会有问题，那个位置还是可以。关键是看投资还是自住，如果是自住，我就觉得那边有点乱糟糟的，不舒服。挨着中关村其实住着都不舒服，但不耽误升值。</p><p><strong>someway2010：</strong></p><p>多谢楼主，是自住<del>因为老公在中关村上班，想离公司近些，所以就挑了那里</del>是挺乱的，唉~<br>希望以后等我们有钱了能换个别的地方的大房子，不过按照楼主的分析这个是极有可能实现不了了。。。5555~~~~~~<br>再问一个，现在市场上卖200w的房子，十年后大概会涨到多少钱？麻烦楼主</p><p><strong>kkndme:：</strong></p><p>80年代你想象不出以后一瓶茅台会卖1000块<br>现在你同样想象不出十年后你的房子能卖多少钱。<br>那时也许人民币都是1000块一张的</p></blockquote><h2 id="二三线城市与重庆"><a href="#二三线城市与重庆" class="headerlink" title="二三线城市与重庆"></a>二三线城市与重庆</h2><blockquote><p><strong>dali_05：</strong></p><p>浏览了楼主观点，和我之前的货币推动楼市的看法完全一致<br>但由于无法像楼主那样掌握一些基础数据，对一些楼市的演变细节还有几个疑问</p><p>，还请lz指点<br>（1）二三线城市在这轮调控中的增长不出意料，但是二三线城市的房价增长，我始终认为存在一个最终谁接盘的问题。我是重庆人，以重庆为例，这个城市代表了典型的二三线城市。外来人口少，特别是外来的普通白领阶层。据我了解的数据，2008年之前，重庆的具备房子购买力的人群任然是净流出。到08年后才得以改观。但是流入任然缓慢，这也就是意味着重庆的楼市将没有长期稳定的接盘群体。而本地人，没有房子的是非常少的。在没有外来人群接盘的情况下，本地人在有房的情况下，任然投资囤积房产，最终，这些房产将如何变现。</p><p>一句话，房价要持续的上涨，还得有没房者接盘，而且这些人还得要有购买力。多次购房者无法稳定的解决这个问题。那么我就有理由对这样的二三线城市的房产前景表示担忧。</p><p><strong>kkndme：</strong></p><p>重庆房价的上涨得益于zy的战略规划，打造中国的大后方，把重庆的经济发展提升到了政治的高度。因为如果发生战争，重庆将变成第二首都，是中国最安全的大后方，蒋同志就很有眼光的选择过重庆。<br>重庆并不是以城中心为核心向外辐射的城市，繁华区域相对比较分散，所以房价很难快速上涨。这也就是过去重庆长期滞涨的原因。<br>重庆房价的崛起可以说完全是中央规划概念推动的，至于日后是否会吸引大量的精英和富人来重庆发展，我想一定可以。作为上升到国家政治高度的发展计划，就算是代价再大，也一定会搞得起来。</p><p><strong>dali_05：</strong></p><p>（2）高端房产还是普通住宅？<br>看了lz的观点，认为高端房产，由于其稀缺性，更具价值。<br>但我认为，房产和古玩还是存在差别的。古玩最大的价值在于收藏把玩，只要有钱，买再多古玩来玩都无所谓。但是房产不一样，房产的价值除了和古玩一样的投资外，真正的功能在于居住。但是目前的二三线城市，精英阶层的数量是非常有限的，他们谁没个3，5套别墅，在没有外来精英加入购买的前提下，这些高端的房产也就是在精英圈子中流转，这样封闭的流转，如何实现价值的增长呢？</p><p>要知道，在2，3线城市，普通白领阶层能跳出自己的阶层而具备购买高端房产能力的概率是非常小的，不具有代表性。那这些每个富人，有权人都有很多的高端房产有什么价值可言？</p><p>而普通住宅由于有普通白领的接盘，是否投资价值更大？</p><p><strong>kkndme：</strong></p><p>二三线城市房价的支撑，要因城市而异的，大体上二三线城市的核心区域与高端住宅区都不会有问题。毕竟一线城市的体量，不可能满足全国中产以上群体定居，而且一线城市随着竞争的日益激烈，钱也不是那么好赚的。有很大比例的富裕人群仍会选择二三线城市生活。<br>中国的二三线城市的富裕人口，要比大家想象的多的多，特别是二三线城市，有相当比例的人口都有较高的隐性收入，权力寻租现象更为严重。</p><p><strong>dali_05：</strong></p><p>（3）长期持有房产的变数<br>中国房产只有70年，甚至50年的使用权，如果长期持有，随着时间推移，房产价值是否会受到影响。因为我在重庆，这个问题尤其严重，重庆只有50年。</p><p>如果我只是持有，出租。那我的租金将是较低的（相对房价而言），因为zf不会允许房租像房价那样疯涨，原因和粮食问题一样，基本需求嘛。那有可能50年到了，我的房租收益实际上还抵不上房款的综合支出。而那时房子早就是危房了，强拆将是完全可能的情况。那做为普通人，怎么可能和zf在赔偿上博弈。这个风险lz是怎么理解的？？</p><p>我的理解是，房子不能长期持有，必须在5年左右变现，否则将存在贬值和变现难度加大的风险，请lz指点</p><p><strong>kkndme：</strong></p><p>关于中国的房产能够持有多少年的问题，这要持续观察zf的动向。对于现在的80后来说，如果在有生之年能够平安度过，不经历大的动乱，已经是很值得庆幸了。<br>如果有动乱发生，即使你没有买房，你手中的现金也将变成废纸。</p><p><strong>dali_05：</strong></p><p>（4）天津现象（或者即将出现的重庆现象）<br>天津房价在二线城市中增长是惊人的，但收入水平并没有达到那样的高度。这种依靠所谓开发区吸引资金推动房价的模式，是否具备可持续性？？</p><p>我认为真正的天津常住精英阶层的资金实力是无法支撑这样的价格的，只能理解是外来游资的介入，推高了价格。<br>我想问的是，这些游资有可能退去吗，一旦退去，面临的风险是否很大。</p><p>据我的理解，中国真正成功的开发区，都是由于本身的条件好，而非开发区本身的作用。</p><p>比如深圳，享受的是经济转型的首发政策优势。上海浦东是由于本身就实力雄厚。而所谓的滨海新区，重庆两江新区，本身实力就不过如此，即使要真正实力上来，那也将是非常漫长的过程。那这些进入房地产的游资，将在概念炒作一遍之后，获得一定收益后撤出，一旦撤出，这些地区的房价将会是怎样的趋势？</p><p>放眼中国，房价高的地方无不是富人集中，或周边富人多的区域。天津重庆这样的地方，一旦外地资金撤出，将何去何从？</p><p>（5）新兴城区和老核心城区<br>新兴城区环境好，轨道交通也使得原本偏远的新兴城区变得方便起来。那老核心城区的房产是否不如这样的新兴城区有价值。这个问题一直很困惑。因为我是重庆人，这个问题尤其明显。现在重庆房价最高的是以前的郊区，江北，渝北。而传统的渝中，房价反而排着中等水平。这和北京的一二环贵，上海的黄埔徐汇贵完全不同。这样的状况具备可持续性吗，还是仅仅是阶段性的。但是感觉现在zf的规划更倾向于向外发展，避免主城区拆迁的高成本，这会否导致传统主城区的边缘化</p><p>先问这几个问题，困惑很久了，期待lz的高论</p></blockquote><h2 id="城区和郊区"><a href="#城区和郊区" class="headerlink" title="城区和郊区"></a>城区和郊区</h2><blockquote><p><strong>hey-hey：</strong></p><p>楼主 我在上海， 小白领一枚。最近想买房。稍微好点的区均价已经至少2万5+了， 现在考虑在其他价格洼地的区买套新房，看中了均价1万7左右，买90送30，到手面积120左右。此楼盘开发建造定位2万&#x2F;米以上，因政策调控，故现1万7。好处是小区规划不错，属大型国企房产公司，2012年交房。附近有超大型公园，地铁明年开通（升值利好），附近有医院，学校，路上看到的在建建筑较多（百废待兴）。不好处是离上班开车要1个小时，属工业区（在另外一个方向），路上集卡较多，有传空气质量不好。 </p><p>另外一个选择是在市中心或其他比较好的区买个小房子，大概5、60平方米左右，预算也是180万左右。 好处是地段好，租金回报可能较高。如果自住相对比较方便。</p><p>单身，买房投资愿望大于自住愿望。 请楼主给分析分析。谢谢</p><p><strong>kkndme：</strong></p><p>多数人买房子都是郊区买个大的，后来上班实在不方便，再想办法城里买套小的。住郊区牺牲时间，住城里牺牲面积。总得来说，还是住城里更方便些。<br>关于房价升值，一定是郊区和城区版块轮动的。当郊区房价较低时，资金就会关注价值洼地，当郊区房价炒起来以后，城区的房价跟着上涨，但总的来说，城区的房价涨幅一定高于郊区，且比郊区更抗跌。</p><p><strong>hey-hey：</strong></p><p>谢谢楼主。真是纠结阿。一样的钱想买个新点的。而且周边的觉着还有这样那样的优势，比如公园，比如现在的性价比。比如大了一倍。比如该区未来发展空间和前途。如路建好了地铁修好了，城市辐射发展的面扩展了。<br>市区现在虽然完善，但未来没什么发展空间，该发展的都饱和了该配套的都配好了。升值的空间是否相对就小了。 </p><p>还请楼主再给说说。</p><p><strong>kkndme：</strong></p><p>你说的其实还是性价比的问题，比如郊区（前提是配套能发展的起来）1万7，城区2万5，那肯定是选择城区，毕竟相差不大。如果郊区1万7，城区3万以上，那肯定选择郊区。<br>好比北京的通州，城区2万的时候，通州8000，肯定选择通州，升值会快。但城区3万，通州2万5的时候，肯定会选城区。</p></blockquote><h2 id="守着金碗要饭吃"><a href="#守着金碗要饭吃" class="headerlink" title="守着金碗要饭吃"></a>守着金碗要饭吃</h2><p>守着金碗要饭吃，最典型的就是老一辈玩田黄寿山石的，收藏了一屋子石头，穷了大半辈子，第一次参加石头交易会，居然发现自己随便拿块石头出来能卖上千万。</p><h2 id="人制的社会，人就是制度"><a href="#人制的社会，人就是制度" class="headerlink" title="人制的社会，人就是制度"></a>人制的社会，人就是制度</h2><p>让李荣融来讲垄断巨头的功劳，这个事很有意思。</p><p>西汉时期，功臣集团和他们的后人势力比较大，大街上瞎晃的黑社会头子比较多，皇帝提倡以法治国，靠法律来制约功臣集团，先是重用了皇宫守大门出身的张释之大法官。<br>张法官完全按法律办事，该杀头的绝不会流放，但是该流放的也绝不会杀头。张大法官实现了我国历代百姓追求的天下无冤民的梦想。<br>史书上记录：汉文帝车驾过中渭桥，一个人从桥底下突然钻出来把皇帝的御马惊了，刘恒很生气，让张法官治他的罪。张法官审讯后发现是个意外，属于民事事件，打算罚点钱放掉。刘恒不干了，那可是惊了圣驾呀。罪该杀头。张法官却认为：律条上没有说因意外惊了圣驾就必须杀头，按律条就应该罚钱放人。要不然陛下你就不要把这个人交给我审，直接杀掉算了。既然陛下让我审，就必须按法律办事。刘恒只好按照张法官的审判结果，放掉了那个人。<br>其实，遵守法律，按照法律办事的不仅仅是张法官，而是刘恒自己。刘恒为了保证社会安定、基业长青，就必须限制特权阶层，限制特权阶层就必须依法治国。<br>但是文景之后，武帝就不满足于完全依法办事的张释之法官这样的人了，而是开始重用酷吏，张汤、义纵、宁成这些新一代法官登上了历史舞台。法律是什么？法律就是张汤，张汤就是法律，犯了法的要往死理打，没犯法的也要往死里打。<br>唐朝武则天时期，出现了一个史无前例的酷吏：来俊臣。<br>来俊臣法官不管法律专搞冤狱，专门养了一大群打手无赖，凡是武则天不喜欢的人，还有他自己不喜欢的人，一律刑讯逼供，屈打成招。发明的酷刑比张汤有过之而无不及。<br>古代，法律是什么？是皇帝？是张释之？是张汤? 是来俊臣？其实，法律什么都不是。</p><h2 id="准公务员的好处"><a href="#准公务员的好处" class="headerlink" title="准公务员的好处"></a>准公务员的好处</h2><blockquote><p><strong>xufangliang1120：</strong></p><p>楼主，请问新进公务员队伍的人员今后还会不会有住房福利。像年纪大的都有分房或定向开发的商品房，已经分过了。象新进来的，工资不高，每月不到2000，平时无任何待遇，过年也就发个千来快意思意思。我在湖南常德，这里的房价也在4000左右，今年涨起来的。象我们这种情况要怎么办才好？请您指教！！谢谢！</p><p><strong>kkndme：</strong></p><p>大哥，公务员也是有级别的，想想宋江为什么上梁山呢？<br>你要是在重要部门，或者到了级别自然就有了。<br>西汉的张释之，冯唐、郅都都是皇宫守大门的出身。皇宫看大门的，不算是公务员，是体制外编外人员，相当于协管员，连工资都不发，但为什么大家都趋之若鹜的争当皇宫传达室老大爷这种有前途的职业？因为，可以有机会见到皇上，有机会成为高级公务员。当上了高级公务员，你就有了票子房子妹子。</p></blockquote><p>最著名的皇宫传达室看门老大爷叫冯唐，头发都白了还在未央宫值班呢。皇帝刘恒没事瞎溜达，看见老大爷一脑袋白头发，就叫过来神侃。不侃则已，一侃才知道冯大爷的爷爷是赵国的官帅将，跟大名鼎鼎的名将李牧是哥们。而且冯大爷不愧是名将之后，太懂带兵打仗的道道了。<br>刘恒说：我要是能有李牧这样的大将，还怕什么匈奴啊。<br>冯唐很牛叉的说：就是有李牧这样的大将，也得不到重用。<br>冯大爷直接把皇帝气晕，皇帝转身就走了。<br>后来刘恒气消了，又找冯大爷问话。<br>冯大爷就说了一番大道理：<br>对待将士，要以激励为主，才能得到将士拼死效力的心。重惩罚，轻奖励，光拿大棒不掏胡萝卜，将士怎么肯用命呢？（皇帝是信奉法家的，法家的精神领袖商鞅同志认为管理手下最高境界就是基本不怎么用胡萝卜，直接用大棒的最牛——罚九赏一。）<br>云中太守魏尚是个名将，让匈奴文风丧胆。魏尚的手下都是农民子弟，魏尚对待士兵很好，很舍得犒劳，也和舍得给钱，所以大家都很拼命。但是陛下您经常因为军兵的一点小错误，就扣掉军兵的赏赐，因为魏尚虚报了几个斩获的首级数量，就把魏尚抓起来关监狱，奖励太轻，而惩罚太重了。所以说陛下有李牧这样的良将也不能重用。<br>刘恒大悟，拜冯大爷为车骑都尉。<br>唐代的王勃，很不得志，于是写了《秋日登洪府滕王阁饯别序》:“嗟乎!时运不齐，命途多舛;冯唐易老,李广难封。” 冯大爷一下子因为王勃的文学作品，家喻户晓了。</p><h2 id="小城市房价会因为人民币贬值涨价，但依然难变现"><a href="#小城市房价会因为人民币贬值涨价，但依然难变现" class="headerlink" title="小城市房价会因为人民币贬值涨价，但依然难变现"></a>小城市房价会因为人民币贬值涨价，但依然难变现</h2><blockquote><p><strong>xufangliang1120：</strong></p><p>楼主,谢谢您的回复!<br>你您怎么看常德的房价呢,那我们现在还是想点办法先买房?</p><p><strong>kkndme：</strong></p><p>买一套自住房还是应该的，不是所有公务员都能够上位，也不是所有公务员能够分到房子，特别是二线以上城市，将来普通的底层公务员住公租房的可能性更大。</p><p>对于小城市，房价也会因为人民币的贬值而上涨，只是可能不如大城市好变现而已。所以，有能力还是应该买一套自住房的。</p></blockquote><h2 id="一线杭州"><a href="#一线杭州" class="headerlink" title="一线杭州"></a>一线杭州</h2><blockquote><p><strong>钱江风帆：</strong></p><p>看了个通宵啊，不知楼主对杭州了不了解，目前市区大概25000&#x2F;m2,杭州未来房价的趋势如何？</p><p><strong>kkndme：</strong></p><p>杭州我都当一线城市看的，你就当一线城市理解。富人的天堂，房价多高都不稀奇</p></blockquote><h2 id="二三线城市的发展靠拆迁"><a href="#二三线城市的发展靠拆迁" class="headerlink" title="二三线城市的发展靠拆迁"></a>二三线城市的发展靠拆迁</h2><blockquote><p><strong>dali_05：</strong></p><p>支持楼主房价大涨房租必涨的观点</p><p>但是这仅限于外来人口众多的一线城市<br>二三线城市本地人几乎没有没房的，如果算上父母的，将来普遍一个家庭拥有两套以上的房子<br>房租也就失去了大涨的基础<br>唯一可导致房租上涨的就是拆迁，一旦便宜的旧房子少了，房租肯定是要上调的<br>但那也是有限的<br>总之，外来人口极其可支配收入是房租的决定性因素</p><p><strong>kkndme：</strong></p><p>二三线城市的敛财和追求政绩方式，全靠大规模拆迁，城市搞升级改造，这个拆迁规模是一线城市市民难以想象的。有的城市已经搞得如火如荼了，有的城市还没开始，但都会走这一步。</p></blockquote><h2 id="转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”"><a href="#转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”" class="headerlink" title="转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”"></a>转篇文章：一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”</h2><p><strong>中年不惑吗：</strong></p><p>一个忽悠了几亿中国人的伪概念-所谓“中国房地产泡沫”</p><p>作者：罗伯特卡帕</p><p>中国大陆大家目前最为关心，讨论最为热烈的一个问题就是中国的房地产泡沫问题。从政府到民间，从经济专家到普通百姓，大家都在关注这个问题。以前，我也觉得中国存在一个叫“中国房地产泡沫”的所谓概念，但今天我忽然感悟，原来多少年来包括我在内的几亿中国人都被蒙骗了，中国根本就不存在所谓“房地产泡沫”的问题，“房地产泡沫”这个概念本身就是一个伪概念。</p><p>如同市场经济一样，房地产泡沫也是一个外来事物，它是市场经济的产物。但问题是，中国是市场经济吗？显然不是，否则为什么大多数西方国家都不承认中国是一个市场经济国家。尤其是中国大陆的房地产市场，更不是市场经济，而是计划经济与市场经济相结合的一个怪物，政府操纵着房地产行业，政府对房地产有着绝对的掌控能力。</p><p>房地产泡沫是市场经济的产物，既然是泡沫，那么这个泡沫也会遵循市场经济的规律，即当泡沫足够大的时候，会破裂。因为日本与美国的经济是市场经济，所以当日本与美国的房地产产生泡沫的时候，就会破裂。</p><p>目前包括中国在内的几乎所有世界经济学家都以为，当年日本与美国的房地产泡沫破裂了，中国的房地产泡沫比日美大几倍，当然也会破裂。事实却是，中国的房地产泡沫在几年年前的膨胀程度就超过了当年日本与美国的房地产泡沫，中国的泡沫几年来虽然翻倍，但却没有破裂，这是何故？显然，经济学家们犯了一个错误，那就是把中国的房地产乃至中国经济当成了市场经济来看待，而事实是中国的房地产市场根本不是市场经济。所以，西方市场经济国家所有的房地产泡沫，在中国也根本不存在，所谓的“中国房地产泡沫”根本就是一个伪概念。</p><p>当然，我说到这里时，肯定有很多人不服气，中国的房地产明明几年之内翻了很多倍，远远超过了普通人的收入水平，这不是泡沫这是什么？我的回答是，中国的房地产价格确实虚高，远远超过普通人的收入水平，这是事实，但这不是“房地产泡沫”，因为泡沫会破，而中国的这个被大家称为“泡沫”的东西却不会破，因为它的真实名字其实不叫泡沫，应该叫“变相的税收”或者“房地产垄断价格”。</p><p>中国的房地产业本质上已经不是一种行业，像中国大陆的税收与垄断行业的垄断价格一样，成了少数人剥夺多数人财富的一种工具。在这个工具上，寄生着很多食利者。这个食物链的最上层为地方政府，地方政府通过卖地与房地产税收，养着一大批高薪的公务员及满足他们的奢侈需求。食物链的第二层为与官员勾结的房地产商以及受贿吃回扣的官员，第三层是炒房者，炒房者相当部分为拥有大量现金的官员及家属。</p><p>市场经济的泡沫会破裂的，但中国的房地产不是市场经济，房地产价格也不是“泡沫”，所以它也不会破裂。中国的房地产价格被政府严格操控着，不说是操控自如，也是有绝对的控制力。因为政府掌控着土地银行汇率等房地产的关键要素。中国的高税收是泡沫吗？中国的垄断行业的高垄断价格如水价电价油价是泡沫吗？当然不是，他们是转移财富的手段。中国的房地产价格也是一种变相的“税收与垄断价格”，其“税率”与“垄断价格”是政府控制的。这也解释了为何中国几年来房价如此之高，却不下跌，所谓“泡沫”却不破裂的原因。</p><p>中国房地产的所谓“泡沫”会“破裂”吗？会，只要政府愿意。中国的房地产的“泡沫”会不破裂吗？会，只要政府愿意。</p><p>其实，中国所有的问题都是政治问题，而不是经济问题，离开政治谈经济，永远找不到问题的答案。</p><h2 id="拆迁补偿"><a href="#拆迁补偿" class="headerlink" title="拆迁补偿"></a>拆迁补偿</h2><p>拆迁补偿的两种方式：1、现金补偿；2、回迁安置。<br>在二三线及以下城市，通常采用第二种，因为多数开发商没有钱现金补偿，房地产开发基本上是靠zf关系，空手套白狼，就是有钱也不愿意拿出来。<br>对于拆迁户来说，现金补偿也不划算，因为补偿的现金在与原地同级别的位置肯定是买不了相同面积的住房的，所以多数拆迁户选择回迁安置。<br>但是越小的城市开发新盘的速度越慢，往往回迁房盖个三五年也不见得盖得起来。在这期间，开发商会按月补偿拆迁户一定的租金，用于过渡。<br>手里现金多的拆迁户会先买房住，慢慢等拆迁，但是现金不多的拆迁户，就不得不拿着开发商的过渡款租房住。通常这笔过渡款都要高于相同位置的租金，所以拆迁户就把房租炒起来了。</p><p>北京已经没有原地回迁的说法了，一线城市，还有部分较发达的二线城市都不搞原地回迁了，土著一旦拆迁了就赶到郊区。反而是二、三线城市，特别是三线以下城市多数还在搞原地回迁。主要原因是城市小，住户多多少少都有些背景，特别是单位的老公房，开发商不让原地回迁，根本就拆不动，阻力太大。</p><p>房子从拆到迁是有时间的，快的情况是1年多，但很多情况都是拆迁安置房3,4年盖不起来。比如昆明的莲花池片区，大概是06年左右拆迁的，但拆迁安置房现在才开始动工，2012年才盖的起来。这种事情并不是个案。<br>贵州更离谱，房子04年拆了就再也没有音讯，开发商一直盖不起来，到现在都6年了。原来的拆迁户，现在还在租房住。</p><h2 id="城市底层"><a href="#城市底层" class="headerlink" title="城市底层"></a>城市底层</h2><blockquote><p><strong>游泳横渡马六甲：</strong></p><p>经常有人说收入是决定因素，其实人均收入没有意义。北京姑娘去外企做前台一个月2000，和公司外地姑娘拿这么多，和做公务员的外地姑娘拿这些，生活成本天差地远。不是说有10万个月入2000的外来人口，四环内就有一万处他们能承受的住房。而个体的外来人口的支出，会随着生活成本调整。开始很难理解月入两三千的白领在北京市如何生活，毕竟他们不可能像楼下卖蔬菜水果的大叔那样，炖点猪肉粉条就算开荤，穿特价五块的汗衫就算工作服。一样的月入，白领的幸福起点高得多。后来知道他们原先偶尔用兰蔻改成一直用大宝，早餐不再喝豆浆，住单位附近的搬到五环外，有人在燕郊买了房……突然想起小时候学新概念英语，说起蓝领工资比白领高，但还有人为了能西装革履宁可减薪做白领。</p><p>对80后而言，最恐怖的绝不是房价，而是养老。这也不是计生的问题，一个社会的生活资源是有限的，老龄化早晚会到来，为了改变老龄化呼吁多生育，那是饮鸩止渴。等多生出来这部分老了，再这么循环？而福利社会如英国是50多岁的人最幸福，有稳定养老金，二三十岁最痛苦，看不到未来依靠。家底不厚的像希腊，透支做社会福利，后果还不如不做。中国则是取不足以奉有余，竭全民之力供特权阶层挥霍，没有哪个年龄段享受过全民福利，还得共同面对养老难题。房子，真不算此生最纠结的事</p><p><strong>kkndme：</strong></p><p>正是如此，以后城市的底层吃饭都是问题，zf最喜欢拿房子说事转移矛盾</p></blockquote><h2 id="垄断企业"><a href="#垄断企业" class="headerlink" title="垄断企业"></a>垄断企业</h2><p>我们的垄断企业其实都是第二税务局的角色，比如石油、移动、电力、水务、地产、银行等等。zf一定要掏空百姓的钱包，所以说什么泡沫不泡沫，就是个笑话</p><h2 id="农村自来水"><a href="#农村自来水" class="headerlink" title="农村自来水"></a>农村自来水</h2><p>说起农村建自来水更搞笑，亲眼目睹要不然真不敢相信。<br>贵州有个村子，以前，自来水是村子集体出钱买的管子，然后全村出劳力从山上接下来（用的山泉水），要是水管坏了，大家再摊钱摊劳动力修。<br>结果zf不愿意了，说他们修的不规范，zf给重新修，还是从山泉引水下来，zf包给工程队换了一下管子，然后每户给按了水表，安好了以后，要按照2块钱一吨收费，全村都炸了窝了，集体抗议，现在还没有结果。</p><h2 id="袁盎"><a href="#袁盎" class="headerlink" title="袁盎"></a>袁盎</h2><p>丛林社会就是要承认人与人之间的差别，性格决定命运。<br>我要讲一个奇人，这个人叫袁盎。故事的出处是《史记·袁盎晁错列传》，如果鸡冻同志认为我瞎编，可以自己去看原文。</p><p>袁盎同志的神奇是一般人都无法想象的，这个奇人在吴国当相国的时候，他手下的一个小公务员跟老袁同志的爱妾乱搞，经常背着老袁嘿咻嘿咻。老袁知道了这个事就装聋作哑。<br>有人跟那个小公务员说:坏了，你跟袁领导的二奶私通的事让袁领导知道了，你死定了。<br>小公务员一听吓坏了，骑了马就跑，公务员这份全世界最令人羡慕的工作也不要了。<br>小公务员一跑，袁领导就使劲追，小公务员就更拼命跑，袁领导就更拼命追。袁领导的马要好一点，跑的快，终于把小公务员追上了。小公务员只好下马等死。<br>袁领导急了，对小公务员说：你跑什么呀？我正打算把我的二奶送给你。兄弟如手足，妻子如衣服。大概就是这个意思。<br>小公务员感激涕零，抱着袁领导的二奶继续嘿咻。<br>所以说老袁这人最仗义，人缘最好。上下都买他的帐。</p><p>老袁也有个把敌人。老袁在皇宫里当小跟班的时候，得罪了汉文帝宠爱的一个太监叫赵谈的，所以特别害怕，怕赵太监哪天找茬把自己给黑了。<br>老袁征求了侄子的意见，认为自己应该先下手为强，应该当众侮辱一下赵太监，这样如果赵太监再黑自己，就没人信了，别人都以为是公报私仇。老袁的政治手腕还是相当高的。<br>一天，文帝刘恒跟找太监坐在一辆车子里外出，老袁上前拦住车子，大义凛然的说：能够跟天子共乘一车的，都是天下豪杰，天子怎么能跟一个没小鸡鸡的人坐一辆车呢？<br>赵太监当场就气哭了，还不能说什么。以后赵太监要黑老袁，也没那么容易了，因为大家都知道老袁义正言辞，充满正义的得罪了赵太监，如果赵太监再说老袁坏话，就是公报私仇。</p><p>老袁的人缘是公认的好，但是在朝里有一个最大的敌人，就是大名鼎鼎的晁错。<br>晁错这个人学的是商鞅之术，法家的代表人物。为人冷酷，不讲人情，人缘特别差。老袁和晁错关系不好，可能跟两个人的性格很有关系。<br>晁错跟贾谊很有一拼，特别喜欢喷，口才也特别好，跟贾谊同志喷的内容也差不多，一会儿说打匈奴其实很简单啦，一会儿说必须削藩啦。刘恒听晁错喷的很有水平，很欣赏，但是刘恒不是傻子。<br>打匈奴？那得是国力强大以后的事，现在必须让老百姓修养生息。<br>削藩？我也想削藩，但是总得有合适时机才行啊，现在削藩不是逼人造反吗？<br>刘恒对晁错这种人的态度就是，你建议你的，我听听就可以了，不能当真。</p><p>晁错同志懂得要想发达，必须选择一个有前途的职业，所以凭着他气死保险推销员的口才，当上太子的老师。这个太子就是汉景帝刘启。<br>晁错的时代终于来了，原因是刘恒挂掉了。<br>刘启生下来就是锦衣玉食，可没他老子那两下子，也不怎么懂帝王之术，晁错说什么就是什么。<br>晁错于是抖起来了，不知姓什么了，仗着是皇帝的老师，飞扬跋扈，人缘极差。晁老师最爱追求政绩，立刻提出削藩。<br>削藩的结果就是吴楚七国反了。<br>这个故事跟明代朱允文同志的削藩如出一辙。明朝朱允文同志削藩的结果就是朱棣反了，当了皇帝。朱允文被迫流浪，泡吉普赛美眉去了。<br>吴王不是朱棣，性格有点象袁绍，生性多疑，手下有人才不会用，所以没能成大事，被周亚夫跟干掉了。如果吴王能有朱棣的本事，汉朝的历史就会改写。</p><p>吴王一反，老袁就着急了。老袁给吴国当过相国，吴王造了反，晁错必然要借机宰了老袁，老袁觉得自己冤枉啊，吴王造反不是你晁错逼的吗？<br>晁错果然趁机对老袁打击报复，安排了两个手下去弹劾老袁。但是晁错的人缘实在太差了，老袁的人缘实在太好了，那两个手下竟然不同意弹劾老袁。而且还劝晁错,大意是：现在七国兵马造反了，形式很危急，我们还搞内斗就不好了。老袁这个人是不可能参与谋反的。<br>晁错也着急叛乱的事，就把老袁放一边了。政治斗争，不是你死就是我活。<br>晁错错了，赔进了自己的老命。<br>窦婴同学也曾经在吴国当过相国，立刻跟老袁站在了一条战线上，准备给晁错来个致命一击。<br>晁错这个人的死，完全是他自己性格造成的，对人苛刻，政治上又是白痴。吴楚七国打着“诛晁错，清君侧”的名义造反，皇帝问晁错应该怎么办?<br>晁错的白痴精神充分发挥了出来，“陛下您御驾亲征，臣留守长安，做好看家的工作。”<br>皇帝估计当时心里要多愤怒有多愤怒。你自己惹的祸，你一个当臣子的在家躲起来，让我当天子的上去当炮灰，你是何居心? 不过刘启涵养好，没说出来。<br>这时候老袁跑了进来，说有平乱之计，要单独跟皇帝说。刘启很不客气的就把晁老师请了出去。<br>老袁立刻献计，既然反叛打着清君侧的名义，就先把晁老师宰了，叛军就出师无名了，就得不到老百姓的响应，事情就好办了。<br>刘启一听挺高兴，正恨晁老师让自己当炮灰的事呢，立刻同意，腰斩晁错。<br>晁错的下场要比贾谊惨多了。</p><p>不过老袁的下场也并不好。皇帝的老妈想让皇帝的弟弟梁王在刘启驾崩后继承皇帝这份工作，但是老袁不同意，坚决表示反对，得罪了梁王。<br>梁王不是一般的高级公务员，最喜欢搞黑社会，找了杀手把老袁干掉了。<br>这个故事又告诉我们，即使人缘再好，在政治斗争中活下来也是不容易的。</p><blockquote><p><strong>welldayzwb：</strong></p><p>最好把历史故事表达的直白的意思讲出来，不排除观众里像我这么愚钝的人不少</p><p><strong>kkndme：</strong></p><p>我说的不是袁盎也不是晁错，说的是削藩，皇帝削藩怎么样？看看朱允文的下场，晁错几乎独揽了大权，削藩的下场是什么？腰斩。清查空置率，zf不参与一级开发，不是扯淡吗？</p></blockquote><h2 id="二三线城市，选新城还是老城"><a href="#二三线城市，选新城还是老城" class="headerlink" title="二三线城市，选新城还是老城"></a>二三线城市，选新城还是老城</h2><blockquote><p><strong>wofuleyumin1：</strong></p><p>楼主 我又有问题了。。。。请务必回答 谢谢</p><p>1。目前很多城市开发新城 我们主要谈二三线城市吧。。。这些地方的新城会超越老城吗？ 我们投资该投新城还是老城？</p><p>比如成都 南边的天府新城，口号国际城南。。</p><p>2。投资一定投越靠市中心越好吗？ 比如成都，西三环是比东二环还好。。但未来2环是否最终比3环好？</p><p><strong>kkndme：</strong></p><p>拆迁是块硬骨头，不够铁腕的领导会避开破旧但繁华的老城区的问题，转而开发新城，所以往往形成倒挂，即新城一下子变成了新贵聚居区，新城的房价甚至高过老城区。 但这是一种倒挂，老城升级改造是必然的一步棋，只是时间的早晚。未来老城区的升级改造，老城区的价值就会凸显，价格要远远高于新城。</p><p>但是老城区的多数老房子都可能面临拆迁，投资老城区的老房子不见得划算，特别是二三线城市的拆迁，离皇帝越远的城市，争取合理补偿越困难。</p></blockquote><h2 id="在中国，普通人手上闲钱不多的人被剥削"><a href="#在中国，普通人手上闲钱不多的人被剥削" class="headerlink" title="在中国，普通人手上闲钱不多的人被剥削"></a>在中国，普通人手上闲钱不多的人被剥削</h2><blockquote><p><strong>抽着雪茄喝着绿茶：</strong></p><p>兰州，我近来盛干人民币的贬值力度之强烈<br>现在手上还有十万的盈余<br>做什么好呢<br>咬紧牙关供一套房？买黄金？还是买车呢？<br>总之不能空放着，<br>这样通货膨胀下去，汽车的价格也会涨吗？</p><p><strong>kkndme：</strong></p><p>买车是消费，不是投资，如果追求享受，可以买车，但不能保值增值。汽车属于工业品，通过扩大生产规模可以使边际成本下降，所以汽车会因为档次的不同有涨有跌。<br>黄金可以适当配置，但由于黄金的定价权不在国内，所以买黄金有一定的风险。<br>十几万买房子估计不够首付，除非特别小的城市。但小城市的房产变现起来比较麻烦。<br>至于古玩字画茅台酒之类的，真假难辨，不是专家很难参与投资，且一般人变现还是很困难的。<br>所以资金越小，资金实现保值增值越困难。我国实行的高通胀低利率政策，是对手中闲钱不多的普通群众赤裸裸的剥削。而手中闲钱较多的中产阶层，相对好一点，可以投资住宅商铺进行保值增值。</p></blockquote><h2 id="三分天注定，七分靠打拼"><a href="#三分天注定，七分靠打拼" class="headerlink" title="三分天注定，七分靠打拼"></a>三分天注定，七分靠打拼</h2><blockquote><p><strong>汝爱之罪：</strong></p><p>从晁错的上位过程可以看出，口才很重要</p><p><strong>kkndme：</strong></p><p>呵呵，这个也不一定，一个是看老板的风格，一个是看自身的运气。<br>说汉文帝刘恒去参观皇家动物园（上林苑）就问动物园园长：“咱们动物园有多少动物啊，都有什么品种啊？”一下子把园长问晕了，吭吭叽叽答不上来。<br>这时有个负责老虎的工作人员跑了出来，作了一通汇报，如数家珍，回答的头头是道。刘恒特别高兴，觉得这个管理老虎的工作人员口才特别好，想提拔他当动物园园长。<br>这时候张释之蹦了出来，对皇帝说：秦朝的时候，赵高口才就特别好，特别巧言善辩，结果忠厚的大臣都被迫害了，天下大乱，秦朝完蛋了。陛下要是提拔这个管理大老虎的人，恐怕所有的大臣都会效仿他，专门学习卡耐基演讲，并且天天琢磨吹牛拍马，就没人真正为皇帝干活了。<br>结果是可怜的管理老虎的工作人员白高兴了一场，不但没得到奖赏，还得罪了动物园园长。</p></blockquote><h2 id="人的前程有的时候不掌握在自己手里"><a href="#人的前程有的时候不掌握在自己手里" class="headerlink" title="人的前程有的时候不掌握在自己手里"></a>人的前程有的时候不掌握在自己手里</h2><p>某城市从外省调来个姓q的一把手。该一把手一上任就把该市原来的骨干公务员全部晾到一边，一概不用，名义上对外宣称的是：领导干部年轻化。提拔了一批没有工作经验刚毕业的博士生当处级干部，大多数30岁还不到。这些人一点工作经验没有，以至于外界都很惊讶，甚至惊动了日本友人。<br>该一把手正是要用这些毫无工作经验的白纸，第一：人是自己一手提拔的，他能不感激涕零吗？第二：这些人啥也不懂，自己想怎么干就怎么干，这些人听话就行。不这样做，怎么能一手遮天呢？<br>一批期望往上爬的老公务员就这样牺牲掉了，而一批新丁就此崛起。人生的前程往往不掌握在自己手里。</p><h2 id="河南郑州与洛阳"><a href="#河南郑州与洛阳" class="headerlink" title="河南郑州与洛阳"></a>河南郑州与洛阳</h2><blockquote><p><strong>scdf1234：</strong></p><p>楼主，我想咨询一下，像洛阳这样的城市，它的经济在河南是第二位，但又离省会郑州很近，洛阳的房价现在大概是四千多，您认为洛阳的房价上涨的空间大吗？<br>谢谢！！！！！！！！！！！！</p><p><strong>kkndme：</strong></p><p>洛阳只能成为郑州的影子，如果自住，趁早在洛阳买房，以后一定会涨，如果投资，还是在郑州买，郑州的上涨空间，肯定大于洛阳。<br>不过95年以后，我就再也没去过洛阳，所以洛阳买哪个楼盘升值快，你得自己仔细研究。</p></blockquote><h2 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h2><blockquote><p><strong>灵魂被枪决：</strong></p><p>不知道楼主还在不在，因为只看完前面几页。</p><p>我前两天刚定了一套二手房，昨天打了首付款，下星期应该就要办银行按揭手续了。</p><p>我一直很想买房，但我LG一直不愿意买房，就在定下这套房子之前他还是很不乐意，但</p><p>因为我的坚持，我们终于买了房子了。房子定下后一个石头落地了，但另一个石头有悬</p><p>地半空了，因为我们是做个体户生意的，就怕生意有变故贷款接不上（我是个悲观主义</p><p>者，总先把最坏情况打算在前）。我们是在杭州，虽然不是市中心，但也算是市区了，</p><p>请问楼主能分析一下杭州楼市情况吗？？</p><p>先谢过了，楼主的文章对我启发真的很大</p><p><strong>kkndme：</strong></p><p>前面说过了，杭州我是当一线城市看的。杭州这个城市，本来就是富人的天堂，房价涨到多高都不奇怪，而且极好变现。所以你根本无须担忧资金问题。</p></blockquote><h2 id="西安与重庆"><a href="#西安与重庆" class="headerlink" title="西安与重庆"></a>西安与重庆</h2><blockquote><p><strong>ttan12345：</strong></p><p>用了一整天的时间拜读了楼主的精彩文章，很是佩服！</p><p>印象最深刻的就是北周宇文式和苏的关于贪官的对答，古人真有高人啊！</p><p>感觉楼主知识面相当的宽广，尤其对世界历史比较精通，许多观点非常符合世界发展的规律</p><p>关于房产的问题，我也一直认为，最终不是我们小老百姓可以玩的东子，所以能买就</p><p>尽早买。看了楼主不止一次给大家推荐去投资西安和重庆的地产，楼主问什么看好西安</p><p>和重庆这两个地方，现在各个省会城市哪个不是大兴土木呢？为何西安和重庆会进入你</p><p>的法眼？</p><p><strong>kkndme：</strong></p><p>重庆我就不多说，论述的比较多了，发展重庆是国家战略性的，这是政治任务。<br>西安是西北地区唯一的大城市（乌市比较特殊，不讨论乌市），教育资源丰富，且房价基数较低，所以说后续发展潜力很大，未来该城市的发展一定会纳入zy的视野</p></blockquote><h2 id="谢国中「空置率」"><a href="#谢国中「空置率」" class="headerlink" title="谢国中「空置率」"></a>谢国中「空置率」</h2><blockquote><p><strong>林语边的鸽子：</strong></p><p>谢国中:”一是加息预期；二是政府对房地产的政策调控力度不改；三是市场对人民币升值的预期减弱；四是参考了实际的供应量，“到2012年，房地产的空置率会非常高，全中国13亿老百姓要有的房子都有了。”<br>谢国忠预测，“接下来可能会看到交易量一直在增长，而房价却不死不活地拖几年，房地产没有第二场戏了</p><p>请问楼主对谢国中的说法怎么看?<br>谢谢</p><p><strong>kkndme：</strong></p><p>谢是油价和中国房地产的长期唱空者，从04年开始唱空中国房产。谢的有些话还是很有道理的，但有些预测就另有目的了，毕竟屁股决定脑袋。<br>今年谢一直呼吁的是加息，兼带唱空房地产，唱空房地产的主要依据是空置率。<br>谢自己也说中国的房地产最大受益的是zf，但却用空置率给出了一个下跌的结论。<br>人民币升值，呼吁加息，唱空房地产，摩根史丹利的喉舌作用显而易见的</p></blockquote><h2 id="打工不如有一技之长的小老板"><a href="#打工不如有一技之长的小老板" class="headerlink" title="打工不如有一技之长的小老板"></a>打工不如有一技之长的小老板</h2><blockquote><p><strong>中年不惑吗：</strong></p><p>现在他们已经比一般的小白领强了</p><p>人力成本只会越来越高</p><p>现在去读个技校，当个技工</p><p>肯定比一般大学出来强多了</p><p>还有一个问题：</p><p>一般企业的工资10年没有变</p><p>10年前某个职位是5000，</p><p>10年后这个职位也是5000；</p><p>而在10年间，民工工资可能从1000涨到了3000，<br>房价更是涨了10倍；</p><p>菜价生活用品也翻了数倍</p><p>高房价问题其实就是分配问题</p><p>如果某个从事的职位10年前和10年后是一样的</p><p>那也就相当于这个职位的薪水降了相当多</p></blockquote><p><strong>kkndme：</strong></p><p>进不了体制内的，无论是不是大学毕业，凡是有头脑的、懂做生意的，会一技之长的，只要不懒，活的肯定比无特长一般在公司打工的小白领强。<br>古代也是这样的，街面上卖爆肚的肯定比大户人家厨房里负责切葱的日子过的稳当。卖爆肚的小本生意很累很辛苦，但是有个手艺就不会饿肚子。大户人家切葱的上班期间日子过的比较轻松，甚至收入比卖爆肚的还强点，在大户人家也体面些。但一旦大户人家不要切葱的了，裁员了，这个切葱的出来还真没办法养活自己。<br>大学文凭顶多算个秀才资格，有这个资格才有机会举士，但是举不了士的，就必须学点技术，否则收入远远赶不上瓦工、电工。<br>过去的穷秀才，饭都吃不饱，但是社会地位却不差，一旦中了恩科，就是宰相根苗。现在有点不同，进不了体制内，又没点技术，那肯定沦为社会的最底层，不要说买房子了，能不能解决吃饭问题都不一定。</p><h2 id="一线、二线的生活"><a href="#一线、二线的生活" class="headerlink" title="一线、二线的生活"></a>一线、二线的生活</h2><p>一线和二线选择哪个城市生活，其实就是围城。<br>在一线打拼，有技术有背景或者机会好的，进了金字塔的中层。对于没背景的，运气差点的，看着没什么希望就离开了，到二线发展，起码二线生活成本还低点。混不下去的离开了，又有大量的打算拼一把的冲进来。<br>很多人宁可在大城市当底层，也不愿意回小城市。这还是个观念问题。小城市从城东走到城西也就二十分钟，觉得过得太枯草。大城市灯红酒绿的，虽然跟自己其实没多大关系，但是看着就是舒服。</p><h2 id="讲故事含沙射影ZG之房子不属于市场经济"><a href="#讲故事含沙射影ZG之房子不属于市场经济" class="headerlink" title="讲故事含沙射影ZG之房子不属于市场经济"></a>讲故事含沙射影ZG之房子不属于市场经济</h2><p>不说历史了，讲个故事吧。这个故事纯属虚构，如有雷同，纯属巧合。讲故事麽，就不要和谐了。<br>传说王安石变法失败，后人小王跑到了海外，发现了大西洲。大西洲正处于混乱阶段，军阀割据，外族入侵。小王是个政治军事天才，煽动农民起义，统一了大西洲政权，建立了大西国。<br>小王继承了王安石变法的理想，建立了一个中央高度集权，百姓与百姓之间完全消灭差别的理想国家。农场、工厂、商场全部由国家统一经营，老百姓只需要在国家的农场、工厂、商场里快乐打工就行了。老百姓穿一样的，吃一样的，连结婚都是国家给安排。<br>大西国里有的知识分子认为这样治理国家太机器化了，有违人性。小王同志对这些知识分子很生气。<br>遥远的东方，有一个白鹿洞书院，书院的院长是个伟大的导师，这个人叫朱熹，此人提出了存天理、灭人欲的理论，给了小王同志治理国家理论上的支持。<br>于是小王同志大搞禁欲主义，凡是学习过陆九渊、王阳明心学理论的都抓起来改造。</p><p>不久，大西国经营的农场、工厂、商场就出了问题。效率特别低，老百姓出工不出力，胡干蛮干的比比皆是，后来出现了大饥荒，饿死了不少人。小王同志干不下去，被人赶走了。<br>新领导上台后，先把农场划分给农民，提高农民的积极性，先解决粮食问题。但是工厂、商场就比较不好办。<br>新领导认为，工厂、商场效益低，赔钱是因为负担太重了，城市里的老百姓生老病死都是由国家的工厂、商场负责，国家哪里管的起呢？<br>于是新领导就提出给国家的企业减负，给点优惠政策，拿出胡萝卜，让胆子大愿意自己单干的同志们主动离开国家企业。对于很多死活不肯走的同志，新领导强令这些人卷铺盖，国家不再负担这些人的生老病死了。大家自己解决吧，国家不管了。<br>新领导把还留在国家企业的自己人，定义为内部人员。离开国家企业的，就是外人，定义为社会闲杂人等。<br>社会闲杂人等，有人欢喜有人忧。有人利用内部人员的关系，大把赚钱，有人跑去给外国人当洋买办赚的也不少，还有的知识分子凭着有点文化，给人打工生活的也不错，反正这些人都挺高兴，比在内部受穷强。当然也有没本事的，就比较惨，生活的比较困难。</p><p>新领导看见内部都是自己人了，闲杂人等都清理掉了，于是着手内部改革，凡是稀缺的，与老百姓生产生活密切相关的行业，都由内部来经营，不需要动脑子搞创新，只要定个价，老百姓就必须得接受。<br>而需要创新动脑子的产业，不具备稀缺性必须充分竞争的产业，不是跟老百姓生产生活密切相关的产业都交给社会闲杂人等去自由竞争。<br>相当于把肉都留给了内部自己，把骨头扔给了外部闲杂人员。<br>这样做还有个好处：新领导喜欢内部自己人直接跟外国人做生意，但是只要跟外国人做生意就赔钱，赔的还不是一点半点。赔的钱从哪里补呢？<br>只要通过内部自己人经营的企业，抬高定价，将赔掉的钱转嫁给社会闲杂人等就可以了。<br>于是，当初离开内部的社会闲杂人等发现，钱也难赚了，生活成本也越来越高了，日子过得变得越来越艰难了。<br>这时有个傻空跳出来说：我就不信了，市场经济没有只涨不跌的商品。房价肯定会跌。<br>有个明白人告诉他：市场经济是分品种的。外部社会闲杂人等经营的电脑、电视是市场经济。但是内部人经营的石油、房地产不是市场经济。不能拿市场经济来解释。<br>这个傻空不信，本来在大西国能买房的，结果一直没买，后来买不起了，只好一直租房住。但是房租老涨价，吃饭越来越困难，一年难得吃两回肉。</p><h2 id="什么是好的政策"><a href="#什么是好的政策" class="headerlink" title="什么是好的政策"></a>什么是好的政策</h2><p>好的政策就象挂在驴子鼻子上的胡萝卜，让人永远有希望，但是拼命追也吃不到。这就是中国政治家的最高智慧。</p><p>洋人进北京，老佛爷把义和团推出来，结果拳匪搞的鸡飞狗跳，没法收场。<br>保钓也打算发动群众，靠爱国激情转嫁矛盾。不过好像这招不灵了。老板怎么对待员工，员工就会怎么回报老板。</p><h2 id="李商隐「渣男」祖师爷"><a href="#李商隐「渣男」祖师爷" class="headerlink" title="李商隐「渣男」祖师爷"></a>李商隐「渣男」祖师爷</h2><p>中秋节将至，撇开房地产的涨跌。喝一壶好酒，聊聊古人。</p><p>云母屏风烛影深，长河渐落晓星沉。 　　<br>嫦娥应悔偷灵药，碧海青天夜夜心。</p><p>借着中秋节的千古名句，我们八卦一下李商隐。<br>李商隐帅哥很有女人缘，据说谈了n多次荡气回肠的恋爱，不过这些恋爱经历没记录进正史，而是唐代的八卦记者通过李商隐帅哥的文学作品，侦破出来的。</p><p>李商隐帅哥不光会写诗，年轻人还在玉阳山修习过道术。但是当道士期间并没有认真的清修，以李帅哥的魅力，竟然吸引了一个美丽多情的女道士的目光。</p><p>这个女道士叫宋华阳，本来是个侍奉公主的宫女，跟随公主进山当了女道士。两人邂逅于山中，缠绵悱恻，但终究没有结果，宋美眉怀了李帅哥的宝宝，李帅哥也被轰下了山。但好像李帅哥也没负什么责任。</p><p>李帅哥伤痛的写下了“无题”以示纪念：<br>昨夜星辰昨夜风， 画楼西畔桂堂东。<br>身无彩凤双飞翼， 心有灵犀一点通。<br>隔座送钩春酒暖， 分曹射覆蜡灯红。<br>嗟余听鼓应官去， 走马兰台类转蓬。</p><p>李帅哥的第二个女朋友，被八卦记者们认为是锦瑟，锦瑟是谁？八卦记者们认为是令狐楚家的一个美丽温婉的侍女。</p><p>李帅哥很有才华，但是在晚唐时代，有点生不逢时。当时牛僧孺和李德裕搞党争，李帅哥跑去给牛党的重要人物令狐楚当幕僚，结果泡上了令狐大人的侍女。这个李帅哥和锦瑟谈恋爱的证据是根本没有。八卦记者是根据李帅哥的诗找到的蛛丝马迹。</p><p>这首诗就叫锦瑟。</p><p>锦瑟无端五十弦，一弦一柱思华年。 　　<br>庄生晓梦迷蝴蝶，望帝春心托杜鹃。 　　<br>沧海月明珠有泪，蓝田日暖玉生烟。 　　<br>此情可待成追忆，只是当时已惘然。</p><p>春 　　<br>风光冉冉东西陌，几日娇魂寻不得。<br>蜜房羽客类芳心，冶叶倡条遍相识。 　　<br>暖蔼辉迟桃树西，高鬟立共桃鬟齐。<br>雄龙雌凤杳何许？絮乱丝繁天亦迷。 　　<br>醉起微阳若初曙，映帘梦断闻残语。<br>愁将铁网罥珊瑚，海阔天宽迷处所。 　　<br>衣带无情有宽窄，春烟自碧秋霜白。<br>研丹擘石天不知，愿得天牢锁冤魄。 　　<br>夹罗委箧单绡起，香肌冷衬琤琤佩。<br>今日东风自不胜，化作幽光入西海。</p><p>夏 　　<br>前阁雨帘愁不卷，后堂芳树阴阴见。<br>石城景物类黄泉，夜半行郎空柘弹。 　　<br>绫扇唤风阊阖天，轻帏翠幕波洄旋。<br>蜀魂寂寞有伴未？几夜瘴花开木棉。 　　<br>桂宫流影光难取，嫣薰兰破轻轻语。<br>直教银汉堕怀中，未遣星妃镇来去。 　　<br>浊水清波何异源，济河水清黄河浑。<br>安得薄雾起缃裙，手接云輧呼太君。 　　</p><p>秋 　　<br>月浪衡天天宇湿，凉蟾落尽疏星入。<br>云屏不动掩孤嚬，西楼一夜风筝急。 　　<br>欲织相思花寄远，终日相思却相怨。<br>但闻北斗声回环，不见长河水清浅。 　　<br>金鱼锁断红桂春，古时尘满鸳鸯茵。<br>堪悲小苑作长道，玉树未怜亡国人。 　　<br>瑶琴愔愔藏楚弄，越罗冷薄金泥重。<br>帘钩鹦鹉夜惊霜，唤起南云绕云梦。 　　<br>璫璫丁丁联尺素，内记湘川相识处。<br>歌唇一世衔雨看，可惜馨香手中故。</p><p>冬 　　<br>天东日出天西下，雌凤孤飞女龙寡。<br>青溪白石不相望，堂上远甚苍梧野。 　　<br>冻壁霜华交隐起，芳根中断香心死。<br>浪乘画舸忆蟾蜍，月娥未必婵娟子。 　　<br>楚管蛮弦愁一概，空城罢舞腰支在。<br>当时欢向掌中销，桃叶桃根双姊妹。 　　<br>破鬟倭堕凌朝寒，白玉燕钗黄金蝉。<br>风车雨马不持去，蜡烛啼红怨天曙。</p><p>这是李帅哥写的燕台诗四首。<br>有个叫柳枝的美女，是洛阳大富翁的女儿，吟唱了这首诗后，就爱慕上了李帅哥。这个美女很大胆主动跟李帅哥约会，并没有嫌弃李帅哥没车没房，但不幸被李帅哥放了鸽子。李帅哥其实很喜欢这个柳枝，事后非常后悔，准备把失去的爱情找回来，但是柳枝已经给有权有势的大佬做了妾。</p><p>飒飒东风细雨来，芙蓉塘外有轻雷。<br>金蟾啮锁烧香入，玉虎牵丝汲井回。 　　<br>贾氏窥帘韩掾少，宓妃留枕魏王才。<br>春心莫共花争发，一寸相思一寸灰。</p><p>这首诗名为“无题”，写得是荷花。荷花是民间传说中李帅哥又一个女朋友的名字，也是李的初恋。美丽的荷花陪李帅哥进京赶考，半路上得了重病，李帅哥天天陪伴着她，但不幸的是，荷花还是香消玉损。李帅哥悲痛不已，常常以荷花为题，以纪念此段恋情。</p><p>李帅哥的才华，被节度使王茂元看中了，把女儿嫁给了这位帅哥。李帅哥娶了这位娇妻的同时，也给自己带来了麻烦。</p><p>原因是王茂元是李党的重要人物，而李帅哥的老师令狐楚却是牛党的重要人物。娶了王美人，李帅哥掉进了牛、李两党的夹缝，于是前途杯具了。</p><p>这个故事告诉我们，如果有个老大罩着你，日子过的还不错，就千万别轻易向老大的对手抛媚眼。否则，只能是杯具。</p><p>李帅哥尽管前途杯具了，但是跟娇妻王氏感情很好，王氏突然病逝，李帅哥伤痛万分，写下了“悼伤后赴东蜀辟至散关遇雪” 　　</p><p>剑外从军远，无家与寄衣。 　　<br>散关三尺雪，回梦旧鸳机。</p><p>无题<br>相见时难别亦难，东风无力百花残。<br>春蚕到死丝方尽，蜡炬成灰泪始干。<br>晓镜但愁云鬓改，夜吟应觉月光寒。<br>蓬山此去无多路，青鸟殷勤为探看。<br>　　<br>夜雨寄北<br>君问归期未有期，　　<br>巴山夜雨涨秋池。 　　<br>何当共剪西窗烛， 　　<br>却话巴山夜雨时。<br>　　<br>读这两首诗，第一个感觉就是李帅哥的用情之深，令人叹为观止；第二个感觉就是，其克女朋友的本事，也令人叹为观止啊</p><p>将近中秋，闲扯了一通李商隐，就以李商隐的无题结束这个闲话吧。</p><p>凤尾香罗薄几重，碧文圆顶夜深缝。<br>扇裁月魄羞难掩，车走雷声语未通。<br>曾是寂寥金烬暗，断无消息石榴红。 　　<br>斑骓只系垂杨岸，何处西南待好风。 　　<br>重帏深下莫愁堂，卧后清宵细细长。 　　<br>神女生涯元是梦，小姑居处本无郎。 　　<br>风波不信菱枝弱，月露谁教桂叶香。 　　<br>直道相思了无益，未妨惆怅是清狂。</p><h2 id="西五环内的别墅，是相当稀缺的资源"><a href="#西五环内的别墅，是相当稀缺的资源" class="headerlink" title="西五环内的别墅，是相当稀缺的资源"></a>西五环内的别墅，是相当稀缺的资源</h2><blockquote><p><strong>黎</strong>明中的星光：**</p><p>楼主，认真阅读您的帖子快两周了，以史为鉴，深入浅出，感觉受益匪浅！</p><p>这两天，也在为在北京买房子的事很纠结，请您指点一二：</p><p>为自住，我们最近要买房了，此前，已经关注一年了，一年中，看上的房子都翻了倍。</p><p>最近我们在西四环西五环之间选了一个低密度花园别墅，叠层，新房，小区面积不大，只有200多户，（第一期08年开盘，大约2万上下单价，已入住，这次是二期）。小区密度是1.0。一期为3到5层，2期为5层坡屋顶。小区本身绿化环境不错，堪称绿意盎然，对内部环境很满意，我们选的是1、2层叠层带小花园的房子，220平方米左右。<br>这个小区叫：“金隅—长安山麓”，您从网上可以查到。</p><p>目前价格均价37000元左右。年初开盘时31000左右。开发商的策略是每次小部分放量，慢慢卖，拉开每栋楼开盘时间。最近我们看上的这个，是8月份开盘的。</p><p>我们认为优点是：<br>1、低密度带花园；这在大都市太难得了。<br>2、周围绿色环境好，多。向北是香山方向，一路绿色。<br>3、距离石景山万达距离近，3公里左右吧。万达出现在哪里，哪里基本是一个商业服务中心了。</p><p>缺点是：<br>1、周围没有紧密连接大型服务超市，商场等。最近的沃尔玛在2公里以外。<br>2、周围环境还不够理想。饭后散步、娱乐休闲的地方几乎没有。</p><p>担忧和想咨询您的问题是：<br>1、现在出手买，是否太冒险？<br>2、您对这个小区的前景判断如何？<br>3、我有朋友说买市中心的高层更好，万一卖掉也方便。怕这里以后不好出手。</p><p>楼主，再次打扰，百忙中能帮分析下吗？不胜感谢！</p><p><strong>kkndme：</strong></p><p>关于西五环内的别墅，是相当稀缺的资源，相当于奢侈品，奢侈品是不会随着调控有大幅度的调整，可以参考收藏品的投资，收藏品的风险在于战乱发生或者**经济崩盘。</p></blockquote><h2 id="“奸臣”贾似道"><a href="#“奸臣”贾似道" class="headerlink" title="“奸臣”贾似道"></a>“奸臣”贾似道</h2><p>说一个存在争议的人物，这个人被宋史写入“奸臣传”，就是大名鼎鼎的贾似道。几乎所有人眼中的贾似道都是大奸贼的形象，仗着是贵妃的姐姐，由一个游手好闲不学无术的二流子，摇身一变成了飞扬跋扈的大汉奸。他贪污受贿，搜罗奇珍美女，蒙古人打过来媚外卖过，还向皇帝谎报军情，最后南宋在他手里灭亡。反正老百姓眼中奸臣能干的所有坏事，都安在了贾似道的头上，然而历史真的如此吗？</p><p>经过多方面史料对照，读书仔细的筒子会发现，宋史的说法并不可信，自相矛盾的地方太多，几乎可以说宋史几乎收罗的都是野史和民间传说。是什么原因使一部正史却采用了大量的野史资料呢？</p><p>原因只有一个，贾似道得罪的人太多。</p><p>贾似道得罪人的原因，在于推行了一个政策：公田法。推出的背景是连年征战，南宋需要庞大的军费开支。军费的开支从哪里来呢？当然是从最底层的农民的肚子挤出来。南宋的经济已经是非常困难了，巧妇难为无米之炊，于是zf推出了纸币，相当于给人民打白条，可见纸币并不是现在的专利。这就是恶性通货膨胀。眼看国家经济崩盘了。贾似道想的办法就是：公田法。</p><p>公田法的意思跟傻空说的把多军的财产充公的意思差不多，就是限制地主的田地，凡是超过标准的，超过部分的三分之一充公给zf，zf给佃农耕种，产出的粮食用于军粮。有点相当于物业税的意思。</p><p>就凭贾似道想出的这个政策，说贾似道是个不学无术的混混，说什么我也不会相信的。</p><p>贾的办法很大程度上缓解了南宋经济的彻底崩盘，延缓了南宋生存的时间，但是贾却得罪了几乎所有的地主士大夫阶层。</p><p>贾不是一个贤臣，但绝非二流子，政治上也许不够成熟，但是为了南宋的艰难维持也算是呕心沥血。关于向蒙古大军求和，也并不能就说明他是个汉奸，那样一个经济崩溃，军队毫无战斗力的朝廷，你让他硬着头皮打，下场也就相当于鸦片战争。当然，关于宋史里讲到的贾似道极尽献媚之能事，把汉奸表演得淋漓尽致，应当是士大夫出于地主阶层对公田法的憎恨，狂泼的屎盆子。因为宋史的记录实在是疑点颇多。</p><p>南宋的将领如范文虎、夏贵之流，才真是腐败透顶，拥兵自重，对抗元军极尽脚底抹油之能事，而贾似道能够亲自督师，所以说贾似道是个大汉奸，实在开玩笑有点过火。南宋灭亡了，元世祖抓了南宋投降的将领问话：你们为什么这么容易就投降了呢？</p><p>降将回答：都是贾似道，只重视文官，不重视我们，所以就投降了。</p><p>元世祖哈哈大笑：就你们这样的武将，贾似道能重视你们才怪。</p><p>贾似道最后被郑虎臣擅自给杀了。郑虎臣是个大地主，自己的利益被公田法害得不轻，恨透了贾似道。</p><p>贾似道死了，全体士大夫阶层拍手称快，并且把他列入了奸臣传，永世不得翻身。</p><p>全因为一个公田法。</p><h2 id="关于拆迁"><a href="#关于拆迁" class="headerlink" title="关于拆迁"></a>关于拆迁</h2><p>关于拆迁，我国只有一部91年颁布的拆迁管理条例，但是就是这个简单的东西，很多拆迁时并不遵守。</p><p>常规来说，拆迁应持有拆迁许可证，开发商的开发项目应通过规划局的审核（这个可以在规划局查到），如果连开发商是谁，有没有资格开发都不知道就奇怪了。</p><p>是否同意拆迁取决于拆迁户和拆迁方的博弈，但是拆迁补偿办法一定要具体详细，包括如何补偿，过渡期的约定，具体要有时间和操作办法，还要签订违约责任。关于协议不可能只留在拆迁方手中，这是不合法的。</p><p>暴利拆迁，zf侵害拆迁户的利益的例子比比皆是，关键是自己如何争取主动。</p><h2 id="保钓事件之死要面子活受罪"><a href="#保钓事件之死要面子活受罪" class="headerlink" title="保钓事件之死要面子活受罪"></a>保钓事件之死要面子活受罪</h2><p>保钓事件，既定对策就是争取更多小国穷国的舆论支持，减免他国债务，加大对外经济援助。钱的来源，要靠底层国民勒紧裤腰带。</p><p>自古以来，泱泱大国，威仪四海，对外“恩”显示国力强大，对内“威”显示权力强大，恩威并施，千古国策。</p><p>朱棣的恩泽海外，死要面子，是做的比较极致的。结果是国库空虚，人民吃饭一下成了问题。所以才有后来坚定的禁海。</p><p>如果开通海外贸易，不是为了皇帝的面子，而是为了充实国库和老百姓的腰包，明代的官僚就不会坚持禁海，中国的历史就会改写。</p><p>郑和下西洋，反而堵塞了中国通向大海的道路。</p><blockquote><p><strong>tjOOSAN</strong></p><p>我只能说，楼主不懂政治，就触及了。钓鱼岛就算所有您所谓的“小国”都支持。也没用啊。神经病 就是神经病</p><p><strong>kkndme</strong></p><p>这个做法不新鲜，从周恩来时期，我们的外交政策就是拉拢第三世界国家的选票，远到非洲拉美，近到越南缅甸柬埔寨，支援铁路基建，捐钱捐物，自认第三世界国家的带头人。但是第三世界国家基本有奶就是娘。比如拉美的苏里南，我国刚捐了钱物，米国给了点好处，马上又投向米国。</p><p><strong>tjOOSAN</strong></p><p>建议您看看nhk的中国力量。真实偷拍的中国在非洲都做了什么。</p><p>1、资源。铁矿石 2、建立国家通信网 3、人力。</p><p>呵呵。援助是拉拢，但是有条件的。</p><p>越南最新的高铁，由日本公司建设。中国从来没援建过越南。</p><p>唉。。。。你把中国当傻子了。</p><p><strong>kkndme</strong></p><p>周时代，越南的生产工具、军火、粮食，都是中国无偿援助。无知不可怕，无知还满嘴喷粪最可怕</p><p><strong>tjOOSAN</strong></p><p>呵呵！</p><p>援建越南？？！哪了？给我证据？！？</p><p>关于非洲，我给你们穿了视频！自己看就知道了</p><blockquote><p><strong>中年不惑吗</strong></p><p>还非洲的力量</p><p>当年红太阳把大米鸡蛋东方红拖拉机运到阿尔及利亚</p><p>换来的是“中国人民是我们最好的朋友”和对中国各种口头的声援</p><p>这和kkndme兄说的难道不一致吗</p><p>现在不给钱给物了</p><p>你还能听到“中国人民是我们最好的朋友”的说法吗？</p><p>拉拢非洲小兄弟，是具有政治意义的</p><p>你英国是一票，人家再穷的小国也是一票</p></blockquote><p><strong>kkndme</strong></p><p>你理解力看来真有问题，你哪只眼睛看到争取小国穷国的舆论支持里面，包括越南。</p><p>这个事是温总定的调子，挂在搜狐首页</p><p><strong>tjOOSAN</strong></p><p>中年！kk！！<br>你们这两个同学啊！一看就跟成天上网的学生，没两样。争来争去。</p><p>哎呀，非要你赢他输。</p><p>唉。。。你说的怎么就对呢？？！证据！！明白吗？？</p><p>光你自己打嘴炮。没用啊！</p><p>呵呵 我得出去玩会了</p><p>你们继续网络吧！~~ 两个宅男</p><p><strong>kkndme</strong></p><p>tjOOSAN你去图书馆查查当年的报纸，什么都清楚了。</p><p>典型的愚民政策教育出来的傻蛋。</p></blockquote><h2 id="中国的房地产不可能软着陆"><a href="#中国的房地产不可能软着陆" class="headerlink" title="中国的房地产不可能软着陆"></a>中国的房地产不可能软着陆</h2><p>中国的房地产不可能软着陆，甚至也不可能出现日本的硬着陆。一旦积蓄的问题爆发，会直接崩，崩的绝不会只是房地产。那时候绝对没有人会关心房价，很多人将庆幸于当天能够勉强填饱肚子，但绝不奢望还能见到第二天的日出。</p><blockquote><p><strong>xiangshangpa</strong></p><p>请教楼主，如果出现您说的大部分老百姓勉强甚至不能填饱肚子，房价没人关心的时候，也就是社会动荡的时候，作为您这样的中产以上的阶级，还没有移民，如何自保？我很感兴趣，谢谢！祝中秋快乐！</p><p><strong>kkndme</strong></p><p>这种事要静观其变，所谓山雨欲来风满楼，发生之前一定会有大的征兆。<br>自保是没**有办法的，只能看形势不对，脚底抹油。</p><p><strong>xxx</strong></p><p>按照我的理解，在发生很大征兆之前，党国就会采取措施，实施闭关锁国政策（倒回50年代），跑是跑不掉的，如果大量难民出去，也没有几个国家会接受，中产，富裕阶层也不例外，现在很多国家已经提高移民门槛了，我对这种情况的出现感到悲观，调适空间十分有限，权贵集团真的是永远无法满足，唉</p><p><strong>kkndme</strong></p><p>呵呵，人的命，天注定，自求多福吧。</p><p><strong>中年不惑吗</strong></p><p>我倒没有kkndme兄那么悲观</p><p>去看看美国20世纪30年代的新闻和文章</p><p>也是一片哀嚎</p><p>资本主义已经完蛋了，无可救药了</p><p>贫富差距太大，老百姓活不下去了</p><p>美国当时的知识界很多人都是向往苏俄模式的</p><p>左倾的名流非常多（包括卓别林和爱因斯坦等等）</p><p>即使到了20世纪50年代，美国还要搞麦卡锡主义</p><p>也说明了当年左倾很有市场</p><p>现在了，苏俄成为历史，资本主义反倒越活越精神了</p><p>还有就是如果在南北战争的时候想象一个黑人能当总统</p><p>人家肯定说你是凡尔纳</p><p>就是马丁路德的时候</p><p>也只是奢望能给黑人争取公平和权益<br>　　<br>社会进步总是靠人推进的</p><p>可以是谭嗣同蔡锷，也可以是邹容和陈天华</p><p>何必太悲观了</p><p>难道不是事在人为吗<br>　　<br>自己都不努力改变</p><p>怎么能埋怨前辈的选择错误不作为了</p></blockquote><h2 id="关于购买经济适用房"><a href="#关于购买经济适用房" class="headerlink" title="关于购买经济适用房"></a>关于购买经济适用房</h2><blockquote><p><strong>大学生007</strong></p><p>楼主你好，质询个问题：<br>我家要买个二手房，房子是经济适用房，房产证上写的是土地划拨，中介说买了之后就是商品房了，那买了以后房产证上写的还是不是划拨啊，如果以后遇到拆迁什么的是不是补偿跟人家正规商品房不一样啊？谢谢</p><p><strong>kkndme</strong></p><p>经济适用房需要补交土地款后才能上市销售，补交土地款后，就变成了商品房，所以不用担心。<br>购买经济适用房一定要把补交的地价款算进去，才知道房价是否高于或低于周边商品房楼盘。<br>我国房地产交易很不规范，特别是中介有很多办法欺骗客户，买房无论是自住还是投资都要多长几个心眼。</p></blockquote><h2 id="地级市买房"><a href="#地级市买房" class="headerlink" title="地级市买房"></a>地级市买房</h2><blockquote><p><strong>我是射手520</strong></p><p>楼主，您好。有幸看到您盖的楼，您对历史、政治和经济的研究让我如醍醐灌顶，很多隐约迷惑的东西，似乎有了出路能去寻找答案。万分感谢。<br>说到置业，您对一线二线城市谈的较多，想听听您对类似我们这样城市楼市和经济的看法。<br>我所在的是地级市，离您帖子提到的武汉有500公里。我所在的地市以汽车工业为主导，是三大汽车集团其中之一的发源地，目前是该企业的商用车基地。<br>在全省范围，离省会最远，但是在城市建设、居民生活水平、物价和房价可以排在全省前面，以前分析是因为我们这里是以工业为主，故经济发展比其他以农业为主的地市发展的要好，看了楼主的帖子，感觉跟离武汉最远也有关系。<br>我们当地最贵房价从05年前2000以内，到09年3000-4000元，到今年的5000元，最贵的6000元。<br>房价的飙升一方面随着全国大环境有关，我分析同时跟当地政府的发展思路密不可分，05年开始引进外地大开发商，新修了很多路，其中跟旧城区主干道平行的最重要的一条路，随着市政府入住，体育馆、美术馆，大开发商进驻，经过5年发展，该路段已经成为我们这里房价最贵的一条路，我们是小城市，在这里买房子的，除了投机成分以外，大部分应该是改善型住房，要大型小区，要绿化，这条路目前房子也是越盖越高。通过建设，当地政府财政也充裕，明显感觉对市政投入也大多了。<br>我们这里养老还是不错的，山多，空气好，工业城市，经济发展也交好。<br>我目前的置业状况是，在老城区广场旁边有单位分高层住宅一套，虽然是塔楼，但在广场旁边，弱化了容积率高，当年放弃了单位地段相对没这个中心，总价低的多层住宅，就是看中了地段，这个投资较成功，按照现在市价，房屋总价基本翻番，该房屋目前由父母住。<br>08年底，在开始说的新地段够买一套房屋，120平米，多层住宅，周边政府规划为大学城，周边有两所大专院校，对于该房屋地段较为满意，虽然比不上新修的路的北边和中部靠近体育馆，靠近政府地段升值快，但较看好该地段前景，该地段新修了 一条连接老城区的通道，唯一不太满意是购买的顶楼，因为是购买的该小区的多层住宅没有电梯，如果有了孩子，住顶楼生活就不太方便。购入均价2900，目前周边的新盘均价4500元，该楼盘创造了摇号去选房的记录。该套房屋自住，当年购买房屋没有多贷款一步到位，现在如果想换个满意的难度就大的多，满意的房屋都5000往上了。这套房屋有15万左右的贷款。<br>虽然很看好武汉的楼盘，远远现阶段大于经济承受能力，目前放弃。<br>对于我们当地的楼盘，也超出了我们这种普通人的能力，虽然最近楼盘都卖的很火。<br>好在单位公积金较多，我打算收复30%，剩下用公积金贷款，再购置一套房屋，怕再过一段时间，我的改善型需求就满足不了。<br>前一段时间，有个机会，但是考虑按照目前房价，30%首复，要耗尽目前自己和家人积蓄，犹豫中，错过了机会。<br>目前这种状况，不知道是否该再次买房？<br>再次买房考虑标准时什么？我不太喜欢高层，但是原中心城区，没有大盘，都是单位或者小开发商盖的，基本没有绿化，在中心城区边上也有了一套高层住宅。<br>考虑学位房？我们城市不大，目前这套中心城区房屋虽然没有画片在最好的小学中学，但是离这些学校距离比较近。<br>在靠近那条政府搬入的路的北边靠近体育馆、美术馆（同时也靠近两所重点高中）地方置业，那里房价已经5000多，年底开盘的都是30层以上的高层，自住又不太考虑高层，总价也超出了承受范围。<br>在当地，离那个大企业居住地，区政府也新开了一条路，那条路待开发状态，据说区政府要搬过去（要搬也是2年以后，现在那条路只有一个大开发商在开发），那条路开车到市中心20分钟，那次有机会买的就是那个大开发商的楼盘，主推多层住宅并且带电梯，去年就预售完毕，这次犹豫中，错过了，住宅品质较好，目前地段太偏。<br>如果再有机会，该如何选择呢？</p><p><strong>kkndme</strong></p><p>地级市选房是比较麻烦的，因为投资风险要大于一线城市和省会城市。<br>地级市的购房需求，主要是以改善性需求为主，追求的是大盘，低密度，低楼层，高绿化，最好有个江景或者水景，环境优美的别墅是首选。<br>因为低级市城市较小，绝对的城中心如果环境比较嘈杂，小区不够高档最好不要选择。没有实力购置别墅，可以选择环境优美的高端住宅，最好是品牌大盘，一眼能够让人赏心悦目。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 6.生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Picx图床部署</title>
      <link href="/2022/06/04/19.%E9%83%A8%E7%BD%B2pixc%E5%9B%BE%E5%BA%8A/"/>
      <url>/2022/06/04/19.%E9%83%A8%E7%BD%B2pixc%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>根据 <a href="https://blog.csdn.net/wbsu2004/article/details/121154470">免费的GitHub图床PicX</a> 整理，替换镜像源</p></blockquote><h2 id="1-下载代码"><a href="#1-下载代码" class="headerlink" title="1. 下载代码"></a>1. 下载代码</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/XPoet/picx.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> picx</span><br></pre></td></tr></table></figure><h2 id="2-创建dockerfile文件"><a href="#2-创建dockerfile文件" class="headerlink" title="2 创建dockerfile文件"></a>2 创建dockerfile文件</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># build stage</span></span><br><span class="line"><span class="keyword">FROM</span> node:lts-alpine as build-stage</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=unravely&lt;xxxx@163.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"><span class="comment">#这里用淘宝镜像，不然会卡住</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> cnpm install</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> cnpm install pm2 -g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># production stage</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:stable-alpine as production-stage</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build-stage /app/dist /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="3-构建镜像"><a href="#3-构建镜像" class="headerlink" title="3. 构建镜像"></a>3. 构建镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t unravely/pixc:v1 .</span><br></pre></td></tr></table></figure><h2 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4. 启动服务"></a>4. 启动服务</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d --name=picx --restart=always -p 3480:80 unravely/pixc:v1</span></span><br></pre></td></tr></table></figure><h2 id="5-访问"><a href="#5-访问" class="headerlink" title="5.访问"></a>5.访问</h2><p>访问地址：<a href="http://ip:3480/">http://ip:3480</a></p><h2 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h2><p>也可以直接去(<a href="https://hub.docker.com/search?type=image">Docker Hub</a>)搜索<code>pixc</code>，直接拉取镜像，然后运行；</p>]]></content>
      
      
      <categories>
          
          <category> 3.环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】JavaSE &amp; JavaWeb查漏补缺</title>
      <link href="/2022/06/04/18.JavaSE&amp;JavaWeb%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
      <url>/2022/06/04/18.JavaSE&amp;JavaWeb%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JavaSE"><a href="#一、JavaSE" class="headerlink" title="一、JavaSE"></a>一、JavaSE</h1><h2 id="1-基本数据类型范围"><a href="#1-基本数据类型范围" class="headerlink" title="1. 基本数据类型范围"></a>1. 基本数据类型范围</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><table><thead><tr><th>类型名称</th><th>关键字（默认值）</th><th>包装类</th><th>占用内存</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte（0）</td><td>Byte</td><td>1 字节</td><td>-128~127</td></tr><tr><td>短整型</td><td>short（0）</td><td>Short</td><td>2 字节</td><td>-32768~32767</td></tr><tr><td>整型</td><td>int（0）</td><td>Integer</td><td>4 字节</td><td>-2147483648~2147483647（21亿4千万）</td></tr><tr><td>长整型</td><td>long（0L）</td><td>Long</td><td>8 字节</td><td>-9223372036854775808L~9223372036854775807L</td></tr><tr><td>单精度浮点型</td><td>float（0.0f）</td><td>Float</td><td>4 字节</td><td>+&#x2F;-3.4E+38F（6~7 个有效位）</td></tr><tr><td>双精度浮点型</td><td>double（0.0d）</td><td>Double</td><td>8 字节</td><td>+&#x2F;-1.8E+308 (15 个有效位）</td></tr><tr><td>字符型</td><td>char（’u0000’）</td><td>Character</td><td>2 字节</td><td>ISO 单一字符集</td></tr><tr><td>布尔型</td><td>boolean（ false）</td><td>Boolean</td><td>1 字节</td><td>true 或 false</td></tr></tbody></table><h2 id="2-修饰符"><a href="#2-修饰符" class="headerlink" title="2. 修饰符"></a>2. 修饰符</h2><table><thead><tr><th>修饰符</th><th>当前类</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>YES</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>protected</td><td>YES</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>default</td><td>YES</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>private</td><td>YES</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table><ul><li><strong>public</strong>： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不<br>　　　　　仅可以跨类访问，而且允许跨包（package）访问。</li><li><strong>protected</strong>: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、<br> 　　　　属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</li><li><strong>default</strong>：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访<br> 　　　　问。</li><li><strong>private</strong>: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以<br>　　　　　及方法只能被该类的对象访问，其[子类]不能访问，更不能允许跨包访问。</li></ul><h2 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3. 转义字符"></a>3. 转义字符</h2><p>Java语言支持一些特殊的转义字符序列。</p><table><thead><tr><th align="left">符号</th><th align="left">字符含义</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行 (0x0a)</td></tr><tr><td align="left">\r</td><td align="left">回车 (0x0d)</td></tr><tr><td align="left">\f</td><td align="left">换页符(0x0c)</td></tr><tr><td align="left">\b</td><td align="left">退格 (0x08)</td></tr><tr><td align="left">\0</td><td align="left">空字符 (0x0)</td></tr><tr><td align="left">\s</td><td align="left">空格 (0x20)</td></tr><tr><td align="left">\t</td><td align="left">制表符</td></tr><tr><td align="left">&quot;</td><td align="left">双引号</td></tr><tr><td align="left">&#39;</td><td align="left">单引号</td></tr><tr><td align="left">\</td><td align="left">反斜杠</td></tr><tr><td align="left">\ddd</td><td align="left">八进制字符 (ddd)</td></tr><tr><td align="left">\uxxxx</td><td align="left">16进制Unicode字符 (xxxx)</td></tr></tbody></table><h2 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4. 代码块"></a>4. 代码块</h2><blockquote><ol><li><p>就是被一对{}所括起来的代码</p></li><li><p>根据代码块定义的位置不同分为:局部代码块,构造代码块,静态代码块**</p></li></ol></blockquote><ol><li><strong>局部代码块：</strong></li></ol><ul><li><p>在方法中出现；限定变量生命周期，及早释放，提高内存利用率</p></li><li><p>在同一个类中的同一个方法中，如果存在多个局部代码块，执行顺序是自上而下的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//局部代码块       </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在方法中出现</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;局部代码块&quot;</span>);</span><br><span class="line">        System.out.println(num);        <span class="comment">//输出200</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println(num);  //出了代码块的范围,就不能再使用了!所以会报错!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><ol start="2"><li><strong>构造代码块 (初始化块)：</strong></li></ol><ul><li>在类中方法外出现；多个构造方法方法中相同的代码存放到一起，<strong>每创建一次对象就会执行一次，优先于构造函数执行</strong>。每次调用构造都执行，并且在构造方法前执行</li><li>无论类中有多少个构造代码块，构造代码块之间会先进行自上而下的顺序执行，然后再执行构造方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">        <span class="comment">//构造代码块，可以为该类的所有对象的成员变量赋值。</span></span><br><span class="line">        num = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;       <span class="comment">//进程入口</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>静态代码块：</strong></li></ol><ul><li>在<strong>类中方法外</strong>出现，并加上static修饰；用于给类进行初始化，<strong>随着类加载而加载</strong>，一般用来给类进行初始化，在加载的时候就执行，并且<strong>只执行一次</strong>。</li><li>一般用于加载驱动，优先于主方法执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;       <span class="comment">//进程入口</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-继承-amp-实现"><a href="#5-继承-amp-实现" class="headerlink" title="5. 继承&amp;实现"></a>5. 继承&amp;实现</h2><ul><li><p>【继承】Java只支持单继承，不支持多继承。(一个儿子只能有一个爹)；</p></li><li><p>【继承】Java支持多层继承（爹的上面可以有爷爷）；</p></li><li><p>【实现】Java支持多实现（implement）；</p></li><li><p>【继承】子类只能继承父类所有非私有的成员（成员方法和成员变量）；</p></li><li><p>【继承】子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法；</p></li><li><p>【继承】抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。</p></li><li><p>【实现】接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。</p></li><li><p>【继承】子类中所有的构造方法默认都会访问父类中空参数的构造方法，子类会继承父类中的数据，可能还会使用父类的数据。所以子类初始化之前，一定要先完成父类数据的初始化。</p></li><li><p>【继承】每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//默认继承object类。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Father的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();        <span class="comment">//这是一条隐藏语句，用来访问父类中的空参构造。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son的构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>【继承】父类没有无参构造方法,子类怎么办？super(…)或者this(….)必须出现在构造方法的第一条语句上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super(&quot;李四&quot;,24);//调父类</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>);<span class="comment">//调本类，不能同时写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Son的空参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age);</span><br><span class="line">        System.out.println(<span class="string">&quot;Son的有参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-重写和重载"><a href="#6-重写和重载" class="headerlink" title="6. 重写和重载"></a>6. 重写和重载</h2><ul><li>方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的。</li><li>方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。</li></ul><h2 id="7-final关键字"><a href="#7-final关键字" class="headerlink" title="7. final关键字"></a>7. final关键字</h2><ul><li>修饰类，类不能被继承</li><li>修饰变量，变量就变成了常量（量命名规范_所有字母大写），只能被赋值一次</li><li>修饰方法，方法不能被重写</li><li>修饰局部变量<ul><li>基本类型，是值不能被改变</li><li>引用类型，是地址值不能被改变,对象中的属性可以改变</li></ul></li></ul><h2 id="8-抽象类"><a href="#8-抽象类" class="headerlink" title="8. 抽象类"></a>8. 抽象类</h2><p><strong>1. 特点</strong></p><ul><li><p>抽象类和抽象方法必须用abstract关键字修饰</p><ul><li>abstract class 类名 {}</li><li>public abstract void eat();</li></ul></li><li><p>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口</p></li><li><p>抽象类不能实例化那么，抽象类如何实例化呢?</p><ul><li>按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。</li></ul></li><li><p>抽象类的子类，要么是抽象类，要么重写抽象类中的所有抽象方法</p></li><li><p>抽象类的成员特点</p><ul><li>成员变量：既可以是变量，也可以是常量;abstract不能修饰成员变量。</li><li>构造方法：用于子类访问父类数据的初始化。</li><li>成员方法：既可以是抽象的，也可以是非抽象的。</li></ul></li><li><p>抽象类的成员方法特性：</p><ul><li>抽象方法 强制要求子类做的事情。</li><li>非抽象方法 子类继承的事情，提高代码复用性。</li></ul></li><li><p>abstract不能和哪些关键字共存</p><ul><li><p>abstract和static</p><ul><li>被abstract修饰的方法没有方法体</li><li>被static修饰的可以用类名.调用，但是类名.调用抽象方法是没有意义的</li></ul></li><li><p>abstract和final</p><ul><li>被abstract修饰的方法强制子类重写</li><li>被final修饰的不让子类重写，所以他俩是矛盾的</li></ul></li><li><p>abstract和private</p><ul><li><p>被abstract修饰是为了让子类看到并强制重写</p></li><li><p>被private修饰不让子类访问，所以他俩是矛盾的</p></li></ul></li></ul></li></ul><p><strong>2. 抽象类和普通类的区别和一些特性</strong></p><ul><li>抽象类不可以直接实例化，只可以用来继承</li><li>子类继承抽象类后，必须实现父类的所有抽象方法， 如果抽象类的派生子类没有实现其中的所有抽象方法，那么该派生子类仍然是抽象类， 只能用于继承，而不能实例化；</li><li>一个类里面定义了抽象方法，那么该类必须定义为抽象类，但是一个抽象类里面可以有抽象方法，也可以没有</li><li>构造方法和静态方法不可以修饰为abstract!!!（注意:static和abstract绝对不是互斥的,虽然两者不能同时修饰某个方法,但他们可以同时修饰内部类）</li><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li></ul><p>​     </p><h2 id="9-接口特点"><a href="#9-接口特点" class="headerlink" title="9. 接口特点"></a>9. 接口特点</h2><ul><li><p>接口用关键字interface表示：interface 接口名 {}</p></li><li><p>类实现接口用implements表示：class 类名 implements 接口名 {}</p></li><li><p>接口不能实例化，按照多态的方式来实例化。</p></li><li><p>接口的子类</p><ul><li><p>可以是抽象类。但是意义不大。</p></li><li><p>可以是具体类。要重写接口中的所有抽象方法。(推荐方案)</p></li></ul></li><li><p>接口成员特点</p><ul><li>成员变量；只能是常量，并且是静态的并公共的。默认修饰符：public static final</li><li>构造方法：接口没有构造方法。</li><li>成员方法：默认修饰符：public abstract，只能是抽象方法。<strong>在jdk8中，还可以有静态方法和default方法。并且静态方法与default方法可以有方法体</strong></li></ul></li></ul><h2 id="10-接口和抽象类的区别"><a href="#10-接口和抽象类的区别" class="headerlink" title="10. 接口和抽象类的区别"></a>10. 接口和抽象类的区别</h2><p><strong>抽象类:</strong></p><ul><li><p>抽象类不可以实例化，<strong>只能够用来继承</strong>；</p></li><li><p>包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</p></li><li><p>抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；</p></li><li><p>一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p></li><li><p>抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用；</p></li><li><p>抽象类中可以包含非抽象的方法；</p></li><li><p>抽象类的引用可指向子类的实例；</p><p><strong>接口：</strong></p></li><li><p>接口用interface关键修饰。接口中所有的方法为抽象方法 ,<strong>注明：</strong>jdk8之后提供了默认方法和静态方法（且这两种方法可以存在方法体）</p></li><li><p>接口可以包含变量、方法；变量被隐式指定为public static final，方法被隐式指定为public abstract（JDK1.8之前）；</p></li><li><p>接口中的变量都为常量</p></li><li><p>接口不能实例化，只被实现,还能被接口继承</p></li><li><p>接口的实现类必须全部实现接口中的方法，如果不实现，可以将子类变成一个抽象类</p></li><li><p>接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p></li><li><p>一个类可以实现多个接口；</p></li><li><p>接口的引用指向实现类的实例</p></li><li><p>JDK1.8中对接口增加了新的特性：</p><ul><li>（1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；</li><li>（2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</li></ul></li></ul><p>C:设计理念区别</p><ul><li>抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。</li><li>接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。</li></ul><p><strong>文字描述</strong></p><blockquote><p>1.接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。</p><p>2.类可以实现很多个接口，但是只能继承一个抽象类。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现， 否则该类仍然需要被声明为抽象类。</p><p>2.抽象类可以在不提供接口方法实现的情况下实现接口。Java 接口中声明的变量默认都是final的。抽象类可以包含非final的变量。Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。</p><p>3.接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main方法的话是可以被调用的。(抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用)接口可以继承接口。抽象类可以实现(implements)接口<strong>，抽象类可继承具体类，但前提是具体类必须有明确的构造函数</strong>。<strong>有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</strong> </p><p>4.接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p></blockquote><h2 id="11-x3D-x3D-号和equals方法的区别"><a href="#11-x3D-x3D-号和equals方法的区别" class="headerlink" title="11. &#x3D;&#x3D;号和equals方法的区别"></a>11. &#x3D;&#x3D;号和equals方法的区别</h2><ul><li>&#x3D;&#x3D;是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,<ul><li>基本数据类型比较的是值</li><li>引用数据类型比较的是地址值</li></ul></li><li>equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,equals方法和&#x3D;&#x3D;号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性，String重写的equal方法</li></ul><h2 id="12-Integer类-128到127陷阱"><a href="#12-Integer类-128到127陷阱" class="headerlink" title="12. Integer类-128到127陷阱"></a>12. Integer类-128到127陷阱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">127</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">127</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">1000</span> ;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">1000</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> d1= <span class="number">127</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(a1 == a2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(b1 == b2); <span class="comment">//false</span></span><br><span class="line">    System.out.println(c1 == c2); <span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(d1 == d2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(e1 == e2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(f1 == f2); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当数据为基本类型int的时候，运行的结果都是true，而如果是封装类型Integer的时候，数据为127的时候使true，128和1000都为false </p></li><li><p>首先我们要理解&#x3D;&#x3D;比较的是什么，它比较的是栈中数据是否相同，我们都知道，<strong>基本类型的数据的变量名和值都存在栈中</strong>（作为类的属性的情况除外），因此，所有int类型的数据运行都会为true。</p></li><li><p>Integer是引用类型，会把它的值存在堆中，栈中存储的是变量名及堆中数据的地址</p></li><li><p>自动拆箱与自动装箱：</p><p>Integer a &#x3D; 1；其实代表的是Integer a &#x3D; new Integer(1)；我们不需要去进行初始化，这个方法会自己初始化在堆中开辟一片区域存储数据。</p><p>自动拆箱也类似int b &#x3D; a；代表的是int b &#x3D; Integer.valueOf(a);同样不需要我们主动调用方法。</p></li><li><p>出现false，<strong>因为每次初始化都会开辟新的区域，虽然两块区域可能储存的值相同，但是它们是堆中两块不同的区域，栈中存储的地址不同，因此比较会出现false。</strong></p></li><li><p>Integer 的值为-128<del>127 的时候就会认为是true是因为Java对-128</del>127在常量池中进行了缓存（Java规定在-128~127之间的Integer类型的变量，直接指向常量池中的缓存地址，不会new开辟出新的空间。 ）</p></li></ul><h2 id="13-Java正则表达式"><a href="#13-Java正则表达式" class="headerlink" title="13. Java正则表达式"></a>13. Java正则表达式</h2><table><thead><tr><th align="left">字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， <strong><code>n</code><strong>匹配字符 <strong><code>n</code><strong>。</strong><code>\n</code></strong> 匹配换行符。序列 <strong><code>\\\\</code></strong> 匹配 <strong><code>\\</code></strong> ，</strong><code>\\(</code></strong> 匹配 **<code>(</code>**。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td></tr><tr><td align="left">*</td><td align="left">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td></tr><tr><td align="left">+</td><td align="left">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td></tr><tr><td align="left">{<em>n</em>}</td><td align="left"><em>n</em> 是非负整数。正好匹配 <em>n</em> 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td></tr><tr><td align="left">{<em>n</em>,}</td><td align="left"><em>n</em> 是非负整数。至少匹配 <em>n</em> 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td></tr><tr><td align="left">{<em>n</em>,<em>m</em>}</td><td align="left"><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;&#x3D; <em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em> 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td align="left">?</td><td align="left">当此字符紧随任何其他限定符（*、+、?、{<em>n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td></tr><tr><td align="left">.</td><td align="left">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td></tr><tr><td align="left">(<em>pattern</em>)</td><td align="left">匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用 <strong>$0…$9</strong> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td></tr><tr><td align="left">(?:<em>pattern</em>)</td><td align="left">匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td></tr><tr><td align="left">(?&#x3D;<em>pattern</em>)</td><td align="left">执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td align="left">(?!<em>pattern</em>)</td><td align="left">执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td align="left"><em>x</em>|<em>y</em></td><td align="left">匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</td></tr><tr><td align="left">[<em>xyz</em>]</td><td align="left">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td></tr><tr><td align="left">[^<em>xyz</em>]</td><td align="left">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td></tr><tr><td align="left">[<em>a-z</em>]</td><td align="left">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td></tr><tr><td align="left">[^<em>a-z</em>]</td><td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td></tr><tr><td align="left">\B</td><td align="left">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td></tr><tr><td align="left">\c<em>x</em></td><td align="left">匹配 <em>x</em> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td></tr><tr><td align="left">\d</td><td align="left">数字字符匹配。等效于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">非数字字符匹配。等效于 [^0-9]。</td></tr><tr><td align="left">\f</td><td align="left">换页符匹配。等效于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">换行符匹配。等效于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等效于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td></tr><tr><td align="left">\t</td><td align="left">制表符匹配。与 \x09 和 \cI 等效。</td></tr><tr><td align="left">\v</td><td align="left">垂直制表符匹配。与 \x0b 和 \cK 等效。</td></tr><tr><td align="left">\w</td><td align="left">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td></tr><tr><td align="left">\W</td><td align="left">与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td></tr><tr><td align="left">\x<em>n</em></td><td align="left">匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td></tr><tr><td align="left">\num</td><td align="left">匹配 <em>num</em>，此处的 <em>num</em> 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td></tr><tr><td align="left">\n</td><td align="left">标识一个八进制转义码或反向引用。如果 *n* 前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td></tr><tr><td align="left"><strong><code>\nm</code></strong></td><td align="left">标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 *nm* 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 <em>nm</em>，其中 <em>n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td></tr><tr><td align="left">\nml</td><td align="left">当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td></tr><tr><td align="left">\u<em>n</em></td><td align="left">匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td></tr></tbody></table><p><strong>Pattern和Matcher的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*b&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aaaaab&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> m.matches();</span><br></pre></td></tr></table></figure><h2 id="14-Math类-x2F-Random类-x2F-BigInteger类-x2F-BigDecimal类"><a href="#14-Math类-x2F-Random类-x2F-BigInteger类-x2F-BigDecimal类" class="headerlink" title="14. Math类&#x2F;Random类&#x2F;BigInteger类&#x2F;BigDecimal类"></a>14. Math类&#x2F;Random类&#x2F;BigInteger类&#x2F;BigDecimal类</h2><p><strong>（1）Math类方法使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Math.PI);</span><br><span class="line">    System.out.println(Math.abs(-<span class="number">10</span>));    <span class="comment">//取绝对值</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.ceil(<span class="number">12.01</span>));<span class="comment">//获取向上取整，但是结果是一个double值</span></span><br><span class="line">    System.out.println(Math.ceil(<span class="number">12.99</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.floor(<span class="number">12.01</span>));<span class="comment">//获取向下取整，但是结果也是一个double值</span></span><br><span class="line">    System.out.println(Math.floor(<span class="number">12.99</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.max(<span class="number">20</span>,    <span class="number">30</span>));<span class="comment">//取最大值</span></span><br><span class="line">    System.out.println(Math.min(<span class="number">20</span>,    <span class="number">30</span>));<span class="comment">//取最小值</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//2.0的3次方</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.random());<span class="comment">//生成0.0到1.0之间的所有小数，包括0.0，不包括1.0</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.round(<span class="number">12.3f</span>));<span class="comment">//四舍五入</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(Math.sqrt(<span class="number">2</span>));<span class="comment">//开平方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）Random类方法使用</strong></p><ul><li>Random类的概述<ul><li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，</li><li>则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。</li></ul></li><li>构造方法<ul><li>public Random()</li><li>public Random(long seed)</li></ul></li><li>成员方法<ul><li>public int nextInt()</li><li>public int nextInt(int n) 生产0 到n的随机数，不包括n；</li></ul></li></ul><p><strong>（3）BigInteger类方法使用</strong></p><ul><li>BigInteger的概述<ul><li>可以让超过Integer范围内的数据进行运算</li></ul></li><li>构造方法<ul><li>public BigInteger(String val)</li></ul></li><li>成员方法<ul><li>public BigInteger add(BigInteger val)  &#x2F;&#x2F;加</li><li>public BigInteger subtract(BigInteger val) &#x2F;&#x2F;减</li><li>public BigInteger multiply(BigInteger val) &#x2F;&#x2F;乘</li><li>public BigInteger divide(BigInteger val) &#x2F;&#x2F;除</li><li>public BigInteger[] divideAndRemainder(BigInteger val) &#x2F;&#x2F;返回一个包含divideToIntegralValue的结果，随后其余与上根据上下文设置进行舍入计算两个操作数的结果，结果由两个元素组成的BigDecimal数组。</li></ul></li></ul><p><strong>（4）BigDecimal类方法使用</strong></p><ul><li>A:BigDecimal的概述<ul><li>由于在运算的时候，float类型和double很容易丢失精度，演示案例。</li><li>所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal</li><li>不可变的、任意精度的有符号十进制数。</li></ul></li><li>B:构造方法<ul><li>public BigDecimal(String val)</li></ul></li><li>C:成员方法<ul><li>public BigDecimal add(BigDecimal augend)</li><li>public BigDecimal subtract(BigDecimal subtrahend)</li><li>public BigDecimal multiply(BigDecimal multiplicand)</li><li>public BigDecimal divide(BigDecimal divisor)</li></ul></li></ul><h2 id="15-日期类的使用"><a href="#15-日期类的使用" class="headerlink" title="15.日期类的使用"></a>15.日期类的使用</h2><p>（1）date类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将时间字符串转换成日期对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2000年08月08日 08:08:08&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;y年M月d日 HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(str);                <span class="comment">//将时间字符串转换成日期对象 Ctrl+1抛出异常</span></span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将日期对象转换为字符串</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="comment">//获取当前时间对象</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;y年M月d日 HH:mm:ss&quot;</span>);   <span class="comment">//创建日期格式化类对象</span></span><br><span class="line">System.out.println(sdf.format(d));  </span><br></pre></td></tr></table></figure><h2 id="16-集合体系"><a href="#16-集合体系" class="headerlink" title="16. 集合体系"></a>16. 集合体系</h2><p><img src="https://img-blog.csdnimg.cn/20200313224345849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2MTg0MDc1,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b70273fa0e4b2630fbace443cce584cb.png" alt="集合体系"></p><h2 id="17-CopyOnWriteArrayList如何做到线程安全的"><a href="#17-CopyOnWriteArrayList如何做到线程安全的" class="headerlink" title="17. CopyOnWriteArrayList如何做到线程安全的"></a>17. CopyOnWriteArrayList如何做到线程安全的</h2><p><strong>CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。</strong></p><p>CopyOnWriteArrayList的整个add操作都是在<strong>锁</strong>的保护下进行的。 </p><p>这样做是为了避免在多线程并发add的时候，<strong>复制出多个副本出来</strong>,把数据搞乱了，导致最终的数组数据不是我们期望的。</p><p>由于所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况： </p><p>1、如果写操作未完成，那么直接读取原数组的数据； </p><p>2、如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据； </p><p>3、如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。</p><p>可见，CopyOnWriteArrayList的<strong>读操作</strong>是可以不用<strong>加锁</strong>的。</p><ul><li>CopyOnWriteArrayList的使用场景</li></ul><p>通过上面的分析，CopyOnWriteArrayList 有几个缺点： </p><p>1、由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc</p><p>2、不能用于<strong>实时读</strong>的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到<strong>最终一致性</strong>,但是还是没法满足实时性要求；</p><p>CopyOnWriteArrayList 合适<strong>读多写少</strong>的场景，不过这类慎用 </p><p>因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add&#x2F;set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</p><p><strong>CopyOnWriteArrayList透露的思想</strong></p><p>如上面的分析CopyOnWriteArrayList表达的一些思想： </p><p>1、读写分离，读和写分开 </p><p>2、最终一致性 </p><p>3、使用另外开辟空间的思路，来解决并发冲突</p><p><strong>Collections.synchronizedList</strong></p><p>CopyOnWriteArrayList和Collections.synchronizedList是实现线程安全的列表的两种方式。</p><p>两种实现方式分别针对不同情况有不同的性能表现，其中CopyOnWriteArrayList的写操作性能较差，而多线程的读操作性能较好。</p><p>而Collections.synchronizedList的写操作性能比CopyOnWriteArrayList在多线程操作的情况下要好很多，而读操作因为是采用了synchronized关键字的方式，其读操作性能并不如CopyOnWriteArrayList。因此在不同的应用场景下，应该选择不同的多线程安全实现类。</p><p><strong>总结：写操作多用Collections.synchronizedList，读操作多用CopyOnWriteArrayList</strong></p><h2 id="18-集合的线程安全性"><a href="#18-集合的线程安全性" class="headerlink" title="18. 集合的线程安全性"></a>18. 集合的线程安全性</h2><p><strong>线程安全的集合：</strong></p><ul><li><p>ConcurrentHashMap</p></li><li><p>Collections.synchronizedList</p></li><li><p>CopyOnWriteArrayList</p></li><li><p>CopyOnWriteArraySet</p></li></ul><p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到。</p><p><strong>（1）概念</strong></p><ul><li><strong>线程安全：</strong>就是当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染的情况。</li><li><strong>线程不安全：</strong>就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染的情况。</li><li><strong>对于线程不安全的问题</strong>，一般会使用synchronized关键字加锁同步控制。</li><li><strong>线程安全 工作原理：</strong> jvm中有一个main memory对象，每一个线程也有自己的working memory，一个线程对于一个变量variable进行操作的时候， 都需要在自己的working memory里创建一个copy,操作完之后再写入main memory。<br>当多个线程操作同一个变量variable，就可能出现不可预知的结果。<br>而用synchronized的关键是建立一个监控monitor，这个monitor可以是要修改的变量，也可以是其他自己认为合适的对象(方法)，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完加载load到working memory 到 use &amp;&amp; 指派assign 到 存储store 再到 main memory的过程。才会释放它得到的锁。这样就实现了所谓的线程安全。</li></ul><p><strong>（2）线程的安全控制有三个级别</strong></p><p> • JVM 级别。大多数现代处理器对并发对 某一硬件级别提供支持，通常以 compare-and-swap （CAS）指令形式。CAS 是一种低级别的、细粒度的技术，它允许多个线程更新一个内存位置，同时能够检测其他线程的冲突并进行恢复。它是许多高性能并发算法的基础。在 JDK 5.0 之前，Java 语言中用于协调线程之间的访问的惟一原语是同步，同步是更重量级和粗粒度的。公开 CAS 可以开发高度可伸缩的并发 Java 类。</p><p> • 低级实用程序类 – 锁定和原子类。使用 CAS 作为并发原语，ReentrantLock 类提供与 synchronized 原语相同的锁定和内存语义，然而这样可以更好地控制锁定（如计时的锁定等待、锁定轮询和可中断的锁定等待）和提供更好的可伸缩性（竞争时的高性能）。大多数开发人员将不再直接使用 ReentrantLock 类，而是使用在 ReentrantLock 类上构建的高级类。</p><p> • 高级实用程序类。这些类实现并发构建块，每个计算机科学课本中都会讲述这些类 – 信号、互斥、闩锁、屏障、交换程序、线程池和线程安全集合类等。大部分开发人员都可以在应用程序中用这些类，来替换许多同步、 wait() 和 notify() 的使用，从而提高性能、可读性和正确性。</p><p><strong>（3）常见的线程安全操作列举几个</strong></p><ul><li><p>加锁同步synchronizedLock等</p></li><li><p>wait() notify()线程调度 已实现执行的同步</p></li><li><p>ThreadLocal局部变量  每一个线程都有一份数据</p></li><li><p>Semaphore 信号量</p></li><li><p>volatile 保证一个变量的线程安全</p></li></ul><p><strong>（4）相关集合对象比较</strong></p><ul><li><strong>Vector、ArrayList、LinkedList：</strong><br><strong>1、Vector：</strong><br>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<br><strong>2、ArrayList：</strong><br>a. 当操作是在一列数据的后面添加数据而不是在前面或者中间，并需要随机地访问其中的元素时，使用ArrayList性能比较好。<br>b. ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br><strong>3、LinkedList：</strong><br>a. 当对一列数据的前面或者中间执行添加或者删除操作时，并且按照顺序访问其中的元素时，要使用LinkedList。<br>b. LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li></ul><p>　　 Vector和ArrayList在使用上非常相似，都可以用来表示一组数量可变的对象应用的集合，并且可以随机的访问其中的元素。</p><ul><li><p><strong>HashTable、HashMap、HashSet：</strong><br>HashTable和HashMap采用的存储机制是一样的，不同的是：<br><strong>1、HashMap：</strong><br>a. 采用数组方式存储key-value构成的Entry对象，无容量限制；<br>b. 基于key hash查找Entry对象存放到数组的位置，对于hash冲突采用链表的方式去解决；<br>c. 在插入元素时，可能会扩大数组的容量，在扩大容量时须要重新计算hash，并复制对象到新的数组中；<br>d. 是非线程安全的；<br>e. 遍历使用的是Iterator迭代器；</p><p><strong>2、HashTable：</strong><br>a. 是线程安全的；<br>b. 无论是key还是value都不允许有null值的存在；在HashTable中调用Put方法时，如果key为null，直接抛出NullPointerException异常；<br>c. 遍历使用的是Enumeration列举；</p><p><strong>3、HashSet：</strong><br>a. 基于HashMap实现，无容量限制；<br>b. 是非线程安全的；<br>c. 不保证数据的有序；</p></li><li><p><strong>TreeSet、TreeMap：</strong><br>TreeSet和TreeMap都是完全基于Map来实现的，并且都不支持get(index)来获取指定位置的元素，需要遍历来获取。另外，TreeSet还提供了一些排序方面的支持，例如传入Comparator实现、descendingSet以及descendingIterator等。<br><strong>1、TreeSet：</strong><br>a. 基于TreeMap实现的，支持排序；<br>b. 是非线程安全的；</p><p><strong>2、TreeMap：</strong><br>a. 典型的基于红黑树的Map实现，因此它要求一定要有key比较的方法，要么传入Comparator比较器实现，要么key对象实现Comparator接口；<br>b. 是非线程安全的；</p></li><li><p><strong>StringBuffer和StringBulider：</strong><br>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串。</p></li></ul><p>　　 1、在执行速度方面的比较：StringBuilder &gt; StringBuffer ；<br>　　 2、他们都是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度快；<br>　 　3、 StringBuilder：线程非安全的；<br>　　 4、StringBuffer：线程安全的； 　 </p><ul><li><strong>对于String、StringBuffer和StringBulider三者使用的总结：</strong><br>　　 1.如果要操作少量的数据用 &#x3D; String<br>2.单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder<br>3.多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</li></ul><h2 id="19-泛型"><a href="#19-泛型" class="headerlink" title="19. 泛型"></a>19. 泛型</h2><p><strong>1. 泛型的本质</strong></p><p>本质是参数化类型：ArrayList<String> strings &#x3D; new ArrayList&lt;&gt;();</p><p><strong>（1）保证了类型的安全性</strong></p><p>在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。</p><p><strong>（2） 消除强制转换</strong></p><p>泛型的一个附带好处是，消除源代码中的许多强制类型转换，不确定的类型转换为确定的类型，这使得代码更加可读，并且减少了出错机会。</p><p><strong>（3）避免了不必要的装箱、拆箱操作，提高程序的性能</strong></p><p>在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。</p><p>泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。</p><p><strong>（4）提高了代码的重用性。</strong></p><p><strong>2. 泛型的使用</strong></p><p>泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。</p><p><strong>常见泛型参数名称有如下：</strong></p><p>E：Element (在集合中使用，因为集合中存放的是元素)<br>T：Type（Java 类）<br>K：Key（键）<br>V：Value（值）<br>N：Number（数值类型）<br>？：表示不确定的java类型</p><p>（1）泛型类：把泛型定义在类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &lt;泛型类型<span class="number">1</span>,...&gt; &#123;  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">泛型参数类型规范：</span><br><span class="line"><span class="number">1.</span> T：任意类型 type</span><br><span class="line"><span class="number">2.</span> E：集合中元素的类型 element</span><br><span class="line"><span class="number">3.</span> K：key-value形式 key</span><br><span class="line"><span class="number">4.</span> V：key-value形式 value</span><br></pre></td></tr></table></figure><p>（2）泛型接口：把泛型定义在接口上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericsInteface</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）泛型方法：把泛型定义在方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 传入泛型的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *   1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *   2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *   3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genercMethod</span><span class="params">(T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(t.getClass());</span><br><span class="line"></span><br><span class="line">    System.out.println(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 泛型通配符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1：表示类型参数可以是任何类型 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;?&gt;&#123;&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2：表示类型参数必须是A或者是A的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T <span class="keyword">extends</span> <span class="title class_">A</span>&gt;&#123;&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3: 表示类型参数必须是A或者是A的超类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T supers A&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="20-不能在循环集合的时候删除元素"><a href="#20-不能在循环集合的时候删除元素" class="headerlink" title="20. 不能在循环集合的时候删除元素"></a>20. 不能在循环集合的时候删除元素</h2><ul><li>普通for循环,可以删除,但是索引要–</li><li>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</li><li>增强for循环不能删除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通for循环删除,索引要--</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; list.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">            if(&quot;b&quot;.equals(list.get(i))) &#123;</span></span><br><span class="line"><span class="comment">                list.remove(i--);                    //通过索引删除元素</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="comment">//迭代器删除</span></span><br><span class="line">    <span class="comment">/*Iterator&lt;String&gt; it = list.iterator();</span></span><br><span class="line"><span class="comment">        while(it.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">            if(&quot;b&quot;.equals(it.next())) &#123;</span></span><br><span class="line"><span class="comment">//                list.remove(&quot;b&quot;);        //不能用集合的删除方法，会报并发修改异常</span></span><br><span class="line"><span class="comment">                it.remove();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*for(Iterator&lt;String&gt; it2 = list.iterator(); it2.hasNext();) &#123;</span></span><br><span class="line"><span class="comment">            if(&quot;b&quot;.equals(it2.next())) &#123;</span></span><br><span class="line"><span class="comment">                it2.remove();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增强for循环,不能删除，只能遍历</span></span><br><span class="line">    <span class="keyword">for</span> (String String : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;b&quot;</span>.equals(String)) &#123;</span><br><span class="line">            list.remove(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-TreeSet-保证元素唯一和自然排序的原理"><a href="#21-TreeSet-保证元素唯一和自然排序的原理" class="headerlink" title="21. TreeSet 保证元素唯一和自然排序的原理"></a>21. TreeSet 保证元素唯一和自然排序的原理</h2><ul><li><p>二叉树——小的存储在左边（负数），大的存储在右边（正数），相等就不存（返回0）。</p></li><li><p>compareTo方法，在TreeSet集合中如何存储元素取决于CopareTo方法的返回值</p></li><li><p>1.返回0，集合中只有一个元素。通过比较不存储。</p></li><li><p>2.返回-1，存储在根元素左边。集合倒序</p></li><li><p>3.返回+1，集合怎么存就怎么取</p></li><li><p>1.特点</p><ul><li>TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列</li></ul></li><li><p>2.使用方式</p><ul><li>a.自然顺序(Comparable)<ul><li>TreeSet类的add()方法中会把存入的对象提升为Comparable类型</li><li>调用对象的compareTo()方法和集合中的对象比较</li><li>根据compareTo()方法返回的结果进行存储</li></ul></li><li>b.比较器顺序(Comparator)<ul><li>创建TreeSet的时候可以制定 一个Comparator</li><li>如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序</li><li>add()方法内部会自动调用Comparator接口中compare()方法排序</li><li>调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数</li></ul></li><li>c.两种方式的区别<ul><li>TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException)</li><li>TreeSet如果传入Comparator, 就优先按照Comparator进行排序</li></ul></li></ul></li></ul><h2 id="21-Comparable-amp-Comparator的区别"><a href="#21-Comparable-amp-Comparator的区别" class="headerlink" title="21. Comparable &amp; Comparator的区别"></a>21. Comparable &amp; Comparator的区别</h2><p><strong>（1）对比</strong></p><table><thead><tr><th>参数</th><th>Comparable</th><th>Comparator</th></tr></thead><tbody><tr><td>排序逻辑</td><td>排序逻辑必须在待排序对象的类中</td><td>排序逻辑在另一个实现</td></tr><tr><td>实现</td><td>实现Comparable接口</td><td>实现Comparator接口</td></tr><tr><td>排序方法</td><td><code>int compareTo(Object o1)</code></td><td><code>int compare(Object o1,Object o2)</code></td></tr><tr><td>触发排序</td><td>Collections.sort(List)</td><td>Collections.sort(List, Comparator)</td></tr><tr><td>所在包</td><td>java.lang.Comparable</td><td>java.util.Comparator</td></tr></tbody></table><p><strong>（2）Comparable</strong></p><p>自然排序Comparable可以认为是一种内部比较器，一般情况下在类定义时实现Comparable接口，重写compareTo方法实现排序，返回值为int类型共有三种情况：</p><ul><li>当前对象大于传入对象，返回正整数。</li><li>当前对象小于传入对象，返回负整数。</li><li>当前对象等于传入对象，返回0。</li></ul><blockquote><p>若当前对象x &#x3D; 3，传入对象y &#x3D; 5，返回值为 -1，认为x &lt; y。排列结果由小到大，即为 3,5，实现了升序排列<br>若当前对象x &#x3D; 5，传入对象y &#x3D; 3，返回值为1，认为x &gt; y。排列结果由小到大，即为5,3，实现了降序排列</p><p><strong>当返回正数的时候就会调换位置</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;<span class="built_in">this</span>.age = age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student s)</span>&#123;</span><br><span class="line">        <span class="comment">//按照年龄大小排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;<span class="comment">//升序</span></span><br><span class="line"><span class="comment">//int num = s.age - this.age;//降序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//年龄一样时，按照姓名字母顺序排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span>num== <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(s.name):num;</span><br><span class="line">        <span class="keyword">return</span> num2;<span class="comment">//当返回正数的时候就会调换位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）Comparator</strong></p><p>比较器排序Comparator一般采用内部类的方式实现，需要重写<a href="https://so.csdn.net/so/search?q=compare&spm=1001.2101.3001.7020">compare</a>方法实现排序。返回值为int类型共有三种情况：</p><ul><li>o1 &gt; o2，返回正整数。</li><li>o1 &lt; o2，返回负整数。</li><li>o1 &#x3D; o2，返回0。</li></ul><blockquote><p>若o1中x &#x3D; 3，o2中y &#x3D; 5，返回值为 -1，认为x &lt; y。排列结果由小到大，即为 3,5，实现了升序排列<br>若o1中x &#x3D; 3，o2中y &#x3D; 5，返回值为1，认为x &gt; y。排列结果由小到大，即为5,3，实现了降序排列</p><p><strong>当返回正数的时候就会调换位置</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部类实现Comparator接口重写compare方法，实现按年龄升序排列</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">StudentCom</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();<span class="comment">//当返回正数的时候就会调换位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部类实现Comparator接口重写compare方法，实现按年龄降序排列</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">StudentComDesc</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1 <span class="number">14</span>, Student o2 <span class="number">12</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> o2.getAge() - o1.getAge();<span class="comment">//当返回正数的时候就会调换位置</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="22-finally与return的执行顺序"><a href="#22-finally与return的执行顺序" class="headerlink" title="22. finally与return的执行顺序"></a>22. finally与return的执行顺序</h2><ul><li>当 try 代码块和 catch 代码块中有 return 语句时，finally 仍然会被执行；</li><li>执行 try 代码块或 catch 代码块中的 return 语句之前，都会先执行 finally 语句；</li><li>finally代码块中的return语句会覆盖try或catch中的return， finally中最好不要出现return；</li><li>finally中没有return语句的情况下，对变量进行修改：return语句中是基本数据类型，则finally中对变量进行操作不会改变其值；return语句中是引用数据类型，finally中则会修改里面的数据；</li></ul><h2 id="23-IO流"><a href="#23-IO流" class="headerlink" title="23. IO流"></a>23. IO流</h2><p><strong>（1）io流分类</strong></p><p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/io%E6%B5%812.3qbz6pgl7g40.webp" alt="IO流体系"></p><p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/io%E6%B5%81.1hjqsymudpfk.webp"></p><p><strong>（2）io流简单使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;视频.avi&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.avi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(arr)) != -<span class="number">1</span>) &#123;        <span class="comment">//忘记写arr，返回的是码表值</span></span><br><span class="line">        fos.write(arr,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）InputStream.available()获取流大小问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;https://t7.baidu.com/it/u=2168645659,3174029352&amp;fm=193&amp;f=GIF&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(path).openConnection();</span><br><span class="line">    <span class="comment">//此连接的URL引用的资源的内容长度，如果内容长度未知，或者内容长度大于Integer.MAX_VALUE，则为-1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">contentLength</span> <span class="operator">=</span> urlConnection.getContentLength();</span><br><span class="line">    System.out.println(contentLength); </span><br><span class="line"></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">    <span class="comment">//inputStream.available()可以在没有阻塞的情况下从此输入流中读取（或跳过）的字节数的估计值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;in.available()=&quot;</span>+inputStream.available()); <span class="comment">//in.available()=15865</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">    System.out.println(<span class="string">&quot;toByteArray数组大小=&quot;</span>+bytes.length);<span class="comment">//toByteArray数组大小=169243</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先开后关，先开的输入流，再开的输出流，通过读取输入流写入输出流中，那么应该先关输出流，再关输入流</span></span><br><span class="line">    <span class="comment">//先关外层，再关内层</span></span><br><span class="line">    inputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的InputStream.available()是从网络中获取数据，由于存在着网络延迟等因素，所以会造成<code>.available()</code>的大小和实际的大小不一致，应该用urlConnection.getContentLength();获取，或者将其转换为字节流byteArrayInputStream然后在获取.available()；</p><p><strong>（4）IO流的关闭</strong></p><ul><li>使用装饰流时，只需要关闭最后面的装饰流即可，装饰流是指通过装饰模式实现的java流，又称为包装流，装饰流关闭时会调用原生流关闭；</li><li>先开后关，先开的输入流，再开的输出流，通过读取输入流写入输出流中，那么应该先关输出流，再关输入流；</li><li>内存流可以不用关闭，ByteArrayOutputStream和ByteArrayInputStream其实是伪装成流的字节数组（把它们当成字节数据来看就好了），他们不会锁定任何文件句柄和端口，如果不再被使用，字节数组会被垃圾回收掉，所以不需要关闭；</li><li>try (OutputStream out &#x3D; new FileOutputStream(“”)) { <em>&#x2F;&#x2F; …操作流代码</em> } catch (Exception e) { e.printStackTrace(); }</li></ul><h2 id="24-Java异或"><a href="#24-Java异或" class="headerlink" title="24. Java异或"></a>24. Java异或</h2><blockquote><p>异或是一种基于<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>的位运算，用符号XOR或者^表示，其运算法则是对运算符两侧数的每一个二进制位同值则取0，异值则取1.<br>简单理解就是不进位加法，如1+1&#x3D;0，0+0&#x3D;0，1+0&#x3D;1.<br>For example: 3^5 &#x3D; 6<br>转成二进制后就是 0011 ^ 0101 二号位和三号位都是异值取1 末尾两个1同值取零，所以3^5 &#x3D; 0110 &#x3D; 6</p></blockquote><p><strong>应用举例</strong></p><p>1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现<br>一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空<br>间，能否设计一个算法实现？<br>解法一、显然已经有人提出了一个比较精彩的解法，将所有数加起来，减去1+2+…+1000的和。<br>这个算法已经足够完美了，相信出题者的标准答案也就是这个算法，唯一的问题是，如果数列过大，则可能会导致溢出。<br>解法二、异或就没有这个问题，并且性能更好。<br>将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。<br>但是这个算法虽然很简单，但证明起来并不是一件容易的事情。这与异或运算的几个特性有关系。<br>首先是异或运算满足交换律、结合律。<br>所以，1^2^…^n^…^n^…^1000，无论这两个n出现在什么位置，都可以转换成为1^2^…^1000^(n^n)的形式。<br>其次，对于任何数x，都有x^x&#x3D;0，x^0&#x3D;x。<br>所以1^2^…^n^…^n^…^1000 &#x3D; 1^2^…^1000^(n^n)&#x3D; 1^2^…^1000^0 &#x3D; 1^2^…^1000（即序列中除了n的所有数的异或）。<br>令，1^2^…^1000（序列中不包含n）的结果为T<br>则1^2^…^1000（序列中包含n）的结果就是T^n。<br>T^(T^n)&#x3D;n。<br>所以，将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。<br>当然有人会说，1+2+…+1000的结果有高斯定律可以快速计算，但实际上1^2^…^1000的结果也是有规律的，算法比高斯定律还该简单的多。</p><p>google面试题的变形：一个数组存放若干整数，一个数出现奇数次，其余数均出现偶数次，找出这个出现奇数次的数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">22</span>, <span class="number">38</span>,<span class="number">38</span>, <span class="number">22</span>,<span class="number">22</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">11</span> &#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">temp ^= a[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法有很多，但是最好的和上面一样，就是把所有数异或，最后结果就是要找的，原理同上！！</p><p><strong>其他用途示例</strong></p><p>这样可以实现不引人第三个变量实现交换，但是进行的计算相对第三个变量多，所以效率会低一些。<br>关于其他的方法还有：int a&#x3D;5,b&#x3D;10;<br>a&#x3D;a+b; &#x2F;&#x2F;a&#x3D;15,b&#x3D;10<br>b&#x3D;a-b; &#x2F;&#x2F;a&#x3D;15,b&#x3D;5<br>a&#x3D;a-b; &#x2F;&#x2F;a&#x3D;10,b&#x3D;5<br>但是这样做有一个缺陷，假设它运行在vc6环境中，那么int的大小是4 Bytes，所以int变量所存放的最大值是2^31-1即2147483647，如果我们令a的值为2147483000，b的值为1000000000，那么a和b相加就越界了。<br>事实上，从实际的运行统计上看，我们发现要交换的两个变量，是同号的概率很大，而且，他们之间相减，越界的情况也很少，因此我们可以把上面的加减法互换，这样使得程序出错的概率减少：<br>int a&#x3D;5,b&#x3D;10;<br>a -&#x3D; b; &#x2F;&#x2F;a&#x3D;-5,b&#x3D;10<br>b +&#x3D; a; &#x2F;&#x2F;b&#x3D;5,a&#x3D;-5<br>a &#x3D; b - a; &#x2F;&#x2F;a&#x3D;10,b&#x3D;5<br>通过以上运算，a和b中的值就进行了交换。表面上看起来很简单，但是不容易想到，尤其是在习惯引入第三变量的算法之后。<br>它的原理是：把a、b看做数轴上的点，围绕两点间的距离来进行计算。<br>具体过程：第一句“a-&#x3D;b”求出ab两点的距离，并且将其保存在a中；第二句“b+&#x3D;a”求出a到原点的距离（b到原点的距离与ab两点距离之差），并且将其保存在b中；第三句“a+&#x3D;b”求出b到原点的距离（a到原点距离与ab两点距离之和），并且将其保存在a中。完成交换。</p><h2 id="25-Properties类简介"><a href="#25-Properties类简介" class="headerlink" title="25. Properties类简介"></a>25. Properties类简介</h2><p>Properties类继承自Hashtable，key-value格式可以当map来使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>． getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>． load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>． setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>． store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>． clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</span><br></pre></td></tr></table></figure><h2 id="26-反射"><a href="#26-反射" class="headerlink" title="26. 反射"></a>26. 反射</h2><h3 id="1-获取Class对象的三种方式"><a href="#1-获取Class对象的三种方式" class="headerlink" title="1. 获取Class对象的三种方式"></a>1. 获取Class对象的三种方式</h3><blockquote><p><strong>在运行期间，一个类，只有一个Class对象产生。</strong> </p><p>三种方式常用第三种，第一种对象都有了还要反射干什么;</p><p>第二种需要导入类的包，依赖太强，不导包就抛编译错误;</p><p>一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p></blockquote><p>（1）Object ——&gt; getClass(); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">//new 产生一个Student对象，一个Class对象。</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> stu1.getClass(); <span class="comment">//获取Class对象</span></span><br><span class="line">System.out.println(stuClass.getName());</span><br></pre></td></tr></table></figure><p>（2）任何数据类型（包括基本数据类型）都有一个“静态”的class属性 ；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式获取Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stuClass2</span> <span class="operator">=</span> Student.class;</span><br><span class="line"><span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line">System.out.println(stuClass == stuClass2);</span><br></pre></td></tr></table></figure><p>（3） 通过Class类的静态方法：forName（String  className）(常用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stuClass3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line"><span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">System.out.println(stuClass3 == stuClass2);</span><br></pre></td></tr></table></figure><h3 id="2-通过反射获取构造方法并使用"><a href="#2-通过反射获取构造方法并使用" class="headerlink" title="2. 通过反射获取构造方法并使用"></a>2. 通过反射获取构造方法并使用</h3><p>学生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------构造方法-------------------</span></span><br><span class="line"><span class="comment">//（默认的构造方法）</span></span><br><span class="line">Student(String str)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;(默认)的构造方法 s = &quot;</span> + str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了公有、无参构造方法执行了。。。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有一个参数的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">char</span> name)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有多个参数的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;年龄：&quot;</span>+ age);<span class="comment">//这的执行效率有问题，以后解决。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//受保护的构造方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Student</span><span class="params">(<span class="type">boolean</span> n)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;受保护的构造方法 n = &quot;</span> + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有构造方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;私有的构造方法   年龄：&quot;</span>+ age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取构造方法：</strong></p><p>（1）批量的方法：</p><ul><li>public Constructor[] getConstructors()：所有”公有的”构造方法</li><li>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</li></ul><p>（2）获取单个的方法：</p><ul><li><p>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：</p></li><li><p>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</p></li></ul><p>（3）调用构造方法：</p><ul><li><strong>Constructor–&gt;newInstance(Object… initargs)</strong></li></ul><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructors</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1.加载Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取所有公有构造方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;*****所有公有构造方法*****&quot;</span>);</span><br><span class="line">Constructor[] conArray = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*****所有的构造方法(包括：私有、受保护、默认、公有)*****&quot;</span>);</span><br><span class="line">conArray = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*****获取公有、无参的构造方法*****&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getConstructor(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span></span><br><span class="line"><span class="comment">//2&gt;、返回的是描述这个无参构造函数的类对象。</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;con = &quot;</span> + con);</span><br><span class="line"><span class="comment">//调用构造方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line"><span class="comment">//System.out.println(&quot;obj = &quot; + obj);</span></span><br><span class="line"><span class="comment">//Student stu = (Student)obj;</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*****获取私有构造方法，并调用*****&quot;</span>);</span><br><span class="line">con = clazz.getDeclaredConstructor(<span class="type">char</span>.class);</span><br><span class="line">System.out.println(con);</span><br><span class="line"><span class="comment">//调用构造方法</span></span><br><span class="line">con.setAccessible(<span class="literal">true</span>);<span class="comment">//暴力访问(忽略掉访问修饰符)</span></span><br><span class="line">obj = con.newInstance(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">********所有公有构造方法********</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(java.lang.String,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student()</span><br><span class="line">******所有的构造方法(包括：私有、受保护、默认、公有)******</span><br><span class="line"><span class="keyword">private</span> fanshe.Student(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">protected</span> fanshe.Student(<span class="type">boolean</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(java.lang.String,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student()</span><br><span class="line">fanshe.Student(java.lang.String)</span><br><span class="line">*******获取公有、无参的构造方法******</span><br><span class="line">con = <span class="keyword">public</span> fanshe.Student()</span><br><span class="line">调用了公有、无参构造方法执行了。。。</span><br><span class="line">******获取私有构造方法，并调用******</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line">姓名：男</span><br></pre></td></tr></table></figure><h3 id="3-获取成员变量并调用"><a href="#3-获取成员变量并调用" class="headerlink" title="3. 获取成员变量并调用"></a>3. 获取成员变量并调用</h3><p>student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********字段*************//</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> sex;</span><br><span class="line"><span class="keyword">private</span> String phoneNum;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, sex=&quot;</span> + sex</span><br><span class="line">+ <span class="string">&quot;, phoneNum=&quot;</span> + phoneNum + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取成员变量并调用：</strong></p><p>1.批量的</p><ul><li>Field[] getFields():获取所有的”公有字段”</li><li>Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；<br>2.获取单个的：</li><li>1).public Field getField(String fieldName):获取某个”公有的”字段；</li><li>2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</li></ul><p><strong>设置字段的值：</strong></p><ul><li>Field –&gt; public void set(Object obj,Object value):<br>参数说明：</li><li>1.obj:要设置的字段所在的对象；</li><li>2.value:要为字段设置的值；</li></ul><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fields</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.field.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取字段</span></span><br><span class="line">        System.out.println(<span class="string">&quot;*****获取所有公有的字段*****&quot;</span>);</span><br><span class="line">        Field[] fieldArray = stuClass.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****获取所有的字段(包括私有、受保护、默认的)*****&quot;</span>);</span><br><span class="line">        fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****获取公有字段**并调用*****&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">//获取一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> stuClass.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">//产生Student对象--》Student stu = new Student();</span></span><br><span class="line">        <span class="comment">//为字段设置值</span></span><br><span class="line">        f.set(obj, <span class="string">&quot;刘德华&quot;</span>);<span class="comment">//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span></span><br><span class="line">        <span class="comment">//验证</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)obj;</span><br><span class="line">        System.out.println(<span class="string">&quot;验证姓名：&quot;</span> + stu.name);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****获取私有字段****并调用*****&quot;</span>);</span><br><span class="line">        f = stuClass.getDeclaredField(<span class="string">&quot;phoneNum&quot;</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);<span class="comment">//暴力反射，解除私有限定</span></span><br><span class="line">        f.set(obj, <span class="string">&quot;18888889999&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;验证电话：&quot;</span> + stu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">************获取所有公有的字段*********</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line">************获取所有的字段(包括私有、受保护、默认的)********</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> fanshe.field.Student.age</span><br><span class="line"><span class="type">char</span> fanshe.field.Student.sex</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">*************获取公有字段**并调用***************</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line">验证姓名：刘德华</span><br><span class="line">**************获取私有字段****并调用*************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">验证电话：Student [name=刘德华, age=<span class="number">0</span>, sex=</span><br></pre></td></tr></table></figure><h3 id="4-获取成员方法并调用"><a href="#4-获取成员方法并调用" class="headerlink" title="4. 获取成员方法并调用"></a>4. 获取成员方法并调用</h3><p><strong>student类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="comment">//**************成员方法***************//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(String s)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了：公有的，String参数的show1(): s = &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了：受保护的，无参的show2()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">show3</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了：默认的，无参的show3()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">show4</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot;</span> + age);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取成员方法并调用：</strong></p><p>1.获取批量的：</p><ul><li>public Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类）</li><li>public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</li></ul><p>2.获取单个的：</p><ul><li><p>public Method getMethod(String name,Class&lt;?&gt;… parameterTypes):</p></li><li><p>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)</p><p>​参数：name : 方法名；</p><p>​Class … : 形参的Class类型对象</p></li></ul><p><strong>调用方法：</strong></p><ul><li><p><strong>Method –&gt; public Object invoke(Object obj,Object… args):</strong></p><p>​参数说明：obj : 要调用方法的对象；</p><p>​args:调用方式时所传递的实参；</p></li></ul><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodClass</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1.获取Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.method.Student&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取所有公有方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;**********获取所有的”公有“方法************&quot;</span>);</span><br><span class="line">stuClass.getMethods();</span><br><span class="line">Method[] methodArray = stuClass.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;*********获取所有的方法，包括私有的*********&quot;</span>);</span><br><span class="line">methodArray = stuClass.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;*********获取公有的show1()方法*************&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(<span class="string">&quot;show1&quot;</span>, String.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">//实例化一个Student对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> stuClass.getConstructor().newInstance();</span><br><span class="line">m.invoke(obj, <span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***********获取私有的show4()方法********&quot;</span>);</span><br><span class="line">m = stuClass.getDeclaredMethod(<span class="string">&quot;show4&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line">        <span class="comment">//解除私有限定</span></span><br><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> m.invoke(obj, <span class="number">20</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;返回值：&quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***************获取所有的”公有“方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">    </span><br><span class="line">***************获取所有的方法，包括私有的*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> fanshe.method.Student.show2()</span><br><span class="line"><span class="keyword">void</span> fanshe.method.Student.show3()</span><br><span class="line">    </span><br><span class="line">***************获取公有的show1()方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">调用了：公有的，String参数的show1(): s = 刘德华</span><br><span class="line">    </span><br><span class="line">***************获取私有的show4()方法******************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="type">int</span>)</span><br><span class="line">调用了，私有的，并且有返回值的，<span class="type">int</span>参数的show4(): age = <span class="number">20</span></span><br><span class="line">返回值：abcd</span><br></pre></td></tr></table></figure><h3 id="5-反射main方法"><a href="#5-反射main方法" class="headerlink" title="5. 反射main方法"></a>5. 反射main方法</h3><p>student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;main方法执行了。。。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Student类的main方法、不要与当前的main方法搞混了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1、获取Student对象的字节码</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.main.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取main方法</span></span><br><span class="line"> <span class="type">Method</span> <span class="variable">methodMain</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);<span class="comment">//第一个参数：方法名称，第二个参数：方法形参的类型，</span></span><br><span class="line"><span class="comment">//3、调用main方法</span></span><br><span class="line"><span class="comment">// methodMain.invoke(null, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);</span></span><br><span class="line"> <span class="comment">//第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数</span></span><br><span class="line"> <span class="comment">//这里拆的时候将  new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。</span></span><br><span class="line"> methodMain.invoke(<span class="literal">null</span>, (Object)<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;);<span class="comment">//方式一</span></span><br><span class="line"><span class="comment">// methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);//方式二</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-通过反射运行配置文件内容"><a href="#6-通过反射运行配置文件内容" class="headerlink" title="6. 通过反射运行配置文件内容"></a>6. 通过反射运行配置文件内容</h3><p>student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;is show()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件以txt文件为例子（pro.txt）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = cn.fanshe.<span class="type">Student</span></span><br><span class="line"><span class="variable">methodName</span> <span class="operator">=</span> show</span><br></pre></td></tr></table></figure><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</span></span><br><span class="line"><span class="comment"> * 我们只需要将新类发送给客户端，并修改配置文件即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//通过反射获取Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(getValue(<span class="string">&quot;className&quot;</span>));<span class="comment">//&quot;cn.fanshe.Student&quot;</span></span><br><span class="line"><span class="comment">//2获取show()方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(getValue(<span class="string">&quot;methodName&quot;</span>));<span class="comment">//show</span></span><br><span class="line"><span class="comment">//3.调用show()方法</span></span><br><span class="line">m.invoke(stuClass.getConstructor().newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法接收一个key，在配置文件中获取相应的value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//获取配置文件的对象</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;pro.txt&quot;</span>);<span class="comment">//获取输入流</span></span><br><span class="line">pro.load(in);<span class="comment">//将流加载到配置文件对象中</span></span><br><span class="line">in.close();</span><br><span class="line"><span class="keyword">return</span> pro.getProperty(key);<span class="comment">//返回根据key获取的value值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台输出：</span><br><span class="line">is <span class="title function_">show</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h3 id="7-通过反射越过泛型检查"><a href="#7-通过反射越过泛型检查" class="headerlink" title="7. 通过反射越过泛型检查"></a>7. 通过反射越过泛型检查</h3><blockquote><p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的</p></blockquote><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过反射越过泛型检查</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">strList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">strList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//strList.add(100);</span></span><br><span class="line"><span class="comment">//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">listClass</span> <span class="operator">=</span> strList.getClass(); <span class="comment">//得到 strList 对象的字节码 对象</span></span><br><span class="line"><span class="comment">//获取add()方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//调用add()方法</span></span><br><span class="line">m.invoke(strList, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : strList)&#123;</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="27-动态代理"><a href="#27-动态代理" class="headerlink" title="27. 动态代理"></a>27. 动态代理</h2><blockquote><p>Java中两种常见的动态代理方式：JDK原生动态代理和CGLIB动态代理</p><p>动态代理在Java中有着广泛的应用，比如Spring AOP、Hibernate数据查询、测试框架的后端mock、RPC远程调用、Java注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。</p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p><strong>代理模式</strong>：给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式</p><p>代理模式角色分为 3 种：</p><ul><li><strong>Subject（抽象主题角色）</strong>：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</li><li><strong>RealSubject（真实主题角色</strong>）：真正实现业务逻辑的类；</li><li><strong>Proxy（代理主题角色）</strong>：用来代理和封装真实主题；</li></ul><p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p><ul><li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li><li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li></ul><h3 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 通过静态代理对 UserServiceImpl 进行功能增强，在调用select和update之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 客户端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理的缺点:</p><ul><li><p>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li><p>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></p></li><li><p>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></p></li></ul></li><li><p>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护。</strong></p></li></ul><h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h3><p><strong>1. 概念</strong></p><p>使用场景：</p><ul><li>设计模式中有一个设计原则是开闭原则，是说对修改关闭对扩展开放，我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑(sometimes the code is really like shit)，这时就很难去下手修改代码，那么这时我们就可以通过代理对类进行<strong>增强</strong>。</li><li>我们在使用RPC框架的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。</li><li>Spring的AOP机制就是采用动态代理的机制来实现切面编程。统计每个 api 的请求耗时，统一的日志输出，校验被调用的 api 是否已经登录和权限鉴定。</li></ul><p><strong>动态代理就是类可以动态的生成</strong>，这就涉及到Java虚拟机的<strong>类加载机制</strong>了</p><p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li></ol><p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，<strong>获取类的二进制字节流</strong>（class字节码）就有很多途径：</p><ul><li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li><li>从网络中获取，典型的应用是 Applet</li><li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li><li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li><li>从数据库中获取等等</li></ul><p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。</p><p><strong>常见的有2中实现方式：</strong></p><ol><li>通过实现接口的方式 -&gt; JDK动态代理</li><li>通过继承类的方式 -&gt; CGLIB动态代理</li></ol><p><strong>2. JDK动态代理</strong></p><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习编写一个调用逻辑处理器 LogHandler 类，提供日志增强功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 <code>invoke</code> 方法中编写方法调用的逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//增强</span></span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        <span class="comment">//增强</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写客户端，获取动态生成的代理类的对象须借助 Proxy 类的 newProxyInstance 方法，具体步骤可见代码和注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> proxy.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line"><span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line"><span class="comment">//System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span></span><br><span class="line"><span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userServiceImpl.getClass().getClassLoader();</span><br><span class="line"><span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line"><span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line"><span class="comment">//这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">logHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line"><span class="comment">// 调用代理的方法</span></span><br><span class="line">proxy.select();</span><br><span class="line">proxy.update();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line"><span class="comment">// ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">16</span>:<span class="number">55</span>:<span class="number">19</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure><p>InvocationHandler 和 Proxy 的主要方法介绍如下：</p><p><strong>java.lang.reflect.InvocationHandler</strong></p><ul><li><code>Object invoke(Object proxy, Method method, Object[] args)</code>定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</li></ul><p><strong>java.lang.reflect.Proxy</strong></p><ul><li><p><code>static InvocationHandler getInvocationHandler(Object proxy)</code>用于获取指定代理对象所关联的调用处理器</p></li><li><p><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code>返回指定接口的代理类</p></li><li><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</p></li><li><p><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code>返回 cl 是否为一个代理类</p></li></ul><p><strong>代理类的调用过程</strong></p><p>借助下面的工具类，把代理类保存下来再探个究竟（通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles&#x3D;true也可以保存代理类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下</span></span><br><span class="line"><span class="comment">     * params: clazz 需要生成动态代理类的类</span></span><br><span class="line"><span class="comment">     * proxyName: 为动态生成的代理类的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generateClassFile</span><span class="params">(Class clazz, String proxyName)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据类信息和提供的代理类名称，生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class="line">        <span class="type">String</span> <span class="variable">paths</span> <span class="operator">=</span> clazz.getResource(<span class="string">&quot;.&quot;</span>).getPath();</span><br><span class="line">        System.out.println(paths);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//保留到硬盘中</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(paths + proxyName + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在 Client2 测试类的main的最后面加入一行代码</span></span><br><span class="line"><span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">ProxyUtils.generateClassFile(userServiceImpl.getClass(), <span class="string">&quot;UserServiceProxy&quot;</span>);</span><br></pre></td></tr></table></figure><p>UserServiceProxy 的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m4, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;proxy.UserService&quot;</span>).getMethod(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;proxy.UserService&quot;</span>).getMethod(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li><li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li><li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li><li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p><p>JDK动态代理执行方法调用的过程简图如下：<img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/jdkProxy.6iqan4drkj80.jpg"></p><p><strong>3. CGLIB动态代理</strong></p><p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao 查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao 更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(object, objects);   <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LogInterceptor</span> <span class="variable">logInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogInterceptor</span>();</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);  <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallback(logInterceptor);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao)enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        dao.update();</span><br><span class="line">        dao.select();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">06</span>:<span class="number">40</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure><p>还可以进一步对多个 MethodInterceptor 进行过滤筛选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor2</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log2 start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log2 end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFilter</span> <span class="keyword">implements</span> <span class="title class_">CallbackFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">accept</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;select&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// Callback 列表第1个拦截器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// Callback 列表第2个拦截器，return 2 则为第3个，以此类推</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LogInterceptor</span> <span class="variable">logInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogInterceptor</span>();</span><br><span class="line">        <span class="type">LogInterceptor2</span> <span class="variable">logInterceptor2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogInterceptor2</span>();</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);   <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;logInterceptor, logInterceptor2, NoOp.INSTANCE&#125;);   </span><br><span class="line">        <span class="comment">// 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">DaoFilter</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserDao) enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">log start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">log2 start time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log2 end time [Fri Dec <span class="number">21</span> <span class="number">00</span>:<span class="number">22</span>:<span class="number">39</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure><p><strong>4. CGlib 对接口实现代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。</span></span><br><span class="line"><span class="comment"> * 该类中完成三样工作：</span></span><br><span class="line"><span class="comment"> * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象</span></span><br><span class="line"><span class="comment"> * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类</span></span><br><span class="line"><span class="comment"> * （3）定义回调接口方法。对目标类的增强这在这里完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 声明目标类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CGLibFactory</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义代理的生成方法,用于创建代理对象</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">myCGLibCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 为代理对象设置父类，即指定目标类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this，</span></span><br><span class="line"><span class="comment">         * 是因为MethodIntecepter接口继承自Callback，是其子接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();<span class="comment">// create用以生成CGLib代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start invoke &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;end invoke &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-JDK动态代理与CGLIB动态代理对比"><a href="#4-JDK动态代理与CGLIB动态代理对比" class="headerlink" title="4. JDK动态代理与CGLIB动态代理对比"></a>4. <strong>JDK动态代理与CGLIB动态代理对比</strong></h3><p>JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p><p>cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。</p><p><strong>JDK Proxy 的优势：</strong></p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul><p><strong>基于类似 cglib 框架的优势：</strong></p><ul><li>无需实现接口，达到代理类无侵入</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能</li></ul><p><strong>描述动态代理的几种实现方式？分别说出相应的优缺点</strong></p><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。<br><strong>静态代理</strong>：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p><ul><li><strong>优点</strong>：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li><li><strong>缺点</strong>：不同的接口要有不同的代理类实现，会很冗余</li></ul><p><strong>JDK 动态代理</strong>：</p><p>为了解决静态代理中，生成大量的代理类造成的冗余；JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象 jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口。</p><p><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</p><p><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</p><p><strong>CGLIB 代理</strong>：</p><p>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。 同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。</p><p><strong>优点</strong>：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</p><p><strong>缺点</strong>：技术实现相对难理解些。</p><h3 id="5-其他文章"><a href="#5-其他文章" class="headerlink" title="5. 其他文章"></a>5. 其他文章</h3><p><a href="https://www.cnblogs.com/bryan31/p/15266725.html">动态代理大揭秘，带你彻底弄清楚动态代理！ - 铂赛东 - 博客园 (cnblogs.com)</a></p><h2 id="28-MyBatis中-和-的区别"><a href="#28-MyBatis中-和-的区别" class="headerlink" title="28. MyBatis中${} 和 #{} 的区别"></a>28. MyBatis中${} 和 #{} 的区别</h2><ul><li><p><code>#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符串替换。</p></li><li><p>MyBatis在处理<code>#&#123;&#125;</code>时，会将SQL中的<code>#&#123;&#125;</code>替换为?号，使用PreparedStatement的set方法来赋值；MyBatis在处理 <code>$&#123;&#125;</code> 时，就是把 <code>$&#123;&#125;</code> 替换成变量的值。</p></li><li><p>使用 <code>#&#123;&#125;</code> 可以有效的防止SQL注入，提高系统安全性。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，使用#&#123;&#125;语法，MyBatis会产生PreparedStatement语句，并且安全地设置PreparedStatement参数，这个过程中MyBatis会进行必要的安全检查和转义。例如：</span><br><span class="line">    </span><br><span class="line">    执行SQL：select * from emp where name = #&#123;employeeName&#125;</span><br><span class="line">    参数：employeeName=&gt;Smith</span><br><span class="line">    解析后执行的SQL：select * from emp where name = ？</span><br><span class="line"> </span><br><span class="line">    执行SQL：Select * from emp where name = $&#123;employeeName&#125;</span><br><span class="line">    参数：employeeName传入值为：Smith</span><br><span class="line">    解析后执行的SQL：Select * from emp where name =Smith</span><br><span class="line"> </span><br><span class="line">综上所述，$&#123;&#125;方式可能会引发SQL注入的问题，同时也会影响SQL语句的预编译，所以从安全性和性能的角度出发，应尽量使用#&#123;&#125;。当需要直接插入一个不做任何修改的字符串到SQL语句中，例如在ORDER BY后接一个不添加引号的值作为列名，这时候就需要使用$&#123;&#125;,比如表名。</span><br></pre></td></tr></table></figure><h2 id="29-Redis相关"><a href="#29-Redis相关" class="headerlink" title="29. Redis相关"></a>29. Redis相关</h2><h3 id="（1）Redis的5种数据结构"><a href="#（1）Redis的5种数据结构" class="headerlink" title="（1）Redis的5种数据结构"></a>（1）Redis的5种数据结构</h3><p>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</p><ul><li>字符串类型 string</li><li>哈希类型 hash ： map格式  </li><li>列表类型 list ： linkedlist格式。支持重复元素</li><li>集合类型 set  ： 不允许重复元素</li><li>有序集合类型 sortedset：不允许重复元素，且元素有顺序</li></ul><h3 id="（2）Redis操作命令"><a href="#（2）Redis操作命令" class="headerlink" title="（2）Redis操作命令"></a>（2）Redis操作命令</h3><p><strong>1. 通用命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. keys * : 查询所有的键</span><br><span class="line"></span><br><span class="line">2. type key ： 获取键对应的value的类型</span><br><span class="line"></span><br><span class="line">3. del key：删除指定的key value</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>字符串类型 string</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 存储： set key value</span><br><span class="line">127.0.0.1:6379&gt; set username zhangsan</span><br><span class="line">OK</span><br><span class="line">2. 获取： get key</span><br><span class="line">127.0.0.1:6379&gt; get username</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line">3. 删除： del key</span><br><span class="line">127.0.0.1:6379&gt; del age</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>哈希类型 hash</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 存储： hset key field value</span><br><span class="line">127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash password 123</span><br><span class="line">(integer) 1</span><br><span class="line">2. 获取： </span><br><span class="line">* hget key field: 获取指定的field对应的值</span><br><span class="line">127.0.0.1:6379&gt; hget myhash username</span><br><span class="line">&quot;lisi&quot;</span><br><span class="line">* hgetall key：获取所有的field和value</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;123&quot;</span><br><span class="line"></span><br><span class="line">3. 删除： hdel key field</span><br><span class="line">127.0.0.1:6379&gt; hdel myhash username</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 添加：</span><br><span class="line">1. lpush key value: 将元素加入列表左表</span><br><span class="line"></span><br><span class="line">2. rpush key value：将元素加入列表右边</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush myList b</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">(integer) 3</span><br><span class="line">2. 获取：</span><br><span class="line">* lrange key start end ：范围获取</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">3. 删除：</span><br><span class="line">* lpop key： 删除列表最左边的元素，并将元素返回</span><br><span class="line">* rpop key： 删除列表最右边的元素，并将元素返回</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>集合类型 set ： 不允许重复元素</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 存储：sadd key value</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(integer) 0</span><br><span class="line">2. 获取：smembers key:获取set集合中所有元素</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">3. 删除：srem key value:删除set集合中的某个元素</span><br><span class="line">127.0.0.1:6379&gt; srem myset a</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 存储：zadd key score value</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 60 zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">2. 获取：zrange key start end [withscores]</span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;60&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;80&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;500&quot;</span><br><span class="line">3. 删除：zrem key value</span><br><span class="line">127.0.0.1:6379&gt; zrem mysort lisi</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h2 id="30-网络编程"><a href="#30-网络编程" class="headerlink" title="30. 网络编程"></a>30. 网络编程</h2><p>在展开介绍TCP&#x2F;IP协议之前，首先介绍一下七层ISO模型。国际标准化组织ISO为了使网络应用更为普及，推出了OSI参考模型，即开放式系统互联（Open<br>System Interconnect）模型，<br>一般都叫OSI参考模型。OSI参考模型是ISO组织在1985年发布的网络互连模型，其含义就是为所有公司使用一个统一的规范来控制网络，这样所有公司遵循相同的通信规范，网络就能互联互通了。</p><h3 id="（1）模型框架"><a href="#（1）模型框架" class="headerlink" title="（1）模型框架"></a>（1）模型框架</h3><p>OSI模型定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI模型各层的通信协议，大致举例如下表所示：</p><p>表：OSI模型各层的通信协议举例</p><table><thead><tr><th>层级</th><th>例子</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、等</td></tr><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP、等</td></tr><tr><td>会话层</td><td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets、等</td></tr><tr><td>传输层</td><td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25、等</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP、等</td></tr><tr><td>物理层</td><td>例如铜缆、网线、光缆、无线电等</td></tr></tbody></table><p>TCP&#x2F;IP协议是Internet互联网最基本的协议，其在一定程度上参考了七层ISO模型。OSI模型共有七层，从下到上分别是物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在TCP&#x2F;IP协议中，七层被简化为了四个层次。TCP&#x2F;IP模型中的各种协议，依其功能不同，被分别归属到这四层之中，常被视为是简化过后的七层OSI模型。</p><img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/tcpip.ouuuvzbisf4.webp" style="zoom: 67%;" /><ul><li>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li><li>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li><li>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</li><li>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li></ul><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。</li></ul></li></ul><h3 id="（2）TCP"><a href="#（2）TCP" class="headerlink" title="（2）TCP"></a>（2）TCP</h3><p><strong>1. 客户端向服务器发送数据</strong></p><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">       <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">  <span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">  <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">  <span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">  <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">  <span class="comment">// 3.写出数据.</span></span><br><span class="line">  os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">  <span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">  os.close();</span><br><span class="line">  client.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.服务器向客户端回写数据</strong></p><p>服务端实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">       <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">       <span class="comment">// =================回写数据=======================</span></span><br><span class="line">       <span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> server.getOutputStream();</span><br><span class="line">       <span class="comment">// 6. 回写数据</span></span><br><span class="line">        out.write(<span class="string">&quot;我很好,谢谢你&quot;</span>.getBytes());</span><br><span class="line">       <span class="comment">// 7.关闭资源.</span></span><br><span class="line">       out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">  <span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">  <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">  <span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">  <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">  <span class="comment">// 3.写出数据.</span></span><br><span class="line">  os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">       <span class="comment">// ==============解析回写=========================</span></span><br><span class="line">       <span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">       <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">       <span class="comment">// 5. 读取数据数据</span></span><br><span class="line">       <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">       System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line">  <span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">       in.close();</span><br><span class="line">  os.close();</span><br><span class="line">  client.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）UDP"><a href="#（3）UDP" class="headerlink" title="（3）UDP"></a>（3）UDP</h3><p><strong>1. 发送数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="comment">//DatagramSocket()构造数据报套接字并将其绑定到本地主机上的任何可用端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">        <span class="comment">//DatagramPacket(byte[]buf,intlength,InetAddressaddress,intport)</span></span><br><span class="line">        <span class="comment">//构造一个数据包，发送长度为length的数据包到指定主机上的指定端口号。</span></span><br><span class="line">        <span class="type">byte</span>[]bys=<span class="string">&quot;hello,udp,我来了&quot;</span>.getBytes();</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length,InetAddress.getByName(<span class="string">&quot;192.168.1.66&quot;</span>),<span class="number">10086</span>);</span><br><span class="line">        <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">        <span class="comment">//voidsend(DatagramPacketp)从此套接字发送数据报包</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        <span class="comment">//voidclose()关闭此数据报套接字</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 接收数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//创建一个数据包，用于接收数据</span></span><br><span class="line">            <span class="type">byte</span>[]bys=newbyte[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length);</span><br><span class="line">            <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">            ds.receive(dp);</span><br><span class="line">            <span class="comment">//解析数据包，并把数据在控制台显示</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据是：&quot;</span>+newString(dp.getData(),<span class="number">0</span>,dp.getLength()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-Servlet相关知识"><a href="#31-Servlet相关知识" class="headerlink" title="31. Servlet相关知识"></a>31. Servlet相关知识</h2><h3 id="1-浏览器请求流程"><a href="#1-浏览器请求流程" class="headerlink" title="1.浏览器请求流程"></a>1.浏览器请求流程</h3><p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/requestResponse.dumyv4zju3c.webp"></p><h3 id="2-Tomcat目录介绍"><a href="#2-Tomcat目录介绍" class="headerlink" title="2.Tomcat目录介绍"></a>2.Tomcat目录介绍</h3><ul><li>bin：包含了一些jar , bat文件 。 startup.bat</li><li>conf：tomcat的配置 server.xml web.xml</li><li>lib ：tomcat运行所需的jar文件</li><li>logs：运行的日志文件</li><li>temp：临时文件</li><li>webapps：发布到tomcat服务器上的项目，就存放在这个目录。</li><li>work：jsp翻译成class文件存放地</li></ul><h3 id="3-配置文件方式创建servlet"><a href="#3-配置文件方式创建servlet" class="headerlink" title="3.配置文件方式创建servlet"></a>3.配置文件方式创建servlet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 创建JavaEE项目</span><br><span class="line">2. 定义一个类，实现Servlet接口</span><br><span class="line">* public class ServletDemo1 implements Servlet</span><br><span class="line">3. 实现接口中的抽象方法</span><br><span class="line">4. 配置Servlet</span><br><span class="line"> 在web.xml中配置：</span><br><span class="line">    &lt;!--配置Servlet --&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">* 执行原理：</span><br><span class="line">1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</span><br><span class="line">2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。</span><br><span class="line">3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名</span><br><span class="line">4. tomcat会将字节码文件加载进内存，并且创建其对象</span><br><span class="line">5. 调用其方法</span><br></pre></td></tr></table></figure><h3 id="4-注解方式创建servlet"><a href="#4-注解方式创建servlet" class="headerlink" title="4.注解方式创建servlet"></a>4.注解方式创建servlet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">* Servlet3.0 支持注解配置。可以不需要web.xml了。</span><br><span class="line"></span><br><span class="line">* 步骤：</span><br><span class="line">1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</span><br><span class="line">2. 定义一个类，实现Servlet接口</span><br><span class="line">3. 复写方法</span><br><span class="line">4. 在类上使用@WebServlet注解，进行配置</span><br><span class="line">* @WebServlet(&quot;资源路径&quot;)</span><br><span class="line">一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;)</span><br><span class="line"></span><br><span class="line">    @Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">    @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">    @Documented</span><br><span class="line">    public @interface WebServlet &#123;</span><br><span class="line">        String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;</span><br><span class="line"></span><br><span class="line">        String[] value() default &#123;&#125;;//代表urlPatterns()属性配置</span><br><span class="line"></span><br><span class="line">        String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt;</span><br><span class="line"></span><br><span class="line">        int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;</span><br><span class="line"></span><br><span class="line">        WebInitParam[] initParams() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        boolean asyncSupported() default false;</span><br><span class="line"></span><br><span class="line">        String smallIcon() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String largeIcon() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String description() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String displayName() default &quot;&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-URL和URI的区别"><a href="#5-URL和URI的区别" class="headerlink" title="5.URL和URI的区别"></a>5.URL和URI的区别</h3><ul><li>URL:统一资源定位符 ： <a href="http://localhost/day14/demo1">http://localhost/day14/demo1</a>中华人民共和国</li><li>URI：统一资源标识符 : &#x2F;day14&#x2F;demo1共和国</li></ul><h3 id="6-Http请求头"><a href="#6-Http请求头" class="headerlink" title="6. Http请求头"></a>6. Http请求头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*</span><br><span class="line">Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Length: 31</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"></span><br><span class="line">       Accept: 客户端向服务器端表示，我能支持什么类型的数据。 </span><br><span class="line">       Referer ： 真正请求的地址路径，全路径</span><br><span class="line">       Accept-Language: 支持语言格式</span><br><span class="line">       User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 </span><br><span class="line">       Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据</span><br><span class="line">       Accept-Encoding： gzip, deflate ： 压缩算法 。 </span><br><span class="line">       Host ： 主机地址</span><br><span class="line">       Content-Length： 数据长度</span><br><span class="line">       Connection : Keep-Alive 保持连接</span><br><span class="line">       Cache-Control ： 对缓存的操作</span><br></pre></td></tr></table></figure><h3 id="7-常见的响应头"><a href="#7-常见的响应头" class="headerlink" title="7.常见的响应头"></a>7.常见的响应头</h3><ol><li>Content-Type：text&#x2F;html;charset&#x3D;UTF-8 服务器告诉客户端本次响应体数据格式以及编码格式</li><li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据<ul><li>值：<ul><li>in-line:默认值,在当前页面内打开</li><li>attachment;filename&#x3D;xxx：以附件形式打开响应体。文件下载</li></ul></li></ul></li></ol><h3 id="8-ServletContext对象"><a href="#8-ServletContext对象" class="headerlink" title="8.ServletContext对象"></a>8.ServletContext对象</h3><ul><li>ServletContext代表是一个web应用的环境（上下文）对象，（代表整个web应用，可以和程序的容器(服务器)来通信）ServletContext对象 内部封装是该web应用的信息，ServletContext对象一个web应用只有一个<ul><li>问题：一个web应用有几个servlet对象？</li><li>答: 多个</li></ul></li><li>ServletContext对象的生命周期？<ul><li>创建：该web应用被加载（服务器启动或发布web应用（前提，服务器启动状 态））</li><li>销毁：web应用被卸载（服务器关闭，移除该web应用）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 获取：</span><br><span class="line">1. 通过request对象获取</span><br><span class="line">request.getServletContext();</span><br><span class="line">2. 通过HttpServlet获取</span><br><span class="line">this.getServletContext();</span><br><span class="line">2. 功能：</span><br><span class="line">1. 获取MIME类型：</span><br><span class="line">* MIME类型:在互联网通信过程中定义的一种文件数据类型</span><br><span class="line">* 格式： 大类型/小类型   text/htmlimage/jpeg</span><br><span class="line"></span><br><span class="line">* 获取：String getMimeType(String file)  </span><br><span class="line">2. 域对象：共享数据</span><br><span class="line">1. setAttribute(String name,Object value)</span><br><span class="line">2. getAttribute(String name)</span><br><span class="line">3. removeAttribute(String name)</span><br><span class="line"></span><br><span class="line">* ServletContext对象范围：所有用户所有请求的数据</span><br><span class="line">3. 获取文件的真实(服务器)路径</span><br><span class="line">1. 方法：String getRealPath(String path)  </span><br><span class="line">String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问</span><br><span class="line">        System.out.println(a);</span><br></pre></td></tr></table></figure><h2 id="32-Cookie-amp-Session"><a href="#32-Cookie-amp-Session" class="headerlink" title="32. Cookie&amp;Session"></a>32. Cookie&amp;Session</h2><ul><li>session与Cookie的区别：<br>  1. session存储数据在服务器端，Cookie在客户端<br>  2. session没有数据大小限制，Cookie有<br>  3. session数据安全，Cookie相对于不安全</li></ul><ul><li>Cookie：数据存储在客户端本地，减少服务器端的存储的压力，安全性不好，客户端 可以清除cookie</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/cookieTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  &#123;</span><br><span class="line">    <span class="comment">//设置Cookie的value</span></span><br><span class="line">        <span class="comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str_date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//URL编码</span></span><br><span class="line">        str_date = URLEncoder.encode(str_date,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;编码后：&quot;</span>+str_date);</span><br><span class="line"></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;lastTime&quot;</span>,str_date);</span><br><span class="line">        <span class="comment">//设置cookie的存活时间</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);<span class="comment">//一个月</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;JSESSIONID&quot;</span>,session.getId());</span><br><span class="line">    c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    response.addCookie(c);</span><br><span class="line">        </span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Session：将数据存储到服务器端，安全性相对好，增加服务器的压力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/sessionTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  &#123;</span><br><span class="line">        <span class="comment">//1．获得Session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2．怎样向session中存取数据（session也是一个域对象）</span></span><br><span class="line">        Session也是存储数据的区域对象，所以session对象也具有如下三个方法：</span><br><span class="line">        session.setAttribute(String name,Object obj);</span><br><span class="line">        session.getAttribute(String name);</span><br><span class="line">        session.removeAttribute(String name);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-过滤器，拦截器，监听器的区别"><a href="#33-过滤器，拦截器，监听器的区别" class="headerlink" title="33. 过滤器，拦截器，监听器的区别"></a>33. 过滤器，拦截器，监听器的区别</h2><p>把<code>整个项目的流程比作一条河，那么监听器的作用就是能够听到河流里的所有声音，过滤器就是能够过滤出其中的鱼，而拦截器则是拦截其中的部分鱼，并且作标记。所以当需要监听到项目中的一些信息，并且不需要对流程做更改时，用监听器；当需要过滤掉其中的部分信息，只留一部分时，就用过滤器；当需要对其流程进行更改，做相关的记录时用拦截器</code>。<br> <strong>监听器</strong>更好的应用是用于<strong>信息的监听</strong><br> <strong>过滤器</strong>更好的应用是用于做请求的过滤，<strong>拦截无效的请求和信息</strong><br> <strong>拦截器</strong>则是可以根据实际场景需要，<strong>对业务逻辑进行校验和调整</strong>。所以类似用户登录校验，拦截器会是更好的选择。</p><p>执行顺序：</p><p><strong>监听器 &gt; 过滤器 &gt; 拦截器 &gt; servlet执行 &gt; 拦截器 &gt; 过滤器 &gt; 监听器</strong></p><h3 id="1-过滤器Filter"><a href="#1-过滤器Filter" class="headerlink" title="1.过滤器Filter"></a>1.过滤器Filter</h3><blockquote><p> 过滤器定义在 javax.servlet包，是Servlet规范的一部分，在JavaWeb项目中都可以使用。<br> 我们常常使用过滤器来<strong>过滤掉一些无效的请求</strong>，避免过多无效请求落到servlet、controller上，导致浪费系统的资源。也常用来对请求的编码进行统一的设置，如配置CharacterEncodingFilter作为字符编码过滤器。同时，<strong>过滤器Filter是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关的请求，只有当你的web应用停止或重新部署的时候才能销毁。</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">自定义过滤器</span><br><span class="line"></span><br><span class="line">执行顺序：如果有两个过滤器：过滤器1和过滤器2</span><br><span class="line">    1. 过滤器1</span><br><span class="line">    2. 过滤器2</span><br><span class="line">    3. 资源执行</span><br><span class="line">    4. 过滤器2</span><br><span class="line">    5. 过滤器1 </span><br><span class="line">1. 定义一个类，实现接口Filter</span><br><span class="line">2. 复写方法</span><br><span class="line">3. 配置拦截路径: `web.xml`或者注解`@WebFilter`</span><br><span class="line"></span><br><span class="line">* 过滤器先后顺序问题：</span><br><span class="line">1. 注解配置：按照类名的字符串比较规则比较，值小的先执行,如： AFilter 和 BFilter，AFilter就先执行了。</span><br><span class="line">2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行</span><br></pre></td></tr></table></figure><p><strong>（1）注解方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoming.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/user/*&quot;,filterName = &quot;filter1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">//  在Filter初始化的时候调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter1 has been initialized ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 每个用户请求都会调用到这个方法，校验通过则doFilter放行到下一个过滤器</span></span><br><span class="line"><span class="comment">     *  等到请求通过所有过滤链上的校验后，才能到达servlet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterChain</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doFilter1开始执行，对&quot;</span>+((HttpServletRequest)servletRequest).getRequestURL().toString()+<span class="string">&quot; 进行过滤 &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;检验接口是否被调用，尝试获取contentType如下： &quot;</span> + servletResponse.getContentType());</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;检验接口是否被调用，尝试获取contentType如下： &quot;</span> + servletResponse.getContentType());</span><br><span class="line">        System.out.println(<span class="string">&quot;doFilter1执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter对象被销毁的时候调用，注意，执行该方法后会在调用一次dofilter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter1 has been destroyed...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）web.xml配置方式</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.filter.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-拦截器Interceptor"><a href="#2-拦截器Interceptor" class="headerlink" title="2.拦截器Interceptor"></a>2.拦截器Interceptor</h3><blockquote><p>依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoming.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对接收到的请求进行前置处理，如果返回true才将请求放行给controller</span></span><br><span class="line"><span class="comment">     *  如果返回false，执行中断请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle has done...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  执行croller后，渲染视图之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle has done...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      整个请求结束后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion has done...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">CustomInterceptorA</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">CustomInterceptorB</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring-mvc.xml文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xiaoming.util.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-过滤器和拦截器的区别："><a href="#3-过滤器和拦截器的区别：" class="headerlink" title="3. 过滤器和拦截器的区别："></a>3. 过滤器和拦截器的区别：</h3><p>　　① 拦截器是基于java的反射机制的，而过滤器是基于函数回调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在我们自定义的过滤器中都会实现一个 doFilter()方法，这个方法有一个FilterChain 参数，而实际上它是一个回调接口。</span><br><span class="line">ApplicationFilterChain是它的实现类， 这个实现类内部也有一个 doFilter() 方法就是回调方法。</span><br><span class="line">ApplicationFilterChain里面能拿到我们自定义的xxxFilter类，在其内部回调方法doFilter()里调用各个自定义xxxFilter过滤器，并执行 doFilter() 方法。</span><br><span class="line">而每个xxxFilter 会先执行自身的 doFilter() 过滤逻辑，最后在执行结束前会执行filterChain.doFilter(servletRequest, servletResponse)，也就是回调ApplicationFilterChain的doFilter() 方法，以此循环执行实现函数回调。</span><br></pre></td></tr></table></figure><p>　　② 拦截器(<code>Interceptor</code>) 它是一个<code>Spring</code>组件，并由<code>Spring</code>容器管理，并不依赖<code>Tomcat</code>等容器，是可以单独使用的；过滤器依赖与servlet容器，所以导致它只能在<code>web</code>程序中使用。</p><p>　　③ 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。<br>　　④ 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。<br>　　⑤ 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.拦截器加载的时间点在springcontext之前, 过滤器在springcontext之后；</span><br><span class="line">2.实际开发过程中，会出现多个过滤器或拦截器同时存在的情况，可以使用@Order(Ordered.HIGHEST_PRECEDENCE)控制顺序</span><br><span class="line">过滤器用@Order注解控制执行顺序，通过@Order控制过滤器的级别，值越小级别越高越先执行。</span><br><span class="line">拦截器默认的执行顺序，就是它的注册顺序，也可以通过Order手动设置控制，值越小越先执行。</span><br><span class="line">3.控制执行顺序不同</span><br><span class="line">    1    Interceptor1 前置</span><br><span class="line">    2    Interceptor2 前置</span><br><span class="line">    3    Interceptor 前置</span><br><span class="line">    4    我是controller</span><br><span class="line">    5    Interceptor 处理中</span><br><span class="line">    6    Interceptor2 处理中</span><br><span class="line">    7    Interceptor1 处理中</span><br><span class="line">    8    Interceptor 后置</span><br><span class="line">    9    Interceptor2 处理后</span><br><span class="line">   10    Interceptor1 处理后</span><br></pre></td></tr></table></figure><p>　　⑥ <strong>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</strong></p><ol><li>过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。</li></ol><p><strong>总结：过滤器包裹住servlet，servlet包裹住拦截器。</strong></p><p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/fiter2.5zw9t497kko0.png"></p><ol start="2"><li>过滤器的触发时机是容器后，servlet之前，所以过滤器的<code>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>的入参是ServletRequest ，而不是httpservletrequest。因为过滤器是在httpservlet之前。</li><li>过滤器是JavaEE标准，采用函数回调的方式进行。是在请求进入容器之后，还未进入Servlet之前进行预处理，并且在请求结束返回给前端这之间进行后期处理。</li></ol><h3 id="4-监听器Listener"><a href="#4-监听器Listener" class="headerlink" title="4.监听器Listener"></a>4.监听器Listener</h3><blockquote><p> web监听器是一种Servlet中的特殊的类，它们能帮助开发者监听web中的特定事件，实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：感知到包括request(请求域)，session(会话域)和applicaiton(应用程序)的初始化和属性的变化。</p></blockquote><p>监听器大概分为以下几种</p><ul><li>ServletContextListener：对Servlet上下文的创建和销毁进行监听</li><li>ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和修改</li><li>HttpSessionListener：对Session的创建和销毁进行监听</li><li>HttpSessionAttributeListener：对Session对象中属性的添加、删除和修改进行监听</li><li>HttpSessionBindingListener：监听Http会话中对象的绑定信息</li><li>HttpSessionActivationListener：监听器监听Http会话的情况</li><li>ServletRequestListener：对请求对象的初始化和销毁进行监听</li><li>ServletRequestAttributeListener：对请求对象属性的添加、删除和修改进行监听</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1. 定义一个类，实现ServletContextListener接口</span><br><span class="line">2. 复写方法</span><br><span class="line">3. 配置</span><br><span class="line">(1) web.xml</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">* 指定初始化参数&lt;context-param&gt;</span><br><span class="line">(2) 注解：@WebListener</span><br></pre></td></tr></table></figure><h2 id="34-注解"><a href="#34-注解" class="headerlink" title="34.注解"></a>34.注解</h2><h3 id="1-JDK中预定义的一些注解"><a href="#1-JDK中预定义的一些注解" class="headerlink" title="1. JDK中预定义的一些注解"></a>1. JDK中预定义的一些注解</h3><p>JDK预设了以下注解，作用于代码：</p><ul><li>@Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li></ul><h3 id="2-自定义注解"><a href="#2-自定义注解" class="headerlink" title="2. 自定义注解"></a>2. 自定义注解</h3><p><strong>元注解：用于描述注解的注解</strong></p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</li></ul><p>​public interface MyAnno extends java.lang.annotation.Annotation {}</p><ul><li>属性：接口中的抽象方法<br>要求：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 属性的返回值类型有下列取值</span><br><span class="line">基本数据类型、String、 枚举、注解、以上类型的数组</span><br><span class="line">2. 定义了属性，在使用时需要给属性赋值</span><br><span class="line">* 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</span><br><span class="line">* 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</span><br><span class="line">* 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略</span><br></pre></td></tr></table></figure><h3 id="3-反射获取注解"><a href="#3-反射获取注解" class="headerlink" title="3. 反射获取注解"></a>3. 反射获取注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : clazz.getMethod(<span class="string">&quot;test&quot;</span>).getAnnotations()) &#123;</span><br><span class="line">        System.out.println(annotation.annotationType());   <span class="comment">//获取类型</span></span><br><span class="line">        System.out.println(annotation <span class="keyword">instanceof</span> Test);   <span class="comment">//直接判断是否为Test</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> (Test) annotation;</span><br><span class="line">        System.out.println(test.value());   <span class="comment">//获取我们在注解中写入的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-函数式接口"><a href="#35-函数式接口" class="headerlink" title="35. 函数式接口"></a>35. 函数式接口</h2><blockquote><p> 含义：函数式接口在Java中是指：有且仅有一个抽象方法的接口</p><p> 函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p></blockquote><p><strong>1. 格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名称 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值 类型方法名称 (可选参数信息);<span class="comment">//其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. @FunctionalInterface</strong></p><p>注解与@Override注解的作用类似，Java8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。该注解可用于一个接口的定义上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样</p><h3 id="1-Supplier接口"><a href="#1-Supplier接口" class="headerlink" title="1.  Supplier接口"></a>1.  Supplier接口</h3><p>Supplier接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产 什么类型的数据供我们使用。</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>T get()</td><td>按照某种实现逻辑(由Lambda表达式实现)返回一个数据</td></tr></tbody></table><p>需求：打印出姓名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Supplier</span> Demo &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString(()-&gt;<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        </span><br><span class="line">        Integeri=getInteger(()-&gt;<span class="number">30</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法，返回一个整数数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">getInteger</span><span class="params">(Supplier&lt;Integer&gt; sup)</span>&#123;</span><br><span class="line">        returnsup.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，返回一个字符串数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span>&#123;</span><br><span class="line">        returnsup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Consumer接口"><a href="#2-Consumer接口" class="headerlink" title="2. Consumer接口"></a>2. Consumer接口</h3><p>Consumer接口也被称为消费型接口，它消费的数据的数据类型由泛型指定</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void accept(T t)</td><td>对给定的参数执行此操作</td></tr><tr><td>default Consumer andThen(Consumer after)</td><td>返回一个组合的Consumer，依次执行此操作，然后执行 after操作，</td></tr></tbody></table><p>需求：将两个Consumer接口按照顺序组合到一起使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//操作一</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(s));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//操作二</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString())</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">//传入两个操作使用andThen完成</span></span><br><span class="line">        operatorString(<span class="string">&quot;林青霞&quot;</span>, s -&gt; System.out.println(s), s -&gt;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个方法，用不同的方式消费同一个字符串数据两次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con1,</span></span><br><span class="line"><span class="params">    Consumer&lt;String&gt; con2)</span> &#123;</span><br><span class="line">        <span class="comment">// con1.accept(name);</span></span><br><span class="line">        <span class="comment">// con2.accept(name);</span></span><br><span class="line">        con1.andThen(con2).accept(name);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//定义一个方法，消费一个字符串数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con)</span> &#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Predicate接口"><a href="#3-Predicate接口" class="headerlink" title="3. Predicate接口"></a>3. Predicate接口</h3><p>Predicate接口通常用于判断参数是否满足指定的条件</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean test(T t)</td><td>对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回 一个布尔值</td></tr><tr><td>default Predicate negate()</td><td>返回一个逻辑的否定，对应逻辑非</td></tr><tr><td>default Predicate and(Predicate other)</td><td>返回一个组合判断，对应短路与</td></tr><tr><td>default Predicate or(Predicate other)</td><td>返回一个组合判断，对应短路或</td></tr></tbody></table><p>需求：返回数组，同时满足如下要求：姓名长度大于2；年龄大于33</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] strArray = &#123;<span class="string">&quot;林青霞,30&quot;</span>, <span class="string">&quot;柳岩,34&quot;</span>, <span class="string">&quot;张曼玉,35&quot;</span>, <span class="string">&quot;貂蝉,31&quot;</span>, <span class="string">&quot;王祖贤, 33&quot;</span>&#125;;</span><br><span class="line">    List&lt;String&gt; array = myFilter(</span><br><span class="line">        strArray, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() &gt; <span class="number">2</span>,</span><br><span class="line">        s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt; <span class="number">33</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (String str : array) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">myFilter</span><span class="params">(String[] strArray,</span></span><br><span class="line"><span class="params">                                     Predicate&lt;String&gt; pre1,</span></span><br><span class="line"><span class="params">                                     Predicate&lt;String&gt; pre2)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个集合</span></span><br><span class="line">    List&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (String str : strArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre1.and(pre2).test(str)) &#123;</span><br><span class="line">            <span class="comment">//姓名长度大于2；年龄大于33</span></span><br><span class="line">            array.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Function接口"><a href="#4-Function接口" class="headerlink" title="4. Function接口"></a>4. Function接口</h3><p>Function接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>R apply(T t)</td><td>将此函数应用于给定的参数</td></tr><tr><td>default Function andThen(Function after)</td><td>返回一个组合函数，首先将该函数应用于输入，然后将after函 数应用于结果</td></tr></tbody></table><p>需求：1.将字符串截取得到数字年龄部分; 2.将上一步的年龄字符串转换成为int类型的数据; 3.将上一步的int数据加70，得到一个int结果，在控制台输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;林青霞,30&quot;</span>;</span><br><span class="line"></span><br><span class="line">    convert(s, ss -&gt; ss.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>], Integer::parseInt, i -&gt; i + <span class="number">70</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(String str, </span></span><br><span class="line"><span class="params">                            Function&lt;String, String&gt; fun1,</span></span><br><span class="line"><span class="params">                            Function&lt;String, Integer&gt; fun2, </span></span><br><span class="line"><span class="params">                            Function&lt;Integer, Integer&gt; fun3)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fun1.andThen(fun2).andThen(fun3).apply(str);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-Lamda表达式"><a href="#36-Lamda表达式" class="headerlink" title="36. Lamda表达式"></a>36. Lamda表达式</h2><h3 id="1-获取Stream"><a href="#1-获取Stream" class="headerlink" title="1. 获取Stream"></a>1. 获取Stream</h3><p>（1）Collection</p><ul><li>java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。</li></ul><p>（2）Map</p><ul><li>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 需要分key、value或entry等情况</li></ul><p>（3）数组</p><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：<code>Stream.of(array)</code></p><h3 id="2-Stream流中间操作方法"><a href="#2-Stream流中间操作方法" class="headerlink" title="2. Stream流中间操作方法"></a>2. Stream流中间操作方法</h3><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： </p><ul><li><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </li><li><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Stream filter(Predicate predicate)</td><td>用于对流中的数据进行过滤</td></tr><tr><td>Stream limit(long maxSize)</td><td>返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td>Stream skip(long n)</td><td>跳过指定参数个数的数据，返回由该流的剩余元素组成的 流</td></tr><tr><td>static Stream concat(Stream a, Stream b)</td><td>合并a和b两个流为一个流</td></tr><tr><td>Stream distinct()</td><td>返回由该流的不同元素（根据Object.equals(Object) ）组 成的流</td></tr><tr><td>Stream sorted()</td><td>返回由此流的元素组成的流，根据自然顺序排序</td></tr><tr><td>Stream sorted(Comparator comparator)</td><td>返回由该流的元素组成的流，根据提供的Comparator进行 排序</td></tr><tr><td>Stream map(Function mapper)</td><td>返回由给定函数应用于此流的元素的结果组成的流</td></tr><tr><td>IntStream mapToInt(ToIntFunction mapper)</td><td>返回一个IntStream其中包含将给定函数应用于此流的元素 的结果</td></tr></tbody></table><p><strong>1. filter</strong></p><p>可以通过 filter 方法将一个流转换成另一个子集流；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</span></span><br><span class="line"><span class="comment">//如果结果为true，那么Stream流的 filter方法将会留用元素；</span></span><br><span class="line"><span class="comment">//如果结果为false，那么filter方法将会舍弃元素</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. map</strong></p><p>将流中的元素映射到另一个流中，可以使用 map 方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">    Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. limit</strong></p><p>limit 方法可以对流进行截取，只取用前n个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">    System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. skip</strong></p><p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">    System.out.println(result.count()); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. concat</strong></p><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. sorted</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;linqingxia&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;zhangmanyu&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;wangzuxian&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;liuyan&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;zhangmin&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;zhangwuji&quot;</span>);</span><br><span class="line">    <span class="comment">//需求1：按照字母顺序把数据在控制台输出</span></span><br><span class="line">    <span class="comment">// list.stream().sorted().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//需求2：按照字符串长度把数据在控制台输出</span></span><br><span class="line">    list.stream().sorted((s1,s2) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s1.length()-s2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num==<span class="number">0</span>?s1.compareTo(s2):num;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7. map&amp;mapToInt</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个集合，存储多个字符串元素</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;50&quot;</span>);</span><br><span class="line">    <span class="comment">//需求：将集合中的字符串数据转换为整数之后在控制台输出</span></span><br><span class="line">    <span class="comment">// list.stream().map(s -&gt; Integer.parseInt(s)).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">// list.stream().map(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">// list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//int sum() 返回此流中元素的总和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().mapToInt(Integer::parseInt).sum();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Stream流终结操作方法"><a href="#3-Stream流终结操作方法" class="headerlink" title="3. Stream流终结操作方法"></a>3. Stream流终结操作方法</h3><p><strong>1. forEach:</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    stream.forEach(name‐&gt; System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. count</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法返回一个long值代表元素个数（不再像旧集合那样是int值）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="4-Stream流的收集操作"><a href="#4-Stream流的收集操作" class="headerlink" title="4. Stream流的收集操作"></a>4. Stream流的收集操作</h3><p>对数据使用Stream流的方式操作完毕后，可以把流中的数据收集到集合中。</p><p><strong>常用方法：</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>R collect(Collector collector)</td><td>把结果收集到集合中</td></tr></tbody></table><p><strong>工具类Collectors提供了具体的收集方式</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Collector toList()</td><td>把元素收集到List集合中</td></tr><tr><td>public static Collector toSet()</td><td>把元素收集到Set集合中</td></tr><tr><td>public static Collector toMap(Function keyMapper,Function valueMapper)</td><td>把元素收集到Map集合 中</td></tr></tbody></table><h3 id="5-方法引用"><a href="#5-方法引用" class="headerlink" title="5. 方法引用"></a>5. 方法引用</h3><blockquote><p>如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，就没必要再写重复逻辑了</p><p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟</p></blockquote><h4 id="1-冗余的Lambda场景"><a href="#1-冗余的Lambda场景" class="headerlink" title="1. 冗余的Lambda场景"></a>1. 冗余的Lambda场景</h4><p><strong>（1）例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串<br>打印到什么地方去。而 main 方法通过Lambda表达式指定了函数式接口 Printable 的具体操作方案为：<strong>拿到</strong><br><strong>String（类型可推导，所以可省略）数据后，在控制台中输出它。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01PrintSimple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span> &#123;</span><br><span class="line">    data.print(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    printString(s ‐&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out 对象中的 println(String) 方法。</p><p><strong>（2）改进：</strong></p><p>其中的双冒号 :: 写法，这被称为“方法引用”，而双冒号是一种新的语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02PrintRef</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span> &#123;</span><br><span class="line">    data.print(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    printString(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）语义分析</strong></p><p>上例中， <code>System.out </code>对象中有一个重载的<code>println(String)</code>方法恰好就是我们所需要的。那么对于 <code>printString</code> 方法的函数式接口参数，对比下面两种写法，完全等效： </p><ul><li>Lambda表达式写法： s -&gt; System.out.println(s); </li><li>方法引用写法： System.out::println</li></ul><p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。</p><p>第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代Lambda。</p><p>两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。</p><p> <strong>注：</strong>Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p><h4 id="2-通过对象名引用成员方法"><a href="#2-通过对象名引用成员方法" class="headerlink" title="2. 通过对象名引用成员方法"></a>2. 通过对象名引用成员方法</h4><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRefObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUpperCase</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    System.out.println(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口仍然定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当需要使用这个<code> printUpperCase</code> 成员方法来替代<code>Printable</code>接口的Lambda的时候，已经具有了 <code>MethodRefObject </code>类的对象实例，则可以通过对象名引用成员方法，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable lambda)</span> &#123;</span><br><span class="line">lambda.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MethodRefObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodRefObject</span>();</span><br><span class="line">    printString(obj::printUpperCase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-通过类名称引用静态方法"><a href="#4-通过类名称引用静态方法" class="headerlink" title="4. 通过类名称引用静态方法"></a>4. 通过类名称引用静态方法</h4><p>由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写 法。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calcable</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种写法是使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> num, Calcable lambda)</span> &#123;</span><br><span class="line">System.out.println(lambda.calc(num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">method(‐<span class="number">10</span>, n ‐&gt; Math.abs(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用方法引用的更好写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> num, Calcable lambda)</span> &#123;</span><br><span class="line">System.out.println(lambda.calc(num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">method(‐<span class="number">10</span>, Math::abs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-通过super引用成员方法"><a href="#5-通过super引用成员方法" class="headerlink" title="5. 通过super引用成员方法"></a>5. 通过super引用成员方法</h4><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Greetable</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是父类 Human 的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是子类 Man 的内容，其中使用了Lambda的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;大家好,我是Man!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义方法method,参数传递Greetable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Greetable g)</span>&#123;</span><br><span class="line">    g.greet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,使用Lambda表达式</span></span><br><span class="line">        method(()‐&gt;&#123;</span><br><span class="line">            <span class="comment">//创建Human对象,调用sayHello方法</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Human</span>().sayHello();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//简化Lambda</span></span><br><span class="line">        method(()‐&gt;<span class="keyword">new</span> <span class="title class_">Human</span>().sayHello());</span><br><span class="line">        <span class="comment">//使用super关键字代替父类对象</span></span><br><span class="line">        method(()‐&gt;<span class="built_in">super</span>.sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 Woman ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;大家好,我是Man!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义方法method,参数传递Greetable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Greetable g)</span>&#123;</span><br><span class="line">    g.greet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    method(<span class="built_in">super</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-通过this引用成员方法"><a href="#6-通过this引用成员方法" class="headerlink" title="6.  通过this引用成员方法"></a>6.  通过this引用成员方法</h4><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方 法引用。首先是简单的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Richable</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个丈夫 Husband 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">    lambda.buy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">    marry(() ‐&gt; System.out.println(<span class="string">&quot;买套房子&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开心方法 <code>beHappy</code> 调用了结婚方法<code> marry</code> ，后者的参数为函数式接口 <code>Richable</code> ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 <code>Husband</code> 丈夫类进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;买套房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">    lambda.buy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">    marry(() ‐&gt; <span class="built_in">this</span>.buyHouse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;买套房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123;</span><br><span class="line">    lambda.buy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123;</span><br><span class="line">    marry(<span class="built_in">this</span>::buyHouse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-类的构造器引用"><a href="#7-类的构造器引用" class="headerlink" title="7. 类的构造器引用"></a>7. 类的构造器引用</h4><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <code>类名称::new</code> 的格式表示。首先是一个简单 的 Person 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是用来创建 Person 对象的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonBuilder</span> &#123;</span><br><span class="line">Person <span class="title function_">buildPerson</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是用来创建 Person 对象的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder builder)</span> &#123;</span><br><span class="line">System.out.println(builder.buildPerson(name).getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">printName(<span class="string">&quot;赵丽颖&quot;</span>, name ‐&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是通过构造器引用，有更好的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder builder)</span> &#123;</span><br><span class="line">System.out.println(builder.buildPerson(name).getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">printName(<span class="string">&quot;赵丽颖&quot;</span>, Person::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-数组的构造器引用"><a href="#8-数组的构造器引用" class="headerlink" title="8. 数组的构造器引用"></a>8. 数组的构造器引用</h4><p>数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArrayBuilder</span> &#123;</span><br><span class="line"><span class="type">int</span>[] buildArray(<span class="type">int</span> length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用该接口的时候，可以通过Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] initArray(<span class="type">int</span> length, ArrayBuilder builder) &#123;</span><br><span class="line"><span class="keyword">return</span> builder.buildArray(length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] array = initArray(<span class="number">10</span>, length ‐&gt; <span class="keyword">new</span> <span class="title class_">int</span>[length]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是更好的写法是使用数组的构造器引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] initArray(<span class="type">int</span> length, ArrayBuilder builder) &#123;</span><br><span class="line"><span class="keyword">return</span> builder.buildArray(length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] array = initArray(<span class="number">10</span>, <span class="type">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-内存泄漏"><a href="#37-内存泄漏" class="headerlink" title="37.内存泄漏"></a>37.内存泄漏</h2><h3 id="1-含义："><a href="#1-含义：" class="headerlink" title="1. 含义："></a>1. 含义：</h3><blockquote><p>内存泄漏：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。</p></blockquote><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：</p><ol><li><strong>首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；</strong></li><li><strong>其次，这些对象是无用的，即程序以后不会再使用这些对象。</strong></li></ol><p>如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p><p>而且对于linux kernel，只要不断电就不会释放内存，所以如果内存泄漏积累到一定程度了，就只能重启</p><h3 id="2-回收机制"><a href="#2-回收机制" class="headerlink" title="2. 回收机制"></a>2. 回收机制</h3><p>在Java语言中，判断一个内存空间是否符合垃圾收集的标准有两个：</p><ul><li><p><strong>一个是给对象赋予了空值null，再没有调用过；</strong></p></li><li><p><strong>另一个是给对象赋予了新值，这样重新分配了内存空间。</strong></p></li></ul><h3 id="3-原因"><a href="#3-原因" class="headerlink" title="3. 原因"></a>3. 原因</h3><blockquote><p>根本原因：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是<strong>因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景</strong>。</p></blockquote><p>具体主要有如下几大类：</p><h4 id="（1）静态集合类引起内存泄漏"><a href="#（1）静态集合类引起内存泄漏" class="headerlink" title="（1）静态集合类引起内存泄漏"></a>（1）静态集合类引起内存泄漏</h4><p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Static <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o&#x3D;null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p><h4 id="（2）监听器"><a href="#（2）监听器" class="headerlink" title="（2）监听器"></a>（2）监听器</h4><p>在 java编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如**addXXXListener()**等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p><h4 id="（3）各种连接"><a href="#（3）各种连接" class="headerlink" title="（3）各种连接"></a>（3）各种连接</h4><p>​比如数据库连接<strong>dataSourse.getConnection()<strong>，网络连接</strong>socket</strong>和 <strong>io</strong>连接，除非其显式的调用了其<strong>close()</strong> 方法将其连接关闭，否则是不会自动被<strong>GC</strong> 回收的。<br>​对于<strong>Resultset</strong> 和<strong>Statement</strong> 对象可以不进行显式回收，但<strong>Connection</strong> 一定要显式回收，因为<strong>Connection</strong> 在任何时候都无法自动回收，而<strong>Connection</strong>一旦回收，<strong>Resultset</strong> 和<strong>Statement</strong> 对象就会立即为<strong>NULL</strong>。</p><p>​但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭<strong>Resultset Statement</strong> 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的<strong>Statement</strong> 对象无法释放，从而引起内存泄漏。这种情况下一般都会在<strong>try</strong> 里面去的连接，在<strong>finally</strong>里面释放连接。</p><h4 id="（4）内部类和外部模块的引用"><a href="#（4）内部类和外部模块的引用" class="headerlink" title="（4）内部类和外部模块的引用"></a>（4）内部类和外部模块的引用</h4><p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：<code>public void registerMsg(Object b);</code>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。</p><h4 id="（5）单例模式"><a href="#（5）单例模式" class="headerlink" title="（5）单例模式"></a>（5）单例模式</h4><p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在 <strong>JVM</strong> 的整个生命周期中存在（<strong>以静态变量的方式</strong>），如果单例对象持有外部的引用，那么这个对象将不能被 <strong>JVM</strong> 正常回收，导致内存泄漏，如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        B.getInstance().setA(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B类采用单例模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">B</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Java-内存分配策略"><a href="#4-Java-内存分配策略" class="headerlink" title="4. Java 内存分配策略"></a>4. Java 内存分配策略</h3><p>Java 程序运行时的内存分配策略有三种,分别是<strong>静态分配,栈式分配</strong>,和<strong>堆式分配</strong>，对应的，三种存储策略使用的内存空间主要分别是<strong>静态存储区（也称方法区）、栈区和堆区</strong>。</p><p><strong>静态存储区（方法区）</strong>：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</p><p><strong>栈区</strong> ：当方法被执行时，方法体内的局部变量（其中包括<strong>基础数据类型、对象的引用</strong>）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p><strong>堆区</strong> ： 又称<strong>动态内存分配</strong>，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 <strong>Java 垃圾回收器</strong>来负责回收。</p><ul><li>局部变量 的基本数据类型和引用存储于<strong>栈</strong>中，引用的对象实体存储于<strong>堆</strong>中。—— 因为它们属于方法中的变量，生命周期随方法而结束。</li><li>成员变量 <strong>全部存储于</strong>堆中（<em>包括基本数据类型，引用和引用的对象实体</em>）—— 因为它们属于类，类对象终究是要被new出来使用的。</li></ul><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】EasyExcel使用</title>
      <link href="/2022/06/04/17.easyExcel%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/06/04/17.easyExcel%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里只是列举下搬砖过程中常用的easy Excel操作，如需更复杂的操作见官网：<a href="https://www.yuque.com/easyexcel/doc">EasyExcel使用说明</a></p></blockquote><h1 id="一、读取Excel"><a href="#一、读取Excel" class="headerlink" title="一、读取Excel"></a>一、读取Excel</h1><h2 id="0-Excel表数据"><a href="#0-Excel表数据" class="headerlink" title="0. Excel表数据"></a>0. Excel表数据</h2><p><strong>sheet1：</strong></p><table><thead><tr><th>日期标题</th><th>标题</th><th>数字标题</th><th>日期二</th></tr></thead><tbody><tr><td>2022&#x2F;5&#x2F;25</td><td>标题1</td><td>20%</td><td>2040&#x2F;5&#x2F;25</td></tr><tr><td>2022&#x2F;5&#x2F;26</td><td>标题2</td><td>120%</td><td>2040&#x2F;5&#x2F;26</td></tr><tr><td>2022&#x2F;5&#x2F;27</td><td>标题3</td><td>220%</td><td>2040&#x2F;5&#x2F;27</td></tr><tr><td>2022&#x2F;5&#x2F;28</td><td>标题4</td><td>320%</td><td>2040&#x2F;5&#x2F;28</td></tr><tr><td>2022&#x2F;5&#x2F;29</td><td>标题5</td><td>555</td><td>2040&#x2F;5&#x2F;29</td></tr><tr><td>2022&#x2F;5&#x2F;30</td><td>标题6</td><td>666</td><td>2040&#x2F;5&#x2F;30</td></tr><tr><td>2022&#x2F;5&#x2F;31</td><td>标题7</td><td>777</td><td>2040&#x2F;5&#x2F;31</td></tr></tbody></table><p><strong>sheet2：</strong></p><table><thead><tr><th>日期标题</th><th>标题</th><th>数字标题</th><th>日期二</th></tr></thead><tbody><tr><td>2099&#x2F;1&#x2F;1</td><td>sheet2</td><td>1</td><td>2099&#x2F;7&#x2F;1</td></tr><tr><td>2099&#x2F;1&#x2F;2</td><td>sheet3</td><td>2</td><td>2099&#x2F;7&#x2F;2</td></tr><tr><td>2099&#x2F;1&#x2F;3</td><td>sheet4</td><td>3</td><td>2099&#x2F;7&#x2F;3</td></tr><tr><td>2099&#x2F;1&#x2F;4</td><td>sheet5</td><td>4</td><td>2099&#x2F;7&#x2F;4</td></tr><tr><td>2099&#x2F;1&#x2F;5</td><td>sheet6</td><td>5</td><td>2099&#x2F;7&#x2F;5</td></tr><tr><td>2099&#x2F;1&#x2F;6</td><td>sheet7</td><td>6</td><td>2099&#x2F;7&#x2F;6</td></tr><tr><td>2099&#x2F;1&#x2F;7</td><td>sheet8</td><td>7</td><td>2099&#x2F;7&#x2F;7</td></tr></tbody></table><p><strong>sheet3：</strong></p><table><thead><tr><th></th><th>测试3sheet</th><th></th><th></th></tr></thead><tbody><tr><td>日期标题</td><td>标题</td><td>数字标题</td><td>日期二</td></tr><tr><td>2099&#x2F;1&#x2F;1</td><td>sheet3</td><td>1</td><td>2099&#x2F;7&#x2F;1</td></tr><tr><td>2099&#x2F;1&#x2F;2</td><td>sheet3</td><td>2</td><td>2099&#x2F;7&#x2F;2</td></tr><tr><td>2099&#x2F;1&#x2F;3</td><td>sheet3</td><td>3</td><td>2099&#x2F;7&#x2F;3</td></tr><tr><td>2099&#x2F;1&#x2F;4</td><td>sheet3</td><td>4</td><td>2099&#x2F;7&#x2F;4</td></tr><tr><td>2099&#x2F;1&#x2F;5</td><td>sheet3</td><td>5</td><td>2099&#x2F;7&#x2F;5</td></tr><tr><td>2099&#x2F;1&#x2F;6</td><td>sheet3</td><td>6</td><td>2099&#x2F;7&#x2F;6</td></tr><tr><td>2099&#x2F;1&#x2F;7</td><td>sheet3</td><td>7</td><td>2099&#x2F;7&#x2F;7</td></tr></tbody></table><h2 id="1-不创建对象【读】"><a href="#1-不创建对象【读】" class="headerlink" title="1. 不创建对象【读】"></a>1. 不创建对象【读】</h2><h4 id="1-1-创建监听类"><a href="#1-1-创建监听类" class="headerlink" title="1.1 创建监听类"></a>1.1 创建监听类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoModelDataListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;Map&lt;Integer, String&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以100条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;Integer, String&gt;&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Map&lt;Integer, String&gt; data, AnalysisContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        cachedDataList.add(data);</span><br><span class="line">        <span class="keyword">if</span> (cachedDataList.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            saveData();</span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        saveData();</span><br><span class="line">        log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, cachedDataList.size());</span><br><span class="line">        log.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-读取数据"><a href="#1-2-读取数据" class="headerlink" title="1.2 读取数据"></a>1.2 读取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取第一个sheet，表头默认一行</span></span><br><span class="line">    EasyExcel.read(excelPath, <span class="keyword">new</span> <span class="title class_">NoModelDataListener</span>()).sheet().doRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-创建对象【读】"><a href="#2-创建对象【读】" class="headerlink" title="2. 创建对象【读】"></a>2. 创建对象【读】</h2><h3 id="2-1-创建对象类（指定列名或下标）"><a href="#2-1-创建对象类（指定列名或下标）" class="headerlink" title="2.1 创建对象类（指定列名或下标）"></a>2.1 创建对象类（指定列名或下标）</h3><ul><li><p>@ExcelProperty 可以指定读取第几列，指定转换器</p></li><li><p>@DateTimeFormat 接收日期，但是字段必须是String</p></li><li><p>@NumberFormat 接收百分比数字</p></li><li><p>@ExcelIgnore 忽略这个字段</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelData</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强制读取第二个 这里不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配</span></span><br><span class="line"><span class="comment">     * MyConverter.class 自定义转换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(converter = MyConverter.class, index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy/MM/dd&quot;)</span> <span class="comment">//这里用string 去接日期才能格式化</span></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;#.##%&quot;)</span> <span class="comment">//接收百分比数字</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;数字标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期二&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime localDateTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略这个字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String ignore;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-自定义easyExcel转换器"><a href="#2-2-自定义easyExcel转换器" class="headerlink" title="2.2 自定义easyExcel转换器"></a>2.2 自定义easyExcel转换器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; supportJavaTypeKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> String.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CellDataTypeEnum <span class="title function_">supportExcelTypeKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CellDataTypeEnum.STRING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里读的时候会调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convertToJavaData</span><span class="params">(ReadConverterContext&lt;?&gt; context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===&quot;</span>+context.getReadCellData().getStringValue());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;自定义：&quot;</span> + context.getReadCellData().getStringValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是写的时候会调用 不用管</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> WriteCellData&lt;?&gt; convertToExcelData(WriteConverterContext&lt;String&gt; context) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====&quot;</span>+context.getValue());</span><br><span class="line">        <span class="keyword">return</span> Converter.<span class="built_in">super</span>.convertToExcelData(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-创建监听类"><a href="#2-3-创建监听类" class="headerlink" title="2.3 创建监听类"></a>2.3 创建监听类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyDataListener</span> <span class="keyword">implements</span> <span class="title class_">ReadListener</span>&lt;ExcelData&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以100条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ExcelData&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TestDao demoDAO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyDataListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是demo，所以随便new一个。实际使用如果到了spring,使用下面的有参构造函数</span></span><br><span class="line">        demoDAO = <span class="keyword">new</span> <span class="title class_">TestDao</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来</span></span><br><span class="line"><span class="comment">     * 存数据库的dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EasyDataListener</span><span class="params">(TestDao demoDAO)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.demoDAO = demoDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(ExcelData data, AnalysisContext context)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;解析到一条数据:%s \n&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;开始睡1秒 %s&quot;</span>, <span class="string">&quot;====&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cachedDataList.add(data);</span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (cachedDataList.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;====缓存满了====&quot;</span>);</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">        log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-简单的5种读取方式"><a href="#2-4-简单的5种读取方式" class="headerlink" title="2.4 简单的5种读取方式"></a>2.4 简单的5种读取方式</h3><blockquote><p>常用的方式为1，2，3</p></blockquote><p><strong>（1）最方便的读</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 读取方式1：</span></span><br><span class="line"><span class="comment">  * 这里需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line"><span class="comment">  *（sheet 从0开始，不填默认为0）</span></span><br><span class="line"><span class="comment">  * 这里每次会读取3000条数据 然后返回过来 直接调用使用数据就行</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readExcel1</span><span class="params">()</span> &#123;</span><br><span class="line">    EasyExcel.read(inputStream, ExcelData.class, </span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">PageReadListener</span>&lt;ExcelData&gt;(list -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (ExcelData excelData : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取数据=&quot;</span> + excelData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).sheet().doRead(); <span class="comment">//sheet 从0开始，不填默认为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2） 匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取方式2：</span></span><br><span class="line"><span class="comment"> * 匿名内部类 不用额外写一个EasyDataListener</span></span><br><span class="line"><span class="comment"> * 这里需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line"><span class="comment"> * 这里每次会读取3000条数据 然后返回过来 直接调用使用数据就行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readExcel2</span><span class="params">()</span> &#123;</span><br><span class="line">    EasyExcel.read(inputStream, ExcelData.class, <span class="keyword">new</span> <span class="title class_">ReadListener</span>&lt;ExcelData&gt;() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(ExcelData data, AnalysisContext context)</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;解析到一条数据:%s \n&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).sheet().doRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）自定义Listener</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取方式3：</span></span><br><span class="line"><span class="comment"> * new EasyDataListener()</span></span><br><span class="line"><span class="comment"> * 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readExcel3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line">    EasyExcel.read(inputStream, ExcelData.class, <span class="keyword">new</span> <span class="title class_">EasyDataListener</span>()).sheet().doRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）try-with-resources读取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取方式4：</span></span><br><span class="line"><span class="comment"> * 使用 try-with-resources <span class="doctag">@since</span> 3.1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readExcel4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ExcelReader</span> <span class="variable">excelReader</span> <span class="operator">=</span> EasyExcel.read(inputStream, ExcelData.class, <span class="keyword">new</span> <span class="title class_">EasyDataListener</span>()).build()) &#123;</span><br><span class="line">        <span class="comment">// 构建一个sheet 这里可以指定名字或者no</span></span><br><span class="line">        <span class="type">ReadSheet</span> <span class="variable">readSheet</span> <span class="operator">=</span> EasyExcel.readSheet(<span class="number">0</span>).build();</span><br><span class="line">        <span class="comment">// 读取一个sheet</span></span><br><span class="line">        excelReader.read(readSheet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）不使用 try-with-resources读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写法5： 不使用 try-with-resources</span></span><br><span class="line"><span class="comment"> * 一个文件一个reader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readExcel5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExcelReader</span> <span class="variable">excelReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        excelReader = EasyExcel.read(excelPath, ExcelData.class, <span class="keyword">new</span> <span class="title class_">EasyDataListener</span>()).build();</span><br><span class="line">        <span class="comment">// 构建一个sheet 这里可以指定名字或者no</span></span><br><span class="line">        <span class="type">ReadSheet</span> <span class="variable">readSheet</span> <span class="operator">=</span> EasyExcel.readSheet(<span class="number">0</span>).build();</span><br><span class="line">        <span class="comment">// 读取一个sheet</span></span><br><span class="line">        excelReader.read(readSheet);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (excelReader != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span></span><br><span class="line">            excelReader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-读取多个sheet"><a href="#2-5-读取多个sheet" class="headerlink" title="2.5 读取多个sheet"></a>2.5 读取多个sheet</h3><blockquote><p>读多个或者全部sheet,这里注意一个sheet不能读取多次，多次读取需要重新读取文件</p><ol><li>创建excel对应的实体对象</li><li>由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器</li><li>直接读即可</li></ol></blockquote><p>（1）读取全部sheet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">multipartReadExcel1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 读取全部sheet</span></span><br><span class="line">    <span class="comment">// 这里需要注意EasyDataListener的doAfterAllAnalysed 会在每个sheet读取完毕后调用一次。</span></span><br><span class="line">    <span class="comment">// 然后所有sheet都会往同一个EasyDataListener里面写</span></span><br><span class="line">    EasyExcel.read(inputStream,ExcelData.class,<span class="keyword">new</span> <span class="title class_">EasyDataListener</span>()).doReadAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）读取部分sheet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">multipartReadExcel2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写法1： 使用 try-with-resources @since 3.1.0</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ExcelReader</span> <span class="variable">excelReader</span> <span class="operator">=</span> EasyExcel.read(inputStream).build()) &#123;</span><br><span class="line">            <span class="comment">// 这里为了简单 所以注册了 同样的head 和Listener 自己使用功能必须不同的Listener</span></span><br><span class="line">            <span class="type">ReadSheet</span> <span class="variable">readSheet1</span> <span class="operator">=</span></span><br><span class="line">                    EasyExcel.readSheet(<span class="number">0</span>).head(ExcelData.class).registerReadListener(<span class="keyword">new</span> <span class="title class_">EasyDataListener</span>()).build();</span><br><span class="line">            <span class="type">ReadSheet</span> <span class="variable">readSheet2</span> <span class="operator">=</span></span><br><span class="line">                    EasyExcel.readSheet(<span class="number">1</span>).head(ExcelData.class).registerReadListener(<span class="keyword">new</span> <span class="title class_">EasyDataListener</span>()).build();</span><br><span class="line">            <span class="comment">// 这里注意 一定要把sheet1 sheet2 一起传进去，不然有个问题就是03版的excel 会读取多次，浪费性能</span></span><br><span class="line">            excelReader.read(readSheet1, readSheet2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写法2： 不使用 try-with-resources</span></span><br><span class="line">        <span class="type">ExcelReader</span> <span class="variable">excelReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            excelReader = EasyExcel.read(inputStream).build();</span><br><span class="line">            <span class="comment">// 这里为了简单 所以注册了 同样的head 和Listener 自己使用功能必须不同的Listener</span></span><br><span class="line">            <span class="type">ReadSheet</span> <span class="variable">readSheet1</span> <span class="operator">=</span></span><br><span class="line">                    EasyExcel.readSheet(<span class="number">0</span>).head(ExcelData.class).registerReadListener(<span class="keyword">new</span> <span class="title class_">EasyDataListener</span>()).build();</span><br><span class="line">            <span class="type">ReadSheet</span> <span class="variable">readSheet2</span> <span class="operator">=</span></span><br><span class="line">                    EasyExcel.readSheet(<span class="number">1</span>).head(ExcelData.class).registerReadListener(<span class="keyword">new</span> <span class="title class_">EasyDataListener</span>()).build();</span><br><span class="line">            <span class="comment">// 这里注意 一定要把sheet1 sheet2 一起传进去，不然有个问题就是03版的excel 会读取多次，浪费性能</span></span><br><span class="line">            excelReader.read(readSheet1, readSheet2);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (excelReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span></span><br><span class="line">                excelReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-6-从第几行开始读"><a href="#2-6-从第几行开始读" class="headerlink" title="2.6 从第几行开始读"></a>2.6 从第几行开始读</h3><ul><li>sheet 从0开始，不填默认为0；</li><li>headRowNumber 这里可以设置1，因为头就是一行。两行头就填2；</li><li>如果多行头，可以设置其他值。不传入也可以，因为默认会根据DemoData 来解析，他没有指定头，也就是默认1行；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">headNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet</span></span><br><span class="line">    EasyExcel.read(inputStream, ExcelData.class, <span class="keyword">new</span> <span class="title class_">PageReadListener</span>&lt;ExcelData&gt;(list -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (ExcelData excelData : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取数据=&quot;</span> + excelData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).sheet(<span class="number">2</span>).headRowNumber(<span class="number">2</span>).doRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-读取表头数据"><a href="#2-7-读取表头数据" class="headerlink" title="2.7 读取表头数据"></a>2.7 读取表头数据</h3><ul><li>监听器里重写invokeHead(Map&lt;Integer, ReadCellData&lt;?&gt;&gt; headMap, AnalysisContext context)</li><li>获取数据：Map&lt;Integer, String&gt; map &#x3D; ConverterUtils.convertToStringMap(headMap, context);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyDataListener</span> <span class="keyword">implements</span> <span class="title class_">ReadListener</span>&lt;ExcelData&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeHead</span><span class="params">(Map&lt;Integer, ReadCellData&lt;?&gt;&gt; headMap, AnalysisContext context)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;解析到一条头数据:&#123;&#125;&quot;</span>, JSON.toJSONString(headMap));</span><br><span class="line">    Map&lt;Integer, String&gt; map = ConverterUtils.convertToStringMap(headMap, context);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、写入Excel"><a href="#二、写入Excel" class="headerlink" title="二、写入Excel"></a>二、写入Excel</h1><h2 id="0-创建对象类"><a href="#0-创建对象类" class="headerlink" title="0. 创建对象类"></a>0. 创建对象类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteData</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强制读/写 第二个 这里不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 1,value=&quot;标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;数字标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期二&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime localDateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-写入Excel【写】"><a href="#1-写入Excel【写】" class="headerlink" title="1. 写入Excel【写】"></a>1. 写入Excel【写】</h2><h3 id="1-1-常用的生成方式"><a href="#1-1-常用的生成方式" class="headerlink" title="1.1 常用的生成方式"></a>1.1 常用的生成方式</h3><p><strong>（1）方式一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">excelPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\xxxx\\Desktop\\data2.xlsx&quot;</span>;</span><br><span class="line">    List&lt;WriteData&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">WriteData</span> <span class="variable">excelData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteData</span>();</span><br><span class="line">        excelData.setDoubleData(<span class="number">22.123d</span>);</span><br><span class="line">        excelData.setDate(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        excelData.setTitle(<span class="string">&quot;标题&quot;</span> + i);</span><br><span class="line">        list.add(excelData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    EasyExcel.write(excelPath, WriteData.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）方式二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">excelPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\xxxx\\Desktop\\data2.xlsx&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写法1 JDK8+</span></span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    <span class="comment">// 如果这里想使用03 则 传入excelType参数即可</span></span><br><span class="line">    EasyExcel.write(excelPath, WriteData.class)</span><br><span class="line">            .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">            .doWrite(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 分页查询数据</span></span><br><span class="line">                List&lt;WriteData&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="type">WriteData</span> <span class="variable">excelData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteData</span>();</span><br><span class="line">                    excelData.setDoubleData(<span class="number">22.123d</span>);</span><br><span class="line">                    excelData.setDate(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                    excelData.setTitle(<span class="string">&quot;标题&quot;</span> + i);</span><br><span class="line">                    list.add(excelData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）方式三：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// （1）使用 try-with-resources</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> EasyExcel.write(excelPath, WriteData.class).build()) &#123;</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;模板&quot;</span>).build();</span><br><span class="line">        excelWriter.write(getData(), writeSheet);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;生成excel报错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2）不使用 try-with-resources</span></span><br><span class="line">    <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        excelWriter = EasyExcel.write(excelPath, WriteData.class).build();</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;模板&quot;</span>).build();</span><br><span class="line">        excelWriter.write(getData(), writeSheet);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 千万别忘记close 会帮忙关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (excelWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriter.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-指定列导出，或者排除列导出"><a href="#1-2-指定列导出，或者排除列导出" class="headerlink" title="1.2 指定列导出，或者排除列导出"></a>1.2 指定列导出，或者排除列导出</h3><ul><li>根据用户传入字段 假设我们要忽略 title</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里需要注意 在使用ExcelProperty注解的使用，如果想不空列则需要加入order字段，而不是index,</span></span><br><span class="line">    <span class="comment">// order会忽略空列，然后继续往后，而index，不会忽略空列，在第几列就是第几列。</span></span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; excludeColumn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    excludeColumn.add(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    EasyExcel.write(excelPath, WriteData.class)</span><br><span class="line">            .excludeColumnFieldNames(excludeColumn)</span><br><span class="line">            .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">            .doWrite(getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据用户传入字段 假设我们只要导出 doubleData</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; includeColumn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    includeColumn.add(<span class="string">&quot;doubleData&quot;</span>);</span><br><span class="line"></span><br><span class="line">    EasyExcel.write(excelPath, WriteData.class)</span><br><span class="line">        .includeColumnFieldNames(includeColumn)</span><br><span class="line">        .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">        .doWrite(getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-复杂头写入"><a href="#1-3-复杂头写入" class="headerlink" title="1.3 复杂头写入"></a>1.3 复杂头写入</h3><p>（1）新建对象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplexWriteData</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value= &#123;&quot;主标题&quot;,&quot;标题&quot;&#125;, index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@ExcelProperty(value= &#123;&quot;主标题&quot;,&quot;日期标题&quot;&#125;, index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="meta">@ExcelProperty(value= &#123;&quot;主标题&quot;,&quot;数字标题&quot;&#125;, index = 2)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">    <span class="meta">@ExcelProperty(value= &#123;&quot;主标题&quot;,&quot;日期二&quot;&#125;, index = 3)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime localDateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）写入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    EasyExcel.write(excelPath, ComplexWriteData.class)</span><br><span class="line">            .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">            .doWrite(getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-写入Excel格式化日期数字"><a href="#1-4-写入Excel格式化日期数字" class="headerlink" title="1.4 写入Excel格式化日期数字"></a>1.4 写入Excel格式化日期数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplexWriteData</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value= &#123;&quot;主标题&quot;,&quot;标题&quot;&#125;, index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写到excel 用年月日的格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy年MM月dd日HH时mm分ss秒&quot;)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value= &#123;&quot;主标题&quot;,&quot;日期标题&quot;&#125;, index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写到excel 用百分比表示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;#.##%&quot;)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value= &#123;&quot;主标题&quot;,&quot;数字标题&quot;&#125;, index = 2)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value= &#123;&quot;主标题&quot;,&quot;日期二&quot;&#125;, index = 3)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime localDateTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    EasyExcel.write(excelPath, ComplexWriteData.class)</span><br><span class="line">        .sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">        .doWrite(getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-5-写入图片"><a href="#1-5-写入图片" class="headerlink" title="1.5 写入图片"></a>1.5 写入图片</h3><p><strong>（1）创建对象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageDemoData</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果string类型 必须指定转换器，string默认转换成string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(converter = StringImageConverter.class)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] byteArray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据url导出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据文件导出 并设置导出的位置。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> WriteCellData&lt;Void&gt; writeCellDataFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）写入图片</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main2</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> FileUtils.openInputStream(<span class="keyword">new</span> <span class="title class_">File</span>(image))) &#123;</span><br><span class="line">        <span class="type">WriteImageData</span> <span class="variable">writeImageData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteImageData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入4种类型的图片 实际使用只要选一种即可,还有一种特别复杂</span></span><br><span class="line">        writeImageData.setFile(<span class="keyword">new</span> <span class="title class_">File</span>(image));</span><br><span class="line">        writeImageData.setInputStream(fileInputStream);</span><br><span class="line">        writeImageData.setString(image);</span><br><span class="line">        writeImageData.setByteArray(FileUtils.readFileToByteArray(<span class="keyword">new</span> <span class="title class_">File</span>(image)));</span><br><span class="line">        writeImageData.setUrl(<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://pics5.baidu.com/feed/a2cc7cd98d1001e952aaeac759f01fe656e79769.png?token=1fb595e57e083921a9a4ab263be9eaaf&quot;</span>));</span><br><span class="line">        List&lt;WriteImageData&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(writeImageData);</span><br><span class="line">        EasyExcel.write(excelPath, WriteImageData.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(list);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-设置表格宽高"><a href="#1-6-设置表格宽高" class="headerlink" title="1.6 设置表格宽高"></a>1.6 设置表格宽高</h3><ul><li><p>@HeadRowHeight(50) 设置表头高度，只能用在类上</p></li><li><p>@ContentRowHeight(150) 设置非表头的数据行高度，只能用在类上</p></li><li><p>@ColumnWidth(20) 设置列宽，可以用在字段和类上</p></li></ul><h1 id="三、try-with-resources用法"><a href="#三、try-with-resources用法" class="headerlink" title="三、try-with-resources用法"></a>三、try-with-resources用法</h1><blockquote><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。</p><p>所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。</p><p>所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。</p></blockquote><ol><li><p>凡是实现了AutoCloseable接口的类，在try()里声明该类实例的时候，在try结束后，close方法都会被调用；</p></li><li><p>try结束后自动调用的close方法，这个动作会早于finally里调用的方法；</p></li><li><p>不管是否出现异常（int i&#x3D;1&#x2F;0会抛出异常），try()里的实例都会被调用close方法；</p></li><li><p>越晚声明的对象，会越早被close掉。</p></li></ol><h2 id="1-关闭单一资源示例"><a href="#1-关闭单一资源示例" class="headerlink" title="1. 关闭单一资源示例"></a>1. 关闭单一资源示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>()) &#123;</span><br><span class="line">            res.doSome();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resource is closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> something</span><br><span class="line">resource is closed</span><br></pre></td></tr></table></figure><h2 id="2-关闭多个资源示例"><a href="#2-关闭多个资源示例" class="headerlink" title="2. 关闭多个资源示例"></a>2. 关闭多个资源示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main2</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ResourceSome</span> <span class="variable">some</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceSome</span>();</span><br><span class="line">            <span class="type">ResourceOther</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceOther</span>()) &#123;</span><br><span class="line">            some.doSome();</span><br><span class="line">            other.doOther();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceSome</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;some resource is closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceOther</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do other things&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;other resource is closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">do</span> other things</span><br><span class="line">other resource is closed</span><br><span class="line">some resource is closed</span><br></pre></td></tr></table></figure><p>可以看到在 try 语句中越是最后使用的资源，越是最早被关闭。 &#x3D;&#x3D;</p><h2 id="3-try-catch-finally和try-with-resources区别"><a href="#3-try-catch-finally和try-with-resources区别" class="headerlink" title="3. try-catch-finally和try-with-resources区别"></a>3. try-catch-finally和try-with-resources区别</h2><p>（1）<strong>try-catch-finally</strong>处理异常有两种情况：</p><ul><li>try 块没有发生异常时，直接调用finally块，如果 close 发生异常，就处理。</li><li>try 块发生异常，catch 块捕捉，进行第一处异常处理，然后调用 finally 块，如果 close 发生异常，就进行第二处异常处理。</li></ul><p>（2）<strong>try-with-resources</strong>处理异常有两种情况：</p><p><code>try-with-resources 在处理异常处理的时候，不论 try 中是否有异常，都会首先自动执行 close 方法，然后才判断是否进入 catch 块</code></p><ul><li>try 块没有发生异常时，自动调用 close 方法，如果发生异常，catch 块捕捉并处理异常。</li><li>try 块发生异常，然后自动调用 close 方法，如果 close 也发生异常，catch 块只会捕捉 try 块抛出的异常，close 方法的异常会在catch 中被压制，但是你可以在catch块中，用 Throwable.getSuppressed 方法来获取到压制异常的数组。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
            <tag> Java </tag>
            
            <tag> try-with-resources </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown制作流程图</title>
      <link href="/2022/06/04/16.markdown%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2022/06/04/16.markdown%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Markdown是一个轻量级的标记语言，使用普通文本编辑器就能快速编写，不仅显示格式丰富，功能也毫不含糊，分享一个md格式的API请求流程图。</p><p>在使用Markdown图表前，你首先需要有解析工具，在本地开发，用vs code再加Markdown preview插件，显然是可以胜任。</p><blockquote><p>由于有些浏览器渲染不出来，所以少数样式流程图带用了图片插入，在强解析下会呈现出相同的两个效果。</p></blockquote><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Markdown图表支持类型包括：</p><ul><li>流程图：指定 mermaid（样式流程图） 或 flow （标准流程图）解析语言</li><li>时序图：指定 sequence（标准时序图） 或 mermaid（样式时序图） 解析语言</li><li>甘特图：指定 mermaid 解析语言</li></ul><p>这些复杂图形的绘制都是使用代码块实现的，指定代码块的解析语言，按照响应的绘制语法即可实现。</p><h2 id="一、流程图"><a href="#一、流程图" class="headerlink" title="一、流程图"></a>一、流程图</h2><h2 id="1-1标准流程图"><a href="#1-1标准流程图" class="headerlink" title="1.1标准流程图"></a>1.1标准流程图</h2><h2 id="一个最简单的流程图"><a href="#一个最简单的流程图" class="headerlink" title="一个最简单的流程图"></a>一个最简单的流程图</h2><p><img src="https://pic3.zhimg.com/80/v2-c258f3c315826ae299c9cf26f275c55e_720w.jpeg" alt="img"></p><p>请点击输入图片描述</p><p>代码：</p><ol><li>`&#96;&#96;flow</li><li>start&#x3D;&gt;start: 接收到消息</li><li>info&#x3D;&gt;operation: 读取信息</li><li>setCache&#x3D;&gt;operation: 更新缓存</li><li>end&#x3D;&gt;end: 处理结束</li><li></li><li>start-&gt;info-&gt;setCache-&gt;end</li></ol><h2 id="简易四步骤流程图"><a href="#简易四步骤流程图" class="headerlink" title="简易四步骤流程图"></a>简易四步骤流程图</h2><p><img src="https://pic4.zhimg.com/80/v2-a06db48aca1dbf873f627f90220af04b_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><p>代码：</p><ol><li>`&#96;&#96;flow</li><li>st&#x3D;&gt;start: Start</li><li>op&#x3D;&gt;operation: Your Operation</li><li>cond&#x3D;&gt;condition: Yes or No?</li><li>e&#x3D;&gt;end</li><li>st-&gt;op-&gt;cond</li><li>cond(yes)-&gt;e</li><li>cond(no)-&gt;op</li></ol><h2 id="简易五步骤流程图"><a href="#简易五步骤流程图" class="headerlink" title="简易五步骤流程图"></a>简易五步骤流程图</h2><p><img src="https://pic4.zhimg.com/80/v2-180e839e72b127d9628e76b8ae9b0697_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><p>代码：</p><ol><li>`&#96;&#96;flow</li><li>start&#x3D;&gt;start: API请求</li><li>cache&#x3D;&gt;operation: 读取Redis缓存</li><li>cached&#x3D;&gt;condition: 是否有缓存？</li><li>sendMq&#x3D;&gt;operation: 发送MQ，后台服务更新缓存</li><li>info&#x3D;&gt;operation: 读取信息</li><li>setCache&#x3D;&gt;operation: 保存缓存</li><li>end&#x3D;&gt;end: 返回信息</li><li></li><li>start-&gt;cache-&gt;cached</li><li>cached(yes)-&gt;sendMq</li><li>cached(no)-&gt;info</li><li>info-&gt;setCache</li><li>setCache-&gt;end</li><li>sendMq-&gt;end</li></ol><h2 id="详解标准流程图"><a href="#详解标准流程图" class="headerlink" title="详解标准流程图"></a>详解标准流程图</h2><p>基本语法：</p><ul><li><p>定义模块 id&#x3D;&gt;关键字: 描述 （“描述”的前面必须有空格，“&#x3D;&gt;” 两端不能有空格）</p></li><li><p>关键字：</p></li><li><ul><li>start 流程开始，以圆角矩形绘制</li><li>opearation 操作，以直角矩形绘制</li><li>condition 判断，以菱形绘制</li><li>subroutine 子流程，以左右带空白框的矩形绘制</li><li>inputoutput 输入输出，以平行四边形绘制</li><li>end 流程结束，以圆角矩形绘制</li></ul></li><li><p>定义模块间的流向：</p></li><li><ul><li>模块1 id-&gt;模块2 id ：一般的箭头指向</li><li>条件模块id (描述)-&gt;模块id(direction) ：条件模块跳转到对应的执行模块，并指定对应分支的布局方向</li></ul></li></ul><p><strong>示例：</strong></p><p><img src="https://pic4.zhimg.com/80/v2-6d605b00cd02f6a60394124cddcb4d9b_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><p><strong>代码：</strong></p><ol><li>`&#96;&#96;flow</li><li>st&#x3D;&gt;start: 开始</li><li>ipt&#x3D;&gt;inputoutput: 输入一个x</li><li>op&#x3D;&gt;operation: 处理加工x+1</li><li>cond&#x3D;&gt;condition: 溢出（是或否？）</li><li>sub&#x3D;&gt;subroutine: 子流程</li><li>io&#x3D;&gt;inputoutput: 输出x</li><li>ed&#x3D;&gt;end: 结束</li><li></li><li>st-&gt;ipt-&gt;op-&gt;cond</li><li>cond(yes)-&gt;io-&gt;ed</li><li>cond(no)-&gt;sub-&gt;io-&gt;ed</li></ol><h2 id="复杂三支线流程图"><a href="#复杂三支线流程图" class="headerlink" title="复杂三支线流程图"></a>复杂三支线流程图</h2><p>效果：</p><p><img src="https://pic3.zhimg.com/80/v2-4400f6f6a20a7082ea689c580c5cc676_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><p>代码：</p><ol><li>`&#96;&#96;flow</li><li>st&#x3D;&gt;start: Start|past:&gt;<a href="https://link.zhihu.com/?target=http://www.google.com">http://www.google.com</a>[blank]</li><li>e&#x3D;&gt;end: End:&gt;<a href="https://link.zhihu.com/?target=http://www.google.com">http://www.google.com</a></li><li>op1&#x3D;&gt;operation: get_hotel_ids|past</li><li>op2&#x3D;&gt;operation: get_proxy|current</li><li>sub1&#x3D;&gt;subroutine: get_proxy|current</li><li>op3&#x3D;&gt;operation: save_comment|current</li><li>op4&#x3D;&gt;operation: set_sentiment|current</li><li>op5&#x3D;&gt;operation: set_record|current</li><li></li><li>cond1&#x3D;&gt;condition: ids_remain空?</li><li>cond2&#x3D;&gt;condition: proxy_list空?</li><li>cond3&#x3D;&gt;condition: ids_got空?</li><li>cond4&#x3D;&gt;condition: 爬取成功??</li><li>cond5&#x3D;&gt;condition: ids_remain空?</li><li></li><li>io1&#x3D;&gt;inputoutput: ids-remain</li><li>io2&#x3D;&gt;inputoutput: proxy_list</li><li>io3&#x3D;&gt;inputoutput: ids-got</li><li></li><li>st-&gt;op1(right)-&gt;io1-&gt;cond1</li><li>cond1(yes)-&gt;sub1-&gt;io2-&gt;cond2</li><li>cond2(no)-&gt;op3</li><li>cond2(yes)-&gt;sub1</li><li>cond1(no)-&gt;op3-&gt;cond4</li><li>cond4(yes)-&gt;io3-&gt;cond3</li><li>cond4(no)-&gt;io1</li><li>cond3(no)-&gt;op4</li><li>cond3(yes, right)-&gt;cond5</li><li>cond5(yes)-&gt;op5</li><li>cond5(no)-&gt;cond3</li><li>op5-&gt;e</li></ol><h2 id="1-2样式流程图"><a href="#1-2样式流程图" class="headerlink" title="1.2样式流程图"></a>1.2样式流程图</h2><p><strong>基本语法：</strong></p><ul><li><p>graph 指定流程图方向：graph LR 横向，graph TD 纵向</p></li><li><p>元素的形状定义：</p></li><li><ul><li>id[描述] 以直角矩形绘制</li><li>id(描述) 以圆角矩形绘制</li><li>id{描述} 以菱形绘制</li><li>id&gt;描述] 以不对称矩形绘制</li><li>id((描述)) 以圆形绘制</li></ul></li><li><p>线条定义：</p></li><li><ul><li>A–&gt;B 带箭头指向</li><li>A—B 不带箭头连接</li><li>A-.-B 虚线连接</li><li>A-.-&gt;B 虚线指向</li><li>A&#x3D;&#x3D;&gt;B 加粗箭头指向</li><li>A–描述—B 不带箭头指向并在线段中间添加描述</li><li>A–描述–&gt;B 带描述的箭头指向</li><li>A-.描述.-&gt;B 带描述的虚线连指向</li><li>A&#x3D;&#x3D;描述&#x3D;&#x3D;&gt;B 带描述的加粗箭头指向</li></ul></li><li><p>子流程图定义</p></li><li><p>subgraph title</p></li><li><p>graph direction</p></li><li><p>end</p></li></ul><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-6a2d7bde8cf5e3f4a0122f51b15efe9c_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><ol><li>graph LR</li><li>A(开始) –&gt;B(起床)</li><li>B –天气不好— C&gt;干活]</li><li>C &#x3D;&#x3D;&gt; D{休息时间到了}</li><li>D -.yes.-&gt; E((休息))</li><li>D -.no.-&gt; C</li><li>E –&gt; F(吃饭)</li></ol><p>代码：</p><ol><li>`&#96;&#96;mermaid</li><li>graph LR</li><li>A(开始) –&gt;B(起床)</li><li>B –天气不好— C&gt;干活]</li><li>C &#x3D;&#x3D;&gt; D{休息时间到了}</li><li>D -.yes.-&gt; E((休息))</li><li>D -.no.-&gt; C</li><li>E –&gt; F(吃饭)</li></ol><h2 id="二、时序图"><a href="#二、时序图" class="headerlink" title="二、时序图"></a>二、时序图</h2><p>时序图（Sequence Diagram）用于描述对象之间发送消息的时间顺序或显示多个对象之间的动态协作。时序图中的每条消息对应一个类操作或一个事件。</p><p>时序图元素<br>时序图主要有一下几个元素：角色，对象，生命线，激活器和消息</p><ul><li>1、角色（Actor）<br>任何主体都可以是角色，角色对外发布消息。示例中，客户端，打印机，数据库都是角色。</li><li>2，对象(Object)<br>对象代表时序图中的对象在交互中所扮演的角色，位于时序图顶部和对象代表类角色。有的时候可能有多个打印机 ，那么这些打印机都是同一角色的不同对象</li><li>3，生命线(Lifeline)<br>生命线代表时序图中的对象在一段时期内的存在。时序图中每个对象和底部中心都有一条垂直的线，这就是对象的生命线，对象间 的消息存在于两条虚线间。</li><li>4，激活期(Activation)<br>激活期代表时序图中的对象执行一项操作的时期，在时序图中每条生命线上的窄的矩形代表活动期。它可以被理解成C语言语义中一对花括号“{}”中的内容。csdn的Markdown中并没有这一举行，只能以右侧或左侧的注解来表示“&#96; python</li><li>5，消息(Message)<br>消息是定义交互和协作中交换信息的类，用于对实体间的通信内容建模，信息用于在实体间传递信息。允许实体请求其他的服务，类角色通过发送和接受信息进行通信。</li></ul><h2 id="2-1标准时序图"><a href="#2-1标准时序图" class="headerlink" title="2.1标准时序图"></a>2.1标准时序图</h2><p>基本语法：</p><ul><li><p>Title:标题 ：指定时序图的标题</p></li><li><p>Note direction of 对象:描述 ： 在对象的某一侧添加描述，direction 可以为 right&#x2F;left&#x2F;over ， 对象 可以是多个对象，以 , 作为分隔符</p></li><li><p>participant 对象 ：创建一个对象</p></li><li><p>loop…end ：创建一个循环体</p></li><li><p>对象A-&gt;对象B:描述 ： 绘制A与B之间的对话，以实线连接</p></li><li><ul><li>-&gt; 实线实心箭头指向</li><li>–&gt; 虚线实心箭头指向</li><li>-&gt;&gt; 实线小箭头指向</li><li>–&gt;&gt; 虚线小箭头指向</li></ul></li></ul><p><strong>示例：</strong></p><p><img src="https://pic4.zhimg.com/80/v2-dbb871bd66086a9f52789a2a49ca95e3_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><p><strong>代码：</strong></p><ol><li>`&#96;&#96;sequence</li><li>Title:时序图示例</li><li>客户端-&gt;服务端: 我想找你拿下数据 SYN</li><li>服务端–&gt;客户端: 我收到你的请求啦 ACK+SYN</li><li>客户端-&gt;&gt;服务端: 我收到你的确认啦，我们开始通信吧 ACK</li><li>Note right of 服务端: 我是一个服务端</li><li>Note left of 客户端: 我是一个客户端</li><li>Note over 服务端,客户端: TCP 三次握手</li><li>participant 观察者</li></ol><p>再来一个UML时序图：</p><p><img src="https://pic4.zhimg.com/80/v2-b36250103b8bf98ed58561c512c1dfc3_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><p>代码：</p><ol><li>`&#96;&#96; sequence</li><li>客户端-&gt;打印机: 打印请求(id)</li><li>打印机-&gt;数据库:请求数据(id)</li><li>Note right of 数据库: 执行SQL获取数据</li><li>数据库–&gt;打印机:返回数据信息</li><li>Note right of 打印机:使用数据打印</li><li>打印机–&gt;&gt;客户端:返回打印结果</li><li>客户端-&gt;客户端:等待提取结果</li></ol><h2 id="2-2带样式时序图"><a href="#2-2带样式时序图" class="headerlink" title="2.2带样式时序图"></a>2.2带样式时序图</h2><p>基本语法同标准时序图，不同的是</p><ul><li><p>需要使用 mermaid 解析，并在开头使用关键字 sequenceDiagram 指明</p></li><li><p>线段的样式遵循 mermaid 的解析方式</p></li><li><ul><li>-&gt; ： 实线连接</li><li>–&gt; ：虚线连接</li><li>-&gt;&gt; ：实线箭头指向</li><li>–&gt;&gt; ：虚线箭头指向</li></ul></li></ul><p>示例：</p><p><img src="https://pic3.zhimg.com/80/v2-d67163fd6e8b18f21291fbaa80e47c82_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><ol><li>sequenceDiagram</li><li>对象A-&gt;对象B:中午吃什么？</li><li>对象B-&gt;&gt;对象A: 随便</li><li>loop 思考</li><li>对象A-&gt;对象A: 努力搜索</li><li>end</li><li>对象A–&gt;&gt;对象B: 火锅？</li><li>对象B-&gt;&gt;对象A: 可以</li><li>Note left of 对象A: 我是一个对象A</li><li>Note right of 对象B: 我是一个对象B</li><li>participant 对象C</li><li>Note over 对象C: 我自己说了算</li></ol><p>代码：</p><ol><li>`&#96;&#96;mermaid</li><li>sequenceDiagram</li><li>对象A-&gt;对象B:中午吃什么？</li><li>对象B-&gt;&gt;对象A: 随便</li><li>loop 思考</li><li>对象A-&gt;对象A: 努力搜索</li><li>end</li><li>对象A–&gt;&gt;对象B: 火锅？</li><li>对象B-&gt;&gt;对象A: 可以</li><li>Note left of 对象A: 我是一个对象A</li><li>Note right of 对象B: 我是一个对象B</li><li>participant 对象C</li><li>Note over 对象C: 我自己说了算</li></ol><h2 id="三、甘特图"><a href="#三、甘特图" class="headerlink" title="三、甘特图"></a>三、甘特图</h2><p>基本语法：</p><ul><li><p>使用 mermaid 解析语言，在开头使用关键字 gantt 指明</p></li><li><p>deteFormat 格式 指明日期的显示格式</p></li><li><p>title 标题 设置图标的标题</p></li><li><p>section 描述 定义纵向上的一个环节</p></li><li><p>定义步骤：每个步骤有两种状态 done（已完成）&#x2F; active（执行中）</p></li><li><ul><li>描述: 状态,id,开始日期,结束日期&#x2F;持续时间</li><li>描述: 状态[,id],after id2,持续时间</li><li>crit ：可用于标记该步骤需要被修正，将高亮显示</li><li>如果不指定具体的开始时间或在某个步骤之后，将默认依次顺序排列</li></ul></li></ul><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-7c0612e72743491c3f8579a5d6e9c978_720w.jpg" alt="img"></p><p>请点击输入图片描述</p><ol><li>gantt</li><li>dateFormat YYYY-MM-DD</li><li></li><li>title 软件开发甘特图</li><li></li><li>section 设计</li><li>需求:done,des1, 2019-01-06,2019-01-08</li><li>原型:active,des2, 2019-01-09, 3d</li><li>UI设计:des3, after des2, 5d</li><li>未来任务:des4, after des3, 5d</li><li></li><li>section 开发</li><li>学习准备理解需求:crit, done, 2019-01-06,24h</li><li>设计框架:crit, done, after des2, 2d</li><li>开发:crit, active, 3d</li><li>未来任务:crit, 5d</li><li>休息时间:2d</li><li></li><li>section 测试</li><li>功能测试:active, a1, after des3, 3d</li><li>压力测试:after a1, 20h</li><li>测试报告: 48h</li></ol><p>代码：</p><ol><li>`&#96;&#96;mermaid</li><li>gantt</li><li>dateFormat YYYY-MM-DD</li><li></li><li>title 软件开发甘特图</li><li></li><li>section 设计</li><li>需求:done,des1, 2019-01-06,2019-01-08</li><li>原型:active,des2, 2019-01-09, 3d</li><li>UI设计:des3, after des2, 5d</li><li>未来任务:des4, after des3, 5d</li><li></li><li>section 开发</li><li>学习准备理解需求:crit, done, 2019-01-06,24h</li><li>设计框架:crit, done, after des2, 2d</li><li>开发:crit, active, 3d</li><li>未来任务:crit, 5d</li><li>休息时间:2d</li><li></li><li>section 测试</li><li>功能测试:active, a1, after des3, 3d</li><li>压力测试:after a1, 20h</li><li>测试报告: 48h</li></ol><h2 id="用Gravizo第三方插件画流程图"><a href="#用Gravizo第三方插件画流程图" class="headerlink" title="用Gravizo第三方插件画流程图"></a>用Gravizo第三方插件画流程图</h2><p>介绍一个在markdown中插入流程图、各种图的方法<br><a href="https://link.zhihu.com/?target=http://g.gravizo.com">http://g.gravizo.com</a></p><p>打开上面这个网站, 这个网站提供动态生成各种图的http接口<br>像这样使用, 接口根据传入的参数返回图，免费版带一个西文LOGO水印。</p>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费CDN加速Github资源</title>
      <link href="/2022/05/21/15.%E5%85%8D%E8%B4%B9CDN%E5%8A%A0%E9%80%9FGitHub%E8%B5%84%E6%BA%90/"/>
      <url>/2022/05/21/15.%E5%85%8D%E8%B4%B9CDN%E5%8A%A0%E9%80%9FGitHub%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="开源还得看国外"><a href="#开源还得看国外" class="headerlink" title="开源还得看国外"></a>开源还得看国外</h1><blockquote><p>5月19号的时候 搭建的GitHub图床图片访问不了了，发现是原来的CDN（jsDelivr）加速被墙了，gitee听说禁止用来做图床，会被封；</p><p>然后又是替换原来博客主题（Butterfly）的 js地址，又是搞图床，图床试了下腾讯的cos，发现存储要收费，访问流量要收费，操作图片也要收费，虽然费用不高，但是还是有点不爽（<del>没办法白嫖</del>）；</p><p>虽然5月21号上午 jsdelivr已经恢复了，但是忧患意识还是要有的，搜了下其他免费的CDN，看了一圈，国内的虽然有免费的，但是要注册，国外的直接替换地址就可以了，还是外国的老爷们大方，记录下国内外的CDN吧，我只是搬运工；</p><p>目前只是用作GitHub的，其他用途没试过。</p></blockquote><h2 id="1-JsDelivr"><a href="#1-JsDelivr" class="headerlink" title="1. JsDelivr"></a>1. <a href="https://www.jsdelivr.com/">JsDelivr</a></h2><p>（1）GitHub原地址：</p><p><a href="https://raw.githubusercontent.com/unravelyt/image-hosting/master/base_img/avatar.4zr2jgjmhq80.webp">https://raw.githubusercontent.com/unravelyt/image-hosting/master/base_img/avatar.4zr2jgjmhq80.webp</a></p><p>（2）替换后：</p><p>经常失效不推荐：<code>https://cdn.jsdelivr.net/gh/unravelyt/image-hosting**@**master/base_img/avatar.4zr2jgjmhq80.webp</code></p><p>推荐使用：<code>https://fastly.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/SecurityContextHolder.637wmh9seyg0.png</code></p><p>（3）替换规则：</p><p>&#x2F;unravelyt&#x2F;image-hosting&#x2F;master&#x2F;base_img&#x2F;avatar.4zr2jgjmhq80.webp</p><p>对应关系：</p><p>unravelyt &#x3D; GitHub用户id</p><p>image-hosting &#x3D; 仓库名称</p><p>master &#x3D; 仓库分支</p><p>base_img &#x3D; 文件夹名称</p><p>avatar.4zr2jgjmhq80.webp &#x3D; 文件名称</p><p>将<code>https://raw.githubusercontent.com/</code>替换为<code>https://cdn.jsdelivr.net/gh/</code> 或者<code>https://fastly.jsdelivr.net/gh/</code></p><p>将<code>/master</code>替换为 <code>@master</code></p><h2 id="2-Sevencdn"><a href="#2-Sevencdn" class="headerlink" title="2. Sevencdn"></a>2. <a href="https://pangniao.net/tag/Sevencdn/">Sevencdn</a></h2><p>Sevencdn有两个cdn域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raw.sevencdn.com` 国内cdn，但是因为滥用增加了白名单限制</span><br><span class="line">只有在白名单中的github仓库才能使用，其他仓库的[资源](https://pangniao.net/tag/资源/)会自动跳转到 raw.githubusercontents.com</span><br></pre></td></tr></table></figure><p><code>raw.githubusercontents.com</code>为中国香港cdn节点，国内访问速度也是很不错的，但是也因为滥用进行了限速。</p><blockquote><p>由于滥用，现对 raw.githubusercontents.com 进行限速，策略如下：</p><ul><li>小于 1M 的文件不限速</li><li>超过 1M 的文件，超过部分限速 100K&#x2F;s<br>若滥用情况继续，则<strong>未来</strong>采用如下限速策略：</li><li>限速 10K&#x2F;s</li></ul></blockquote><p>替换规则</p><p>三个域名替换规则，将 raw.githubusercontent.com 替换为</p><p><strong>raw.sevencdn.com</strong></p><p>或<strong>raw.staticdn.net</strong></p><p>或<strong>raw.githubusercontents.com</strong> 即可加速。</p><h2 id="3-91chi-fun"><a href="#3-91chi-fun" class="headerlink" title="3. 91chi.fun"></a>3. <a href="https://github.91chi.fun/">91chi.fun</a></h2><blockquote><p>这个有个插件可以直接使用：<a href="https://github.com/fhefh2015/Fast-GitHub">fhefh2015&#x2F;Fast-GitHub: 国内Github下载很慢，用上了这个插件后，下载速度嗖嗖嗖的~！</a></p></blockquote><p>（1）GitHub原地址：</p><p><a href="https://raw.githubusercontent.com/unravelyt/image-hosting/master/base_img/icon1.webp">https://raw.githubusercontent.com/unravelyt/image-hosting/master/base_img/icon1.webp</a></p><p>（2）替换后：</p><p><strong><a href="https://github.91chi.fun/">https://github.91chi.fun</a></strong>&#x2F;<a href="https://raw.githubusercontent.com/unravelyt/image-hosting/master/base_img/icon1.webp">https://raw.githubusercontent.com/unravelyt/image-hosting/master/base_img/icon1.webp</a></p><p>（3）替换规则：</p><p>直接在地址前面加上<code>https://github.91chi.fun/</code></p><p>备选：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://github.91chi.fun/</span><br><span class="line">https://ghproxy.com/</span><br><span class="line">https://github.abskoop.workers.dev</span><br><span class="line">https://gh.api.99988866.xyz</span><br></pre></td></tr></table></figure><p>也可以访问网站输入地址：<a href="https://github.91chi.fun/">https://github.91chi.fun/</a></p><h2 id="4-staticaly"><a href="#4-staticaly" class="headerlink" title="4. staticaly"></a>4. <a href="https://www.staticaly.com/">staticaly</a></h2><p>（1）GitHub原地址：</p><p><a href="https://raw.githubusercontent.com/unravelyt/image-hosting/master/base_img/icon1.webp">https://raw.githubusercontent.com/unravelyt/image-hosting/master/base_img/icon1.webp</a></p><p>（2）替换后：</p><p><strong><a href="https://cdn.staticaly.com/gh">https://cdn.staticaly.com/gh</a></strong>&#x2F;unravelyt&#x2F;image-hosting&#x2F;master&#x2F;base_img&#x2F;icon1.webp</p><p>（3）替换规则：</p><blockquote><p>GitHub CDN</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/gh/:user/:repo/:tag/:file</span><br></pre></td></tr></table></figure><blockquote><p>GitLab CDN</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/gl/:user/:repo/:tag/:file</span><br></pre></td></tr></table></figure><blockquote><p>Bitbucket CDN</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/bb/:user/:repo/:tag/:file</span><br></pre></td></tr></table></figure><blockquote><p>WordPress CDN</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/wp/c/:version/wp-includes/:file  </span><br><span class="line">https://cdn.staticaly.com/wp/p/:plugin_name/:version/:file  </span><br><span class="line">https://cdn.staticaly.com/wp/t/:theme_name/:version/:file</span><br></pre></td></tr></table></figure><blockquote><p>Imgpx CDN</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/img/:image_url</span><br></pre></td></tr></table></figure><blockquote><p>Favicons CDN</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/favicons/:favicon_url</span><br></pre></td></tr></table></figure><h2 id="5-npm"><a href="#5-npm" class="headerlink" title="5. npm"></a>5. npm</h2><p>前端一般会引入很多的外部的js，css，收集癖的我也找到了些npm的CDN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">https://unpkg.com/social-share.js/dist/css/share.min.css</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">https://beecdn.com/</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">http://www.staticfile.org/</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line">https://www.npmjs.com/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> CDN </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建基础镜像</title>
      <link href="/2022/05/17/14.docker%20%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6/"/>
      <url>/2022/05/17/14.docker%20%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础镜像"><a href="#Java基础镜像" class="headerlink" title="Java基础镜像"></a>Java基础镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull anapsix/alpine-java:8_server-jre_unlimited 46M</span><br><span class="line"></span><br><span class="line">docker pull fabric8/java-alpine-openjdk11-jre:1.8  64M</span><br><span class="line"></span><br><span class="line">docker pull bitnami/java:1.8 158M</span><br><span class="line"></span><br><span class="line">docker pull fabric8/java-centos-openjdk8-jre:1.8  145.61 MB</span><br></pre></td></tr></table></figure><h2 id="docker网络相关"><a href="#docker网络相关" class="headerlink" title="docker网络相关"></a>docker网络相关</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#获取所有运行的容器内网IP</span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; </span><br><span class="line"></span><br><span class="line">#创建docker网络</span><br><span class="line">docker network create --subnet=172.18.0.0/16 myNetwork</span><br><span class="line"></span><br><span class="line">#列举出现有的网络</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME        DRIVER    SCOPE</span><br><span class="line">4d23d22e92c4   bridge      bridge    local</span><br><span class="line">ea73c5b3aaf9   host        host      local</span><br><span class="line">2108cff882c7   none        null      local</span><br><span class="line"></span><br><span class="line"># 移除网络</span><br><span class="line">docker network rm xxx</span><br><span class="line"></span><br><span class="line"># 查看网络信息</span><br><span class="line">docker inspect xxx</span><br><span class="line"></span><br><span class="line">两个容器需要在同一个网络里面</span><br><span class="line">docker run  -itd  -p 5001:5001 --name 镜像名称 </span><br><span class="line">--net myNetwork --ip 172.18.0.2 --privileged=true </span><br><span class="line">--restart=always -d 镜像名称</span><br><span class="line"></span><br><span class="line">172.18.0.1 是网关 不能用所以要从172.18.0.1 开始</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="0-安装-portainer"><a href="#0-安装-portainer" class="headerlink" title="0 安装 portainer"></a>0 安装 portainer</h2><ol><li>拉取镜像<blockquote><p>docker pull portainer&#x2F;portainer</p></blockquote></li><li>执行run命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data \</span><br><span class="line">portainer/portainer</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://192.168.244.128:9000/">http://192.168.244.128:9000/</a></p><p>登录密码：admin123</p></blockquote></li></ol><hr><h2 id="1-安装nacos"><a href="#1-安装nacos" class="headerlink" title="1 安装nacos"></a>1 安装nacos</h2><ol><li>拉取镜像<blockquote><p>docker pull nacos&#x2F;nacos-server:v2.0.4</p></blockquote></li><li>执行run命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取mysql容器 IP （每次重启容器IP都会变）</span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; </span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d -p 8848:8848 --restart always \</span></span><br><span class="line"><span class="language-bash">-e MODE=standalone \</span></span><br><span class="line"><span class="language-bash">-e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> \</span></span><br><span class="line"><span class="language-bash">-e PREFER_HOST_MODE=hostname \</span></span><br><span class="line"><span class="language-bash">-e SPRING_DATASOURCE_PLATFORM=mysql \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_HOST=172.17.0.4 \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_PORT=3306 \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_DB_NAME=nacos \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_USER=root \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_PASSWORD=root \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_DATABASE_NUM=1 \</span></span><br><span class="line"><span class="language-bash">--name nacos nacos/nacos-server:v2.0.4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">固定ip</span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d -p 8848:8848 --restart always \</span></span><br><span class="line"><span class="language-bash">--net myNetwork --ip 172.18.0.3 \</span></span><br><span class="line"><span class="language-bash">-e MODE=standalone \</span></span><br><span class="line"><span class="language-bash">-e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> \</span></span><br><span class="line"><span class="language-bash">-e PREFER_HOST_MODE=hostname \</span></span><br><span class="line"><span class="language-bash">-e SPRING_DATASOURCE_PLATFORM=mysql \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_HOST=172.18.0.2 \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_PORT=3306 \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_DB_NAME=nacos \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_USER=root \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_SERVICE_PASSWORD=root \</span></span><br><span class="line"><span class="language-bash">-e MYSQL_DATABASE_NUM=1 \</span></span><br><span class="line"><span class="language-bash">--name nacos nacos/nacos-server:v2.0.4</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简易版(配置不持久化，容器没了配置就没了)：</span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d -p 8848:8848 --restart always \</span></span><br><span class="line"><span class="language-bash">-e MODE=standalone -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--name nacos nacos/nacos-server:v2.0.4</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">集群：</span><br><span class="line">docker run -d --name nacos-cluster -p 8848:8848 \</span><br><span class="line">  --env NACOS_SERVERS=192.168.56.102,192.168.56.104,192.168.56.105 \</span><br><span class="line">  --env NACOS_SERVER_IP=192.168.56.102 \</span><br><span class="line">  --env SPRING_DATASOURCE_PLATFORM=mysql \</span><br><span class="line">  --env MYSQL_SERVICE_HOST=192.168.56.103 \</span><br><span class="line">  --env MYSQL_SERVICE_DB_NAME=nacos \</span><br><span class="line">  --env MYSQL_SERVICE_USER=root \</span><br><span class="line">  --env MYSQL_SERVICE_PASSWORD=root \</span><br><span class="line">  --env MYSQL_DATABASE_NUM=1 \</span><br><span class="line">  nacos/nacos-server</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">NACOS_SERVERS : 集群节点信息</span><br><span class="line">NACOS_SERVER_IP : 服务IP，多网卡模式下建议指定</span><br><span class="line">SPRING_DATASOURCE_PLATFORM : 使用数据库类型</span><br><span class="line">MYSQL_SERVICE_HOST : MySQL数据库地址</span><br><span class="line">MYSQL_SERVICE_DB_NAME : 数据库名称</span><br><span class="line">MYSQL_SERVICE_DB_NAME : 数据库用户名</span><br><span class="line">MYSQL_SERVICE_PASSWORD : 数据库密码</span><br><span class="line">MYSQL_DATABASE_NUM : 数据库数量，默认就是1，可以不填写</span><br></pre></td></tr></table></figure><ol start="3"><li>更改配置文件(可选)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it nacos bash \r</span><br><span class="line"></span><br><span class="line">vim /home/nacos/conf/application.properties</span><br><span class="line"></span><br><span class="line">需要的话加上</span><br><span class="line">&amp;useSSL=truee&amp;serverTimezone=UTC</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="2-安装-Mysql-5-7-amp-8-0"><a href="#2-安装-Mysql-5-7-amp-8-0" class="headerlink" title="2 安装 Mysql 5.7 &amp; 8.0"></a>2 安装 Mysql 5.7 &amp; 8.0</h2><ol><li><p>拉取镜像</p><blockquote><p>docker pull mysql:5.7</p><p>docker pull mysql:8.0</p></blockquote></li><li><p>执行 run 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不挂载(推荐)：</span><br><span class="line">docker run -p 3306:3306 --name mysql --restart=always \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root -e TZ=&quot;Asia/Shanghai&quot; -d mysql:8.0</span><br><span class="line"></span><br><span class="line">docker rm -f mysql</span><br><span class="line"></span><br><span class="line">docker cp mysql:/etc/mysql/my.cnf /data/docker-volume/mysql/config/</span><br></pre></td></tr></table></figure></li></ol><p>固定容器ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql --restart=always \</span><br><span class="line">--net myNetwork --ip 172.18.0.2 \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root -e TZ=&quot;Asia/Shanghai&quot; -d mysql:8.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql --restart=always \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-v /data/docker-volume/mysql/config/:/etc/mysql/my.cnf \</span><br><span class="line">-v /data/docker-volume/mysql/mysql-files:/var/lib/mysql-files \</span><br><span class="line">-e TZ=&quot;Asia/Shanghai&quot; -d mysql:8.0</span><br></pre></td></tr></table></figure><ol start="5"><li>时间相差8小时处理</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql查询当前时间：</span><br><span class="line">&gt; select now();</span><br><span class="line"></span><br><span class="line">&gt; docker cp /etc/localtime mysql:/etc/localtime</span><br><span class="line"></span><br><span class="line">注意：因为时区问题可能上面命令会报下面错误</span><br><span class="line">Error response from daemon: Error processing tar file(exit status 1): invalid symlink &quot;/etc/localtime&quot; -&gt; &quot;../usr/share/zoneinfo/Asia/Shanghai&quot;</span><br><span class="line"></span><br><span class="line">解决方法：切换命令</span><br><span class="line">&gt; docker cp /usr/share/zoneinfo/Asia/Shanghai[容器ID或者NAME]:/etc/localtime</span><br></pre></td></tr></table></figure><br><hr><h2 id="3-安装-Postgres-14-1"><a href="#3-安装-Postgres-14-1" class="headerlink" title="3 安装 Postgres 14.1"></a>3 安装 Postgres 14.1</h2><ol><li>拉取镜像<blockquote><p>docker pull postgres:14.1</p></blockquote></li><li>执行run命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=postgres -p 5432:5432 \</span><br><span class="line">-e POSTGRES_PASSWORD=root -e TZ=&quot;Asia/Shanghai&quot; -d postgres:14.1</span><br></pre></td></tr></table></figure></li></ol><br><hr><h2 id="4-安装-Redis"><a href="#4-安装-Redis" class="headerlink" title="4 安装 Redis"></a>4 安装 Redis</h2><ol><li><p>拉取镜像</p><blockquote><p>docker pull redis:latest</p></blockquote></li><li><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/docker-volume/redis/</span><br><span class="line"></span><br><span class="line">cd /data/docker-volume/redis/</span><br><span class="line"></span><br><span class="line">wget http://download.redis.io/redis-stable/redis.conf</span><br><span class="line"></span><br><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure><blockquote><p>*注释掉bind 127.0.0.1, 或者修改bind 0.0.0.0,表示允许所有ip地址访问<br></p><p>*修改peotected-mode yes  <br><br>改为：protected-mode no.  <br><br>protected-mode参数是为了禁止外网访问redis,如果启用了，<br>则只能够通过localhost ip (127.0.0.1)访问Redis <br></p><p>daemonize no #用守护线程的方式启动 <br><br>requirepass root #给redis设置密码 密码要复杂，不然就会被黑<br><br>appendonly yes #redis持久化　　默认是no <br><br>tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300</p></blockquote></li><li><p>执行run命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 --restart=always \</span><br><span class="line">-e TZ=&quot;Asia/Shanghai&quot; \</span><br><span class="line">-v /data/docker-volume/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis:latest /etc/redis/redis.conf</span><br></pre></td></tr></table></figure></li></ol><br><hr><h2 id="5-安装-wurstmeister-x2F-kafka-（推荐）"><a href="#5-安装-wurstmeister-x2F-kafka-（推荐）" class="headerlink" title="5 安装 wurstmeister&#x2F;kafka （推荐）"></a>5 安装 wurstmeister&#x2F;kafka （推荐）</h2><ol><li>拉取镜像<blockquote><p>docker pull zookeeper:3.8.0<br>docker pull wurstmeister&#x2F;kafka:2.13-2.8.1</p></blockquote></li><li>启动 zookeeper</li></ol><blockquote><p>-p 2888:2888 -p 3888:3888 <br><br>1、2181：对cline端提供服务 <br><br>2、3888：选举leader使用<br><br>3、2888：集群内机器通讯使用（Leader监听此端口）<br></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 2181:2181 --name zookeeper --restart=always \</span><br><span class="line">-e TZ=&quot;Asia/Shanghai&quot; \</span><br><span class="line">-e JVMFLAGS=&quot;-Xmx256M -Xms256M&quot; \</span><br><span class="line">-d zookeeper:3.7.0</span><br></pre></td></tr></table></figure><ol start="3"><li>启动 kafka</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 9092:9092 --link zookeeper \</span><br><span class="line">-e KAFKA_BROKER_ID=0 \</span><br><span class="line">-e KAFKA_CREATE_TOPICS=&quot;topic-test1:2:1&quot; \</span><br><span class="line">-e KAFKA_ZOOKEEPER_CONNECT=&quot;zookeeper:2181&quot; \</span><br><span class="line">-e KAFKA_ADVERTISED_LISTENERS=&quot;PLAINTEXT://192.168.244.129:9092&quot; \</span><br><span class="line">-e KAFKA_LISTENERS=&quot;PLAINTEXT://0.0.0.0:9092&quot; \</span><br><span class="line">-e KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms256M&quot; \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">--restart always --name kafka wurstmeister/kafka:2.12-2.5.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">修改端口：</span><br><span class="line"></span><br><span class="line">docker run -p 2181:2181 --name zookeeper --restart=always \</span><br><span class="line">-e JVMFLAGS=&quot;-Xmx256M -Xms256M&quot; \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-d zookeeper:3.7.0</span><br><span class="line"></span><br><span class="line">docker run -itd -p 9092:9092 --link zookeeper \</span><br><span class="line">-e KAFKA_BROKER_ID=1 \</span><br><span class="line">-e KAFKA_ZOOKEEPER_CONNECT=&quot;zookeeper:2181&quot; \</span><br><span class="line">-e KAFKA_ADVERTISED_LISTENERS=&quot;PLAINTEXT://192.168.244.129:9092&quot; \</span><br><span class="line">-e KAFKA_LISTENERS=&quot;PLAINTEXT://0.0.0.0:9092&quot; \</span><br><span class="line">-e KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms256M&quot; \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">--restart always --name kafka wurstmeister/kafka:2.12-2.5.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过kafka-topics.sh脚本来创建一个名为topic-test1并且副本数为1、分区数为2的topic。</span><br><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 2 --topic mytest</span><br></pre></td></tr></table></figure><blockquote><p>参数说明：<br><br>-e KAFKA_BROKER_ID&#x3D;0<br>在kafka集群中，每个kafka都有一个BROKER_ID来区分自己 <br></p></blockquote><blockquote><p>-e KAFKA_CREATE_TOPICS&#x3D;”topic-test:2:1”<br>topic-test1有2个分区1个副本，副本必须要有一个，1个表示没有备份的，<br>如果设置topic那么就不会自动生成了<br><br></p></blockquote><blockquote><p>-e KAFKA_ZOOKEEPER_CONNECT&#x3D;zookeeper:2181<br>配置zookeeper管理kafka的路径172.16.0.13:2181&#x2F;kafka <br></p></blockquote><blockquote><p>-e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;172.16.0.13:9092<br>把kafka的地址端口注册给zookeeper，如果是远程访问要改成外网IP,类如Java程序访问出现无法连接。 <br></p></blockquote><blockquote><p>-e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092 配置kafka的监听端口 <br></p></blockquote><br><hr><h2 id="6-安装-bitnami-x2F-kafka"><a href="#6-安装-bitnami-x2F-kafka" class="headerlink" title="6 安装 bitnami&#x2F;kafka"></a>6 安装 bitnami&#x2F;kafka</h2><ol><li>拉取镜像<blockquote><p>docker pull zookeeper:3.8.0&amp;&amp; bitnami&#x2F;kafka:2.8.1</p></blockquote></li><li>启动 zookeeper<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 2181:2181 --name zookeeper --restart=always -d zookeeper:3.7.0</span><br></pre></td></tr></table></figure></li><li>启动 kafka</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kafka -p 9092:9092 --link zookeeper \</span><br><span class="line">-e KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.244.128:9092 \</span><br><span class="line">-e KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181 \</span><br><span class="line">-e KAFKA_CFG_LISTENERS=PLAINTEXT://0.0.0.0:9092 \</span><br><span class="line">-e ALLOW_PLAINTEXT_LISTENER=yes \</span><br><span class="line">-d bitnami/kafka:2.8.1</span><br></pre></td></tr></table></figure><br><hr><h2 id="7-安装-kafka-manager"><a href="#7-安装-kafka-manager" class="headerlink" title="7 安装 kafka-manager"></a>7 安装 kafka-manager</h2><ol><li><p>拉取镜像</p><blockquote><p>docker pull kafkamanager&#x2F;kafka-manager:3.0.0.4</p></blockquote></li><li><p>启动 kafka</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kafka-manager \</span><br><span class="line">-e ZK_HOSTS=1.2.3.4 -e KAFKA_MANAGER_AUTH_ENABLED=true \</span><br><span class="line">-d kafkamanager/kafka-manager:3.0.0.4</span><br></pre></td></tr></table></figure><br><hr><h2 id="8-安装-xxl-job"><a href="#8-安装-xxl-job" class="headerlink" title="8 安装 xxl-job"></a>8 安装 xxl-job</h2><ol><li>拉取镜像<blockquote><p>docker pull xuxueli&#x2F;xxl-job-admin:2.3.0</p></blockquote></li><li>执行run命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -p 8080:8080 \</span><br><span class="line">-e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://192.168.244.128:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8 \</span><br><span class="line">--spring.datasource.username=root \</span><br><span class="line">--spring.datasource.password=root \</span><br><span class="line">--xxl.job.accessToken=xxljob2333&quot; \</span><br><span class="line">--name xxl-job-admin -d xuxueli/xxl-job-admin:2.3.0</span><br></pre></td></tr></table></figure></li></ol><h2 id="9-安装-ElasticSearch"><a href="#9-安装-ElasticSearch" class="headerlink" title="9 安装 ElasticSearch"></a>9 安装 ElasticSearch</h2><ol><li><p>拉取镜像</p><blockquote><p>docker pull elasticsearch:7.17.0</p></blockquote></li><li><p>先不挂载目录运行ES，拷贝出配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e discovery.type=single-node -e TZ=&quot;Asia/Shanghai&quot; \</span><br><span class="line">-v /data/docker-volume/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.17.0</span><br></pre></td></tr></table></figure></li><li><p>拷贝出配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp elasticsearch:/usr/share/elasticsearch/config /data/docker-volume/elasticsearch/config</span><br></pre></td></tr></table></figure></li><li><p>配置:开启x-pack插件,用于设置ES密码（如果用8.x版本的就简单些）</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /data/docker-volume/elasticsearch/config/elasticsearch.yml </span><br><span class="line"></span><br><span class="line">添加设置：</span><br><span class="line">  xpack.security.enabled: true   #这一步是开启x-pack插件</span><br></pre></td></tr></table></figure><ol start="5"><li>删除ES容器,再运行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f elasticsearch 先删除，再运行</span><br><span class="line"></span><br><span class="line">docker run --name=elasticsearch --restart=always -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; -e TZ=&quot;Asia/Shanghai&quot; \</span><br><span class="line">-e discovery.type=single-node \</span><br><span class="line">-v /data/docker-volume/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /data/docker-volume/elasticsearch/config:/usr/share/elasticsearch/config \</span><br><span class="line">-d elasticsearch:7.17.0</span><br></pre></td></tr></table></figure><ol start="7"><li><p>安装IK分词器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install -y lrzsz</span><br><span class="line"></span><br><span class="line">rz 上传到Linux</span><br><span class="line">sz xxx.txt 下载到本地</span><br><span class="line"></span><br><span class="line">unzip -d /data/docker-volume/elasticsearch/plugins/elasticsearch-analysis-ik-7.17.0 elasticsearch-analysis-ik-7.17.0.zip </span><br></pre></td></tr></table></figure></li><li><p>开启密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it elasticsearch /bin/bash    # 进入容器</span><br><span class="line"></span><br><span class="line">cd bin</span><br><span class="line"></span><br><span class="line">elasticsearch-setup-passwords interactive     #此步为手动设置密码</span><br><span class="line"></span><br><span class="line">Please confirm that you would like to continue [y/N] y</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure></li></ol><br><hr><h2 id="10-安装-Kibana"><a href="#10-安装-Kibana" class="headerlink" title="10 安装 Kibana"></a>10 安装 Kibana</h2><ol><li><p>拉取镜像</p><blockquote><p>docker pull kibana:7.17.0</p><p>docker pull logstash:7.17.0 (可选)</p></blockquote></li><li><p>先不挂载目录运行ES，拷贝出配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=kibana -p 5601:5601 \</span><br><span class="line">-e TZ=&quot;Asia/Shanghai&quot; -e discovery.type=single-node -d kibana:7.17.0</span><br></pre></td></tr></table></figure></li><li><p>拷贝出配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/docker-volume/kibana/config</span><br><span class="line"></span><br><span class="line">docker cp kibana:/usr/share/kibana/config /data/docker-volume/kibana</span><br></pre></td></tr></table></figure></li><li><p>修改配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /data/docker-volume/kibana/config/kibana.yml</span><br><span class="line"></span><br><span class="line">配置：</span><br><span class="line">server.name: kibana</span><br><span class="line"># kibana的主机地址 0.0.0.0可表示监听所有IP</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line"># kibana访问es的URL</span><br><span class="line">elasticsearch.hosts: [ &quot;http://192.168.32.133:9200&quot; ]</span><br><span class="line">#这里是在elasticsearch设置密码时的值</span><br><span class="line">elasticsearch.username: &quot;elastic&quot;</span><br><span class="line">elasticsearch.password: &quot;elastic&quot;</span><br></pre></td></tr></table></figure></li><li><p>执行run命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=kibana --restart=always -p 5601:5601 \</span><br><span class="line">-e TZ=&quot;Asia/Shanghai&quot; -e discovery.type=single-node \</span><br><span class="line">-v /data/docker-volume/kibana/config:/usr/share/kibana/config \</span><br><span class="line">-d kibana:7.17.0</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 3.环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
            <tag> Postgres </tag>
            
            <tag> Redis </tag>
            
            <tag> Kafka </tag>
            
            <tag> xxl-job </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装nginx并配置代理</title>
      <link href="/2022/05/15/13.docker%E6%90%AD%E5%BB%BAnginx%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
      <url>/2022/05/15/13.docker%E6%90%AD%E5%BB%BAnginx%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Docker安装nginx"><a href="#1-Docker安装nginx" class="headerlink" title="1. Docker安装nginx"></a>1. Docker安装nginx</h2><h3 id="1-1-拉取镜像"><a href="#1-1-拉取镜像" class="headerlink" title="1.1 拉取镜像"></a>1.1 拉取镜像</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:stable</span><br></pre></td></tr></table></figure><h3 id="1-2-启动容器"><a href="#1-2-启动容器" class="headerlink" title="1.2 启动容器"></a>1.2 启动容器</h3><p>这里编写个sh脚本直接运行即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;启动nginx&quot;</span></span><br><span class="line">docker run --name nginx -p 80:80 -d nginx:stable</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;创建目录并复制出配置文件...&quot;</span></span><br><span class="line"><span class="built_in">rm</span> -rf /data/docker-volume/nginx</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /data/docker-volume/nginx</span><br><span class="line"><span class="built_in">mkdir</span> -p /data/docker-volume/nginx/html</span><br><span class="line"><span class="built_in">mkdir</span> -p /data/docker-volume/nginx/logs</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">cp</span> nginx:/etc/nginx/nginx.conf /data/docker-volume/nginx/</span><br><span class="line">docker <span class="built_in">cp</span> nginx:/etc/nginx/conf.d/ /data/docker-volume/nginx/</span><br><span class="line">docker <span class="built_in">cp</span> nginx:/usr/share/nginx/html/ /data/docker-volume/nginx/</span><br><span class="line">docker <span class="built_in">cp</span> nginx:/var/log/nginx /data/docker-volume/nginx/logs/</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;强制删除nginx容器...&quot;</span></span><br><span class="line">docker <span class="built_in">rm</span> -f nginx</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;再次启动nginx容器同时挂载目录&quot;</span></span><br><span class="line">docker run --name nginx -p 80:80 --restart always \</span><br><span class="line">-v /data/docker-volume/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /data/docker-volume/nginx/html/:/usr/share/nginx/html/ \</span><br><span class="line">-v /data/docker-volume/nginx/logs/nginx:/var/log/nginx/ \</span><br><span class="line">-v /data/docker-volume/nginx/conf.d/:/etc/nginx/conf.d \</span><br><span class="line">--privileged=<span class="literal">true</span> -d nginx:stable</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nginx容器启动完成&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-配置代理"><a href="#1-3-配置代理" class="headerlink" title="1.3 配置代理"></a>1.3 配置代理</h3><p>（1）复制默认配置文件并改名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data/docker-volume/nginx/conf.d</span><br><span class="line"></span><br><span class="line">vim picx.conf</span><br></pre></td></tr></table></figure><p>（2）填写配置文件内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">           <span class="attribute">proxy_pass</span> http://服务所在服务器的外网ip:端口号/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）重启nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart nginx</span><br></pre></td></tr></table></figure><p>（4）访问：<br>http:&#x2F;&#x2F; nginx所在的服务器的外网地址</p><p>ps：<br>（1）配置没有配上下文，直接访问；<br>（2）代理可以换成域名，然后就可以通过域名访问了；</p><h2 id="2-Nginx详细配置"><a href="#2-Nginx详细配置" class="headerlink" title="2. Nginx详细配置"></a>2. Nginx详细配置</h2><h3 id="2-1-文件结构"><a href="#2-1-文件结构" class="headerlink" title="2.1 文件结构"></a>2.1 文件结构</h3><ul><li>1、<strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li>2、<strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li>3、<strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li>4、<strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li>5、<strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...              <span class="comment">#全局块</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;         <span class="comment">#events块</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;         <span class="comment">#http块</span></span><br><span class="line">    ...   <span class="comment">#http全局块</span></span><br><span class="line">   <span class="section">upstream</span> myserver &#123;   <span class="comment">#负载均衡</span></span><br><span class="line">        ...   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;        <span class="comment">#server块</span></span><br><span class="line">        ...       <span class="comment">#server全局块</span></span><br><span class="line">        <span class="section">location</span> [PATTERN] &#123;   <span class="comment">#location块</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> [PATTERN] &#123;</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     <span class="comment">#http全局块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-详细配置"><a href="#2-2-详细配置" class="headerlink" title="2.2 详细配置"></a>2.2 详细配置</h3><p>每个指令必须有分号结束</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##################### 全局块 ######################</span></span><br><span class="line"><span class="comment">#配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</span></span><br><span class="line"><span class="attribute">user</span>  nginx; <span class="comment">#配置用户或者组</span></span><br><span class="line"><span class="attribute">worker_processes</span>  auto; <span class="comment">#允许生成的进程数，工作进程数量，可配置成服务器内核数 * 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid; <span class="comment">#指定nginx进程运行文件存放地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################### events块 ######################</span></span><br><span class="line"><span class="comment">#配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>; <span class="comment">#最大连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">##################### http块 ######################</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types; <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line"><span class="comment">#access_log off; #取消服务日志 </span></span><br><span class="line">    <span class="comment"># 日志格式</span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main; <span class="comment">#访问日志位置</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>; <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on; #此选项允许或禁止使用socke的TCP_CORK的选项（发送数据包前先缓存数据），此选项仅在使用sendfile的时候使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>; <span class="comment">#连接保持超时时间，单位是秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on; #gzip模块设置，设置是否开启gzip压缩输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##################### 负载均衡 ######################</span></span><br><span class="line">    <span class="section">upstream</span> myserver &#123;   </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.11:8880</span>   weight=<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.1.12:9990</span>   weight=<span class="number">1</span>;</span><br><span class="line">     <span class="attribute">server</span> <span class="number">192.168.10.121:3333</span> backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">##################### 虚拟主机，可以配置多个 ######################</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;  <span class="comment"># ipv4 监听端口</span></span><br><span class="line">        <span class="attribute">listen</span>  [::]:<span class="number">80</span>;  <span class="comment"># ipv6 监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost  www.xxxxx.com; <span class="comment">#站点域名，可以有多个，用空格隔开</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#静态资源配置</span></span><br><span class="line">        <span class="section">location</span> / &#123; <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写</span></span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html; <span class="comment">#根目录</span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm; <span class="comment">#设置默认页</span></span><br><span class="line">            <span class="attribute">deny</span> <span class="number">192.168.2.11</span>;   <span class="comment">#禁止访问的ip地址，可以为all</span></span><br><span class="line">            <span class="attribute">allow</span> <span class="number">192.168.3.44</span>； <span class="comment">#允许访问的ip地址，可以为all</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#反向代理配置</span></span><br><span class="line">        location /picx/ &#123; </span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://myserver;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">            <span class="comment">#proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            <span class="comment">#proxy_send_timeout 90;     #后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">            <span class="comment">#proxy_read_timeout 90;     #连接成功后,后端服务器响应时间(代理接收超时)</span></span><br><span class="line">            <span class="comment">#proxy_buffer_size 4k;      #代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="comment">#proxy_buffers 4 32k;      #proxy_buffers缓冲区</span></span><br><span class="line">            <span class="comment">#proxy_busy_buffers_size 64k;     #高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            <span class="comment">#proxy_temp_file_write_size 64k;  #设定缓存文件夹大小</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">#proxy_set_header Host $host; </span></span><br><span class="line">            <span class="comment">#proxy_set_header X-Forwarder-For $remote_addr;  #获取客户端真实IP</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重定向配置</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">             <span class="attribute">return</span> <span class="number">404</span>; <span class="comment">#直接返回状态码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">             <span class="attribute">return</span> <span class="number">404</span> <span class="string">&quot;pages not found&quot;</span>; <span class="comment">#返回状态码 + 一段文本</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">             <span class="attribute">return</span> <span class="number">302</span> /blog ; <span class="comment">#返回状态码 + 重定向地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">             <span class="attribute">return</span> https://www.mingongge.com ; <span class="comment">#返回重定向地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-域名匹配的四种写法"><a href="#2-3-域名匹配的四种写法" class="headerlink" title="2.3 域名匹配的四种写法"></a>2.3 <a href="https://dnspod.cloud.tencent.com/">域名</a>匹配的四种写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">精确匹配：server_name www.xxxx.com ;</span><br><span class="line">左侧通配：server_name *.xxxx.com ;</span><br><span class="line">右侧统配：server_name www.xxxx.* ;</span><br><span class="line">正则匹配：server_name ~^www\.xxxx\.*$ ;</span><br><span class="line"></span><br><span class="line">匹配优先级：精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</span><br></pre></td></tr></table></figure><h3 id="2-4-location-匹配说明"><a href="#2-4-location-匹配说明" class="headerlink" title="2.4 location 匹配说明"></a>2.4 location 匹配说明</h3><ul><li><p>1、&#x3D; ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p></li><li><p>2、~：用于表示 uri 包含正则表达式，并且区分大小写。</p></li><li><p>3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。</p></li><li><p>4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location块中的正则 uri 和请求字符串做匹配。</p></li></ul><p>注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</p><h3 id="2-5-proxy-pass-匹配说明"><a href="#2-5-proxy-pass-匹配说明" class="headerlink" title="2.5 proxy_pass 匹配说明"></a>2.5 proxy_pass 匹配说明</h3><p>在nginx中配置proxy_pass代理转发时：</p><ul><li>如果在proxy_pass后面的url中含有&#x2F;，表示绝对根路径，匹配的location 路径就不在url里了；</li><li>如果在proxy_pass后面的url中没有&#x2F;，表示相对路径，把匹配的路径部分也给代理走，要在url里留着。<br>proxy_pass有&#x2F;，实际访问地址就没有location</li></ul><p>以下是几种常见的匹配情况，访问地址：<a href="http://localhost/proxy/abc.html">http://localhost/proxy/abc.html</a></p><p>图示：</p><table><thead><tr><th>序号</th><th>location</th><th>proxy_pass</th><th>代理到</th></tr></thead><tbody><tr><td>1</td><td>&#x2F;proxy&#x2F;</td><td><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a></td><td><a href="http://127.0.0.1:8080/abc.html">http://127.0.0.1:8080/abc.html</a></td></tr><tr><td>2</td><td>&#x2F;proxy&#x2F;</td><td><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></td><td><a href="http://127.0.0.1:8080/proxy/abc.html">http://127.0.0.1:8080/proxy/abc.html</a></td></tr><tr><td>3</td><td>&#x2F;proxy&#x2F;</td><td><a href="http://127.0.0.1:8080/api/">http://127.0.0.1:8080/api/</a></td><td><a href="http://127.0.0.1:8080/api/abc.html">http://127.0.0.1:8080/api/abc.html</a></td></tr><tr><td>4</td><td>&#x2F;proxy&#x2F;</td><td><a href="http://127.0.0.1:8080/api">http://127.0.0.1:8080/api</a></td><td><a href="http://127.0.0.1:8080/apiabc.html">http://127.0.0.1:8080/apiabc.html</a></td></tr><tr><td>5</td><td>&#x2F;proxy</td><td><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a></td><td><a href="http://127.0.0.1:8080//abc.html">http://127.0.0.1:8080//abc.html</a></td></tr><tr><td>6</td><td>&#x2F;proxy</td><td><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></td><td><a href="http://127.0.0.1:8080/proxy/abc.html">http://127.0.0.1:8080/proxy/abc.html</a></td></tr><tr><td>7</td><td>&#x2F;proxy</td><td><a href="http://127.0.0.1:8080/api/">http://127.0.0.1:8080/api/</a></td><td><a href="http://127.0.0.1:8080/proxy//abc.html">http://127.0.0.1:8080/proxy//abc.html</a></td></tr><tr><td>8</td><td>&#x2F;proxy</td><td><a href="http://127.0.0.1:8080/api">http://127.0.0.1:8080/api</a></td><td><a href="http://127.0.0.1:8080/proxy/apiabc.html">http://127.0.0.1:8080/proxy/apiabc.html</a></td></tr></tbody></table><h3 id="2-5-nginx负载均衡策略"><a href="#2-5-nginx负载均衡策略" class="headerlink" title="2.5 nginx负载均衡策略"></a>2.5 nginx负载均衡策略</h3><p><strong>1.轮询（默认）</strong></p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p><p><strong>2.weight</strong></p><p>weight 代表权,重默认为 1,权重越高被分配的客户端越多</p><p>指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。 例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> server_pool&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.5.21</span> weight=<span class="number">10</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.5.22</span> weight=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.ip_hash</strong></p><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 例如</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> server_pool&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.5.21:80</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.5.22:80</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.fair（第三方）</strong></p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> server_pool&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.5.21:80</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.5.22:80</span>;</span><br><span class="line">    fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-安装-SSL-配置-HTTPS"><a href="#2-6-安装-SSL-配置-HTTPS" class="headerlink" title="2.6 安装 SSL 配置 HTTPS"></a>2.6 安装 SSL 配置 HTTPS</h3><h4 id="2-6-1-下载证书并上传"><a href="#2-6-1-下载证书并上传" class="headerlink" title="2.6.1 下载证书并上传"></a>2.6.1 下载证书并上传</h4><p>下载申请好的 ssl 证书文件压缩包到本地并解压（这里是用的 pem 与 key 文件，文件名可以更改）。</p><p>在 nginx 目录新建 cert 文件夹存放证书文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/nginx</span><br><span class="line">$ mkdir cert</span><br></pre></td></tr></table></figure><p>将这两个文件上传至服务器的 cert 目录里。</p><h4 id="2-6-2-配置ssl证书"><a href="#2-6-2-配置ssl证书" class="headerlink" title="2.6.2 配置ssl证书"></a>2.6.2 配置ssl证书</h4><p>配置 https <a href="https://www.aliyun.com/minisite/goods?userCode=veyumm2k">server</a>。注释掉之前的 http server 配置，新增 https server：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="comment">#SSL 访问端口号为 443</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl; </span><br><span class="line">    <span class="comment">#填写绑定证书的域名</span></span><br><span class="line">    <span class="attribute">server_name</span> www.xxxx.com; </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ssl证书地址</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /usr/local/nginx/cert/ssl.pem;  <span class="comment"># pem文件的路径</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /usr/local/nginx/cert/ssl.key; <span class="comment"># key文件的路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ssl验证相关配置</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>; <span class="comment">#缓存有效期</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;  <span class="comment">#安全链接可选的加密协议</span></span><br><span class="line">    <span class="comment">#请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span></span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;  <span class="comment">#加密算法 腾讯</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>; <span class="comment">#使用服务器端的首选算法</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment">#网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span></span><br><span class="line">        <span class="comment">#例如，您的网站运行目录在/etc/www下，则填写/etc/www。</span></span><br><span class="line">        <span class="attribute">root</span> html; </span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 http 重定向 https。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.xxxx.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3.环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在一台电脑上同时使用Gitee和Github</title>
      <link href="/2022/05/13/12.%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8Gitee%E5%92%8CGithub/"/>
      <url>/2022/05/13/12.%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8Gitee%E5%92%8CGithub/</url>
      
        <content type="html"><![CDATA[<h2 id="1-生成-ssh-key"><a href="#1-生成-ssh-key" class="headerlink" title="1. 生成 ssh key"></a>1. 生成 ssh key</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">进入用户目录下的 .ssh 文件夹下，路径会因你使用的操作系统不同而略有差异</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">没有这个文件夹也无所谓，直接运行下一句命令也可以</span></span><br><span class="line">`cd C:\Users\用户\.ssh`</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">生成 key:</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ssh-keygen -t ed25519 -C <span class="string">&quot;xxxxx@xxxxx.com&quot;</span></span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">注意：这里的 xxxxx@xxxxx.com 只是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">在\.ssh目录下生成2个密钥对</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">gitee密钥</span></span><br><span class="line">ssh-keygen -t ed25519 -C &quot;gitee&quot;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">github密钥</span></span><br><span class="line">ssh-keygen -t ed25519 -C &quot;github&quot;</span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，即可生成 ssh key。通过查看C:\Users\用户.ssh 文件夹，获取到你的 public key，执行完就得到了2对密钥，需要先将第一对密钥重新命名再生成第二对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in id_rsa_gitee.</span><br><span class="line">Your public key has been saved in id_rsa_gitee.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:F0K/ojCbFzgMPru11m4g/9uV03oHK+U0rKBLwOOye2c xxx@xxx.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|        .        |</span><br><span class="line">|       . .       |</span><br><span class="line">|  .     . o      |</span><br><span class="line">| . + .   . o     |</span><br><span class="line">|  o X . S o.     |</span><br><span class="line">|  .+.O o.o o*    |</span><br><span class="line">|  oo=o+. .+=.+   |</span><br><span class="line">|   =++E. .oo+ .  |</span><br><span class="line">|  ++.*=o. .o .   |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新命名后的2对密钥：</p><p><img src="https://s4.ax1x.com/2022/03/05/b0OMk9.png"></p><h2 id="2-设置密钥"><a href="#2-设置密钥" class="headerlink" title="2.设置密钥"></a>2.设置密钥</h2><p>打开 Gitee 和 Github 的网站找到设置，再找到 SSH Keys，添加复制的 public key 。</p><p><img src="https://img2018.cnblogs.com/blog/1635345/201908/1635345-20190820140215627-1057414887.png" alt="Gitee 新增 ssh key"></p><p><img src="https://img2018.cnblogs.com/blog/1635345/201908/1635345-20190820140238740-813223982.png" alt="Github 新增 ssh key"></p><h2 id="3-本地创建配置文件"><a href="#3-本地创建配置文件" class="headerlink" title="3.本地创建配置文件"></a>3.本地创建配置文件</h2><p>在 <code>C:\Users\用户\.ssh</code> 文件夹中创建 config 文件，添加以下内容以区分两个 ssh key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitee</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>1.在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>若返回如下内容，则 Github 连接正常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi yourname! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>2.继续在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure><p>若返回如下内容，则 Gitee 连接正常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Gitee.com, yourname!</span><br></pre></td></tr></table></figure><p>出现以下信息就成功了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br><span class="line"></span><br><span class="line">Warning: Permanently added the RSA host key for IP address &#x27;13.250.177.223&#x27; to the list of known hosts.</span><br><span class="line">Hi dragon! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ssh -T git@gitlab.com</span></span><br><span class="line"></span><br><span class="line">The authenticity of host &#x27;gitlab.com (35.231.145.151)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:HbW3g8zUjNSksFbqTiUWPWg2Bq1x8xdGUrliXFzSn.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;gitlab.com,35.231.145.151&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line">Welcome to GitLab, @dragon!</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">ssh -T git@gitee.com</span> </span><br><span class="line"></span><br><span class="line">The authenticity of host &#x27;gitee.com (116.211.167.14)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrp+KkGYoFgbVr17bmjeyc.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;gitee.com,116.211.167.14&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line">Hi 我是x! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-上传代码到远程仓库"><a href="#5-上传代码到远程仓库" class="headerlink" title="5.上传代码到远程仓库"></a>5.上传代码到远程仓库</h2><p>5.1  查看git设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><p>5.2 全局设置用户名和邮箱（用于git提交记录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;xxxx&quot;</span><br><span class="line">git config --global user.email &quot;xxxx@163.com&quot;</span><br><span class="line"></span><br><span class="line">git config --global --unset user.name &quot;xxxx&quot;</span><br><span class="line">git config --global --unset user.email &quot;xxxx@163.com&quot;</span><br></pre></td></tr></table></figure><p>5.3 本地建git仓库并推送</p><p>gitee:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir xxxx</span><br><span class="line">cd xxxx</span><br><span class="line">git init </span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://gitee.com/xxxx/xxxx.git</span><br><span class="line">git push -u origin &quot;master&quot;</span><br></pre></td></tr></table></figure><p>github:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/xxxx/xxxx.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Gitee </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建maven私服实现上传下载依赖</title>
      <link href="/2022/05/12/11.maven%E7%A7%81%E6%9C%8D%E4%B8%8A%E4%BC%A0/"/>
      <url>/2022/05/12/11.maven%E7%A7%81%E6%9C%8D%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0-搭建nexus私服"><a href="#0-搭建nexus私服" class="headerlink" title="0. 搭建nexus私服"></a>0. 搭建nexus私服</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.拉取镜像</span><br><span class="line">docker pull sonatype/nexus3:3.38.1</span><br><span class="line"></span><br><span class="line">2.运行镜像（没必要挂载文件出来）</span><br><span class="line">docker run -d -p 8081:8081 --name nexus --restart=always sonatype/nexus3:3.38.1</span><br><span class="line"></span><br><span class="line">3.浏览器访问 http://192.168.32.133:8081/</span><br></pre></td></tr></table></figure><h2 id="1-私服上传："><a href="#1-私服上传：" class="headerlink" title="1.私服上传："></a>1.私服上传：</h2><h3 id="1-1-pom-配置："><a href="#1-1-pom-配置：" class="headerlink" title="1.1 pom 配置："></a>1.1 pom 配置：</h3><p>maven的pom配置文件配置私服地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--上传私服 配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id的名字可以任意取，但是在setting文件中的属性&lt;server&gt;的ID与这里一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>local-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--name只是标识作用，无实际作用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus Repository RELEASES<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指向仓库类型为host(宿主仓库）的储存类型为Release的仓库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.244.130:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>local-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus Repository SNAPSHOTS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.244.130:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-settings-配置"><a href="#1-2-settings-配置" class="headerlink" title="1.2 settings 配置:"></a>1.2 settings 配置:</h3><blockquote><p>setting配置文件默认路径（windows）：C:\Users\用户名\.m2\settings.xml<br>指定本地maven仓库路径：<code>&lt;localRepository&gt;D:/dev/maven-repository&lt;/localRepository&gt;</code></p></blockquote><p>指定私服的密码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对应pom.xml的distributionManagement.id=releases的仓库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>local-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对应pom.xml的distributionManagement.id=releases的仓库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>local-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-上传到私服"><a href="#1-3-上传到私服" class="headerlink" title="1.3 上传到私服"></a>1.3 上传到私服</h3><p>运行命令：<code>maven deploy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;demo-nexus&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">根据pom文件中设置的上传到不同仓库</span><br><span class="line">带有【-SNAPSHOT】会上传到 snapshotRepository 仓库</span><br><span class="line">其余的会上传到 repository 仓库</span><br></pre></td></tr></table></figure><h2 id="2。-私服下载："><a href="#2。-私服下载：" class="headerlink" title="2。 私服下载："></a>2。 私服下载：</h2><blockquote><p>两种任选其一：</p></blockquote><h3 id="2-1-pom-配置："><a href="#2-1-pom-配置：" class="headerlink" title="2.1 pom 配置："></a>2.1 pom 配置：</h3><p>当前项目生效：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--从私服下载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span> <span class="comment">&lt;!-- 这里的ID为maven仓库的name --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>local Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- 这里的name 只是标识作用，随意取 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.244.130:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span> <span class="comment">&lt;!-- 这里的ID为maven仓库的name --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>local Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- 这里的name 只是标识作用，随意取 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.244.130:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-setting-配置"><a href="#2-2-setting-配置" class="headerlink" title="2.2 setting 配置:"></a>2.2 setting 配置:</h3><p>全局生效：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 仓库地址1 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里的ID为maven仓库的name --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>local nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.244.130:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仓库地址2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>wshoto-nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://111.229.217.171:7081/nexus/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>!maven-public,*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-setting的mirrorOf设置"><a href="#3-setting的mirrorOf设置" class="headerlink" title="3. setting的mirrorOf设置"></a>3. setting的mirrorOf设置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当maven需要到的依赖jar包不在本地仓库时, 就需要到远程仓库下载。</span><br><span class="line">这个时候如果mavensetting.xml中配置了镜像 , 而且镜像配置的规则中匹配到目标仓库时 ,</span><br><span class="line">maven认为目标仓库被镜像了, 不会再去被镜像仓库下载依赖jar包, 而是直接去镜像仓库下载。</span><br><span class="line"></span><br><span class="line">简单而言, 当通过pom文件指定的repository去下载镜像时，mirror首先通过repository的id拦截对远程仓库的请求 , 改变对目标仓库的下载地址，因为自己在这里指定的mirrorOf为*，那么所有的repository都会被该mirror拦截，从而替换成了自己的私服镜像</span><br><span class="line"></span><br><span class="line">为了满足一些复杂的需求，Maven还支持更高级的镜像配置：</span><br><span class="line"></span><br><span class="line">1.*</span><br><span class="line">匹配所有远程仓库。</span><br><span class="line"></span><br><span class="line">2.external:*</span><br><span class="line">匹配所有远程仓库，使用localhost的除外，使用file://协议的除外。也就是说，匹配所有不在本机上的远程仓库。</span><br><span class="line"></span><br><span class="line">3.repo1,repo2</span><br><span class="line">匹配仓库repo1和repo2，使用逗号分隔多个远程仓库。</span><br><span class="line"></span><br><span class="line">4.*,!repo1</span><br><span class="line">匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!pom中reposiretory的Id<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://172.xx.xx.xx:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-pom配置阿里Maven镜像地址"><a href="#4-pom配置阿里Maven镜像地址" class="headerlink" title="4. pom配置阿里Maven镜像地址"></a>4. pom配置阿里Maven镜像地址</h2><p>配置镜像仓库优先级：</p><p><strong>本地仓库(localRepositories) &gt; pom.xml文件中的repositories仓库 &gt; setting.xml配置文件中mirrors镜像仓库</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3.环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Nexus </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机的网络连接方式</title>
      <link href="/2022/05/09/10.%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/05/09/10.%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的网络连接方式："><a href="#常见的网络连接方式：" class="headerlink" title="常见的网络连接方式："></a>常见的网络连接方式：</h2><h3 id="1、NAT-（Network-Address-Translation，网络地址转换）"><a href="#1、NAT-（Network-Address-Translation，网络地址转换）" class="headerlink" title="1、NAT （Network Address Translation，网络地址转换）"></a>1、NAT （Network Address Translation，网络地址转换）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Guest访问网络的所有数据都是由主机提供的，Guest并不真实存在于网络中，主机与网络中的任何机器都不能查看和访问到Guest的存在。</span><br><span class="line"></span><br><span class="line">Guest可以访问主机能访问到的所有网络，但是对于主机以及主机网络上的其他机器，Guest又是不可见的，甚至主机也访问不到Guest。</span><br><span class="line"></span><br><span class="line">虚拟机与主机的关系：只能单向访问，虚拟机可以通过网络访问到主机，主机无法通过网络访问到虚拟机。</span><br><span class="line"></span><br><span class="line">虚拟机与网络中其他主机的关系：只能单向访问，虚拟机可以访问到网络中其他主机，其他主机不能通过网络访问到虚拟机。</span><br><span class="line"></span><br><span class="line">虚拟机与虚拟机的关系：相互不能访问，虚拟机与虚拟机各自完全独立，相互间无法通过网络访问彼此。</span><br></pre></td></tr></table></figure><h3 id="2、Bridged-Adapter（网桥模式）"><a href="#2、Bridged-Adapter（网桥模式）" class="headerlink" title="2、Bridged Adapter（网桥模式）"></a>2、Bridged Adapter（网桥模式）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">它是通过主机网卡，架设了一条桥，直接连入到网络中了。因此，它使得虚拟机能被分配到一个网络中独立的IP，所有网络功能完全和在网络中的真实机器一样。</span><br><span class="line"></span><br><span class="line">网桥模式下的虚拟机，你把它认为是真实计算机就行了。</span><br><span class="line"></span><br><span class="line">虚拟机与主机的关系：可以相互访问，因为虚拟机在真实网络段中有独立IP，主机与虚拟机处于同一网络段中，彼此可以通过各自IP相互访问。</span><br><span class="line"></span><br><span class="line">虚拟机于网络中其他主机的关系：可以相互访问，同样因为虚拟机在真实网络段中有独立IP，虚拟机与所有网络其他主机处于同一网络段中，彼此可以通过各自IP相互访问。</span><br><span class="line"></span><br><span class="line">虚拟机与虚拟机的关系：可以相互访问，原因同上。</span><br></pre></td></tr></table></figure><h3 id="3、Internal（内网模式）"><a href="#3、Internal（内网模式）" class="headerlink" title="3、Internal（内网模式）"></a>3、Internal（内网模式）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内网模式，顾名思义就是内部网络模式：</span><br><span class="line"></span><br><span class="line">虚拟机与外网完全断开，只实现虚拟机于虚拟机之间的内部网络模式。</span><br><span class="line"></span><br><span class="line">虚拟机与主机的关系：不能相互访问，彼此不属于同一个网络，无法相互访问。</span><br><span class="line"></span><br><span class="line">虚拟机与网络中其他主机的关系：不能相互访问，理由同上。</span><br><span class="line"></span><br><span class="line">虚拟机与虚拟机的关系：可以相互访问，前提是在设置网络时，两台虚拟机设置同一网络名称。如上配置图中，名称为intnet。</span><br></pre></td></tr></table></figure><h3 id="4、Host-only-Adapter（主机模式）"><a href="#4、Host-only-Adapter（主机模式）" class="headerlink" title="4、Host-only Adapter（主机模式）"></a>4、Host-only Adapter（主机模式）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主机模式，这是一种比较复杂的模式，需要有比较扎实的网络基础知识才能玩转。可以说前面几种模式所实现的功能，在这种模式下，通过虚拟机及网卡的设置都可以被实现。</span><br><span class="line"></span><br><span class="line">我们可以理解为Guest在主机中模拟出一张专供虚拟机使用的网卡，所有虚拟机都是连接到该网卡上的，我们可以通过设置这张网卡来实现上网及其他很多功能，比如（网卡共享、网卡桥接等）。</span><br><span class="line"></span><br><span class="line">虚拟机与主机的关系：默认不能相互访问，双方不属于同一IP段，host-only网卡默认IP段为192.168.56.X 子网掩码为255.255.255.0，后面的虚拟机被分配到的也都是这个网段。通过网卡共享、网卡桥接等，可以实现虚拟机于主机相互访问。</span><br><span class="line"></span><br><span class="line">虚拟机与网络主机的关系：默认不能相互访问，原因同上，通过设置，可以实现相互访问。</span><br><span class="line"></span><br><span class="line">虚拟机与虚拟机的关系：默认可以相互访问，都是同处于一个网段。</span><br></pre></td></tr></table></figure><h2 id="VMware支持三种类型的网络：NAT，Bridged，Host-only。"><a href="#VMware支持三种类型的网络：NAT，Bridged，Host-only。" class="headerlink" title="VMware支持三种类型的网络：NAT，Bridged，Host-only。"></a>VMware支持三种类型的网络：NAT，Bridged，Host-only。</h2><h3 id="1、NAT"><a href="#1、NAT" class="headerlink" title="1、NAT"></a>1、NAT</h3><p>这种方式下，虚拟机的网卡连接到宿主的 VMnet8 上。此时系统的 VMWare NAT Service 服务就充当了路由器的作用，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。VMWare DHCP Service 负责为虚拟机提供 DHCP 服务。</p><p><img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/05/161210210454532.3w1ypfg2i240.webp"></p><h3 id="2、Bridged"><a href="#2、Bridged" class="headerlink" title="2、Bridged"></a>2、Bridged</h3><p>这种方式下，虚拟机就像一台真正的计算机一样，直接连接到实际的网络上，与宿主机没有任何联系。</p><p><img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/05/161210210454533.4739l5jodhe0.webp"></p><h3 id="3、Host-only"><a href="#3、Host-only" class="headerlink" title="3、Host-only"></a>3、Host-only</h3><p>这种方式下，虚拟机的网卡连接到宿主的 VMnet1 上，但系统并不为虚拟机提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。</p><p><img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/05/161210210454534.3kmducjiip20.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 5.课外知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录下常用的win软件和idea插件</title>
      <link href="/2022/05/09/9.%E8%AE%B0%E5%BD%95%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84win%E8%BD%AF%E4%BB%B6%E5%92%8Cidea%E6%8F%92%E4%BB%B6/"/>
      <url>/2022/05/09/9.%E8%AE%B0%E5%BD%95%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84win%E8%BD%AF%E4%BB%B6%E5%92%8Cidea%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>搬砖仔的常用软件和idea插件</strong></li></ul><p><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/05/image-20220509004813023.ub6zw3zn0u8.webp" alt="image-20220509004813023"></p><hr><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/05/image-20220509004706125.5p2qyhrf4s80.webp" alt="image-20220509004706125" style="zoom:50%;" /><img src="https://raw.githubusercontents.com/unravelyt/image-hosting/master/2022/05/image-20220509004737669.5ox4wrdk3hg0.webp" alt="image-20220509004737669" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些常用的sh脚本</title>
      <link href="/2022/05/08/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
      <url>/2022/05/08/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-批量clone代码到指定目录"><a href="#1-批量clone代码到指定目录" class="headerlink" title="1. 批量clone代码到指定目录"></a>1. 批量clone代码到指定目录</h2><h3 id="1-1-脚本"><a href="#1-1-脚本" class="headerlink" title="1.1 脚本"></a>1.1 脚本</h3><p>指定目录：openSourceDir （替换即可）</p><p>指定代码地址：<a href="https://gitee.com/zhijiantianya/ruoyi-vue-pro.git">https://gitee.com/zhijiantianya/ruoyi-vue-pro.git</a> （替换即可）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d openSourceDir ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> openSourceDir</span><br><span class="line">    <span class="built_in">cd</span> openSourceDir</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cd</span> openSourceDir</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/zhijiantianya/ruoyi-vue-pro.git</span><br><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/zhijiantianya/ruoyi-vue-pro.git</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><p>新建一个sh文件，复制脚本到文件内保存，使用git bash打开运行即可<br>如执行：<code>./gitClone.sh</code></p><hr><h2 id="2-批量更新Git仓库"><a href="#2-批量更新Git仓库" class="headerlink" title="2. 批量更新Git仓库"></a>2. 批量更新Git仓库</h2><h3 id="2-1-脚本"><a href="#2-1-脚本" class="headerlink" title="2.1 脚本"></a>2.1 脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> $(<span class="built_in">ls</span> -d */)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$dir</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;into <span class="variable">$dir</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">&quot;.git&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">&quot;正在拉取 <span class="variable">$dir</span>&quot;</span></span><br><span class="line">     git pull</span><br><span class="line">  <span class="keyword">elif</span> [ -d <span class="string">&quot;.svn&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">     svn update</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> dir1 <span class="keyword">in</span> $(<span class="built_in">ls</span> -d */)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$dir1</span> <span class="built_in">echo</span> <span class="string">&quot;--into <span class="variable">$dir1</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="string">&quot;.git&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;--正在拉取 <span class="variable">$dir1</span>&quot;</span></span><br><span class="line">            git pull</span><br><span class="line">        <span class="keyword">elif</span> [ -d <span class="string">&quot;.svn&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            svn update</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">cd</span> ..</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">cd</span> ..</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><p>新建一个sh文件，复制脚本到文件内保存后放到项目文件夹内<br>如执行：<code>./gitPull.sh</code></p><hr><h2 id="3-清理maven仓库未下载成功的依赖-仅Windows"><a href="#3-清理maven仓库未下载成功的依赖-仅Windows" class="headerlink" title="3. 清理maven仓库未下载成功的依赖 (仅Windows)"></a>3. 清理maven仓库未下载成功的依赖 (仅Windows)</h2><h3 id="3-1-脚本"><a href="#3-1-脚本" class="headerlink" title="3.1 脚本"></a>3.1 脚本</h3><p>设置maven仓库目录地址：D:\dev\maven-repository</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\dev\maven-repository</span><br><span class="line"><span class="comment">rem 正在搜索...</span></span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b /s &quot;<span class="variable">%REPOSITORY_PATH%</span>\*lastUpdated*&quot;&#x27;) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">del</span> /s /q <span class="variable">%%i</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">rem 搜索完毕</span></span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-使用"><a href="#3-2-使用" class="headerlink" title="3.2 使用"></a>3.2 使用</h3><p>新建一个bat文件，复制脚本到文件内保存，双击运行即可<br>如：cleanMaven.bat</p><h2 id="4-重置BeyondCopare试用时间-仅Windows"><a href="#4-重置BeyondCopare试用时间-仅Windows" class="headerlink" title="4. 重置BeyondCopare试用时间 (仅Windows)"></a>4. 重置BeyondCopare试用时间 (仅Windows)</h2><h3 id="4-1-方式一：删除注册表"><a href="#4-1-方式一：删除注册表" class="headerlink" title="4.1 方式一：删除注册表"></a>4.1 方式一：删除注册表</h3><p>Windows 新建一个bat文件，复制脚本到文件内保存，双击运行即可</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg delete &quot;HKEY_CURRENT_USER\Software\Scooter Software\Beyond Compare <span class="number">4</span>&quot; /v CacheID /f</span><br></pre></td></tr></table></figure><h3 id="4-2-方式二：删除dll文件"><a href="#4-2-方式二：删除dll文件" class="headerlink" title="4.2 方式二：删除dll文件"></a>4.2 方式二：删除dll文件</h3><ol><li>找到文件安装目录：C:\Program Files\Beyond Compare 4</li><li>删除名字为<code>BCUnrar.dll</code>的文件</li></ol>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装ElasticSearch和Kibana [8.1.3]</title>
      <link href="/2022/05/08/7.docker%20%E5%AE%89%E8%A3%85%E7%89%88%E6%9C%AC8.1.3%E7%9A%84es%E5%92%8CKibana/"/>
      <url>/2022/05/08/7.docker%20%E5%AE%89%E8%A3%85%E7%89%88%E6%9C%AC8.1.3%E7%9A%84es%E5%92%8CKibana/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-安装ES-8-1-3"><a href="#docker-安装ES-8-1-3" class="headerlink" title="docker 安装ES 8.1.3"></a>docker 安装ES 8.1.3</h1><h2 id="1-安装elasticsearch"><a href="#1-安装elasticsearch" class="headerlink" title="1. 安装elasticsearch"></a>1. 安装elasticsearch</h2><h3 id="1-1-拉镜像"><a href="#1-1-拉镜像" class="headerlink" title="1.1 拉镜像"></a>1.1 拉镜像</h3><blockquote><p>docker pull elasticsearch:8.1.3</p><p>docker pull kibana:8.1.3</p></blockquote><h3 id="1-2-起容器"><a href="#1-2-起容器" class="headerlink" title="1.2 起容器"></a>1.2 起容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e discovery.type=single-node -e TZ=&quot;Asia/Shanghai&quot; -e ES_JAVA_OPTS=&quot;-Xms1024m -Xmx1024m&quot; \</span><br><span class="line">-d elasticsearch:8.1.3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-网页登录"><a href="#1-3-网页登录" class="headerlink" title="1.3 网页登录"></a>1.3 网页登录</h3><p>这里一定要是https,不然登录不了</p><blockquote><p><a href="https://192.168.32.133:9200/">https://192.168.32.133:9200</a></p></blockquote><h3 id="1-4-获取密码"><a href="#1-4-获取密码" class="headerlink" title="1.4 获取密码"></a>1.4 获取密码</h3><p>docker 安装ES的 密码 和 kibana登录token 是不会显示在log上的，<br>所以需要手动获取密码</p><p>(1) 进入es容器内</p><p><code>docker exec -it elasticsearch bash</code></p><p>(2) 重置es登录密码</p><p><code>./bin/elasticsearch-reset-password -u elastic</code></p><blockquote><p>页面输出：New value: 29qq*d_PTfOokywpM1Us</p></blockquote><p>(3) 生成登录kibana token</p><p><code>./bin/elasticsearch-create-enrollment-token --scope kibana</code></p><p>得到token：<br><code>eyJ2ZXIiOiI4LjEuMyIsImFkciI6WyIxNzIuMTcuMC4zOjkyMDAiXSwiZmdyIjoiOGMzZTU5MTczMGNlZDg0N2NjODM5ZjgyNDY2OTUzZmI5Nzg3MTVkOTUwYTJlYjNjZjU0ZGI5OWM2ZDNmYjMyMyIsImtleSI6Ii1KUFJXNEFCZS1IZmFxMEpCRDdpOjNhd081VmlZU19XNDVQYThUb1phVGcifQ== </code></p><p>(4) 生成kibana Verification code</p><p><code>docker exec -it kibana bash</code></p><p><code>./bin/kibana-verification-code</code></p><hr><h2 id="2-安装-Kibana"><a href="#2-安装-Kibana" class="headerlink" title="2. 安装 Kibana"></a>2. 安装 Kibana</h2><h3 id="2-1-起容器"><a href="#2-1-起容器" class="headerlink" title="2.1 起容器"></a>2.1 起容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=kibana -p 5601:5601 -e TZ=&quot;Asia/Shanghai&quot; \</span><br><span class="line">-e discovery.type=single-node  -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; \</span><br><span class="line">-d kibana:8.1.3</span><br></pre></td></tr></table></figure><h3 id="2-2-网页登录"><a href="#2-2-网页登录" class="headerlink" title="2.2 网页登录"></a>2.2 网页登录</h3><p>这里一定要是http,不然登录不了</p><blockquote><p><a href="http://192.168.32.133:5601/">http://192.168.32.133:5601</a></p></blockquote><p>登录token 在es的bin里生成的</p><h3 id="2-3-创建新的-superUser"><a href="#2-3-创建新的-superUser" class="headerlink" title="2.3 创建新的 superUser"></a>2.3 创建新的 superUser</h3><p>路径：</p><blockquote><p>Stack Management &gt; Users &gt; create Users</p></blockquote><h3 id="2-4-kibana设置中文"><a href="#2-4-kibana设置中文" class="headerlink" title="2.4 kibana设置中文"></a>2.4 kibana设置中文</h3><p>docker exec -it kibana bash</p><p>echo ‘i18n.locale: “zh-CN”‘ &gt;&gt; config&#x2F;kibana.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">另一种方法是打开文件并写入行，直到您键入 EOT：</span><br><span class="line"></span><br><span class="line">$ cat &lt;&lt;EOT &gt;&gt; result.txt</span><br><span class="line"></span><br><span class="line">line 1</span><br><span class="line"></span><br><span class="line">line 2</span><br><span class="line"></span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 3.环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> Kibana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】StopWatch秒表工具类的使用</title>
      <link href="/2022/03/08/6.stopWatch%20%E7%A7%92%E8%A1%A8%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/08/6.stopWatch%20%E7%A7%92%E8%A1%A8%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里记录计时的工具类：<br>stopWatch常用的有2个，一个是Spring提供的，一个是apache提供的</p></blockquote><h2 id="1-org-apache-commons-lang3-time-StopWatch"><a href="#1-org-apache-commons-lang3-time-StopWatch" class="headerlink" title="1. org.apache.commons.lang3.time.StopWatch"></a>1. org.apache.commons.lang3.time.StopWatch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * start(); //开始计时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * split(); //设置split点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * getSplitTime(); //获取从start 到 最后一次split的时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * reset(); //重置计时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * suspend(); //暂停计时, 直到调用resume()后才恢复计时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * resume(); //恢复计时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stop(); //停止秒表，要再次使用需调用reset()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * getTime(); //统计从start到现在的计时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> org.apache.commons.lang3.time.StopWatch;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>(<span class="string">&quot;apache计时器&quot;</span>);</span><br><span class="line">        watch.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        watch.split();</span><br><span class="line">        System.out.println(<span class="string">&quot;节点1&quot;</span>+watch.getTime());</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">123</span>);</span><br><span class="line">        watch.split();</span><br><span class="line">        watch.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;节点2&quot;</span>+watch.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-org-springframework-util-StopWatch"><a href="#2-org-springframework-util-StopWatch" class="headerlink" title="2. org.springframework.util.StopWatch"></a>2. org.springframework.util.StopWatch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>(<span class="string">&quot;spring计时器&quot;</span>);</span><br><span class="line">        watch.start(<span class="string">&quot;开始点1&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        watch.stop();</span><br><span class="line">        watch.start(<span class="string">&quot;开始点2&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        watch.stop();</span><br><span class="line">        watch.start(<span class="string">&quot;开始点3&quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1200</span>);</span><br><span class="line">        watch.stop();</span><br><span class="line">        log.info(watch.prettyPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PS：常用的时间类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">start</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="type">Instant</span> <span class="variable">end</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(<span class="string">&quot;耗时：&quot;</span> + Duration.between(start, end).toMillis() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 以毫秒表示的当前时间戳</span></span><br><span class="line"><span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> System.currentTimeMillis()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】CountDownLatch线程协同</title>
      <link href="/2022/03/08/5.CountDownLatch%E7%BA%BF%E7%A8%8B%E5%8D%8F%E5%90%8C/"/>
      <url>/2022/03/08/5.CountDownLatch%E7%BA%BF%E7%A8%8B%E5%8D%8F%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CountDownLatch用于主线程和子线程协同配合，常用2种使用方式：</p><ol><li>主线程等待所有的子线程完成任务后再执行</li><li>所有的子线程准备，等待主线程发令执行</li></ol></blockquote><h3 id="用法一：主线程等子线程"><a href="#用法一：主线程等子线程" class="headerlink" title="用法一：主线程等子线程"></a>用法一：主线程等子线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span>+name+<span class="string">&quot;执行任务中...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> + ThreadLocalRandom.current().nextInt(<span class="number">2000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span>+name+<span class="string">&quot;完成任务&quot;</span>);</span><br><span class="line">                    countDownLatch2.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待中....&quot;</span>);</span><br><span class="line">        countDownLatch2.await();<span class="comment">// 主线程在阻塞，当计数器==0，就唤醒主线程往下执行。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程:在所有任务运行完成后，进行结果汇总&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-0执行任务中...</span><br><span class="line">子线程Thread-2执行任务中...</span><br><span class="line">主线程等待中....</span><br><span class="line">子线程Thread-1执行任务中...</span><br><span class="line">子线程Thread-3执行任务中...</span><br><span class="line">子线程Thread-4执行任务中...</span><br><span class="line">子线程Thread-1完成任务</span><br><span class="line">子线程Thread-0完成任务</span><br><span class="line">子线程Thread-3完成任务</span><br><span class="line">子线程Thread-2完成任务</span><br><span class="line">子线程Thread-4完成任务</span><br><span class="line">主线程:在所有任务运行完成后，进行结果汇总</span><br></pre></td></tr></table></figure><h3 id="用法二：所有子线程准备，等待主线程发令执行"><a href="#用法二：所有子线程准备，等待主线程发令执行" class="headerlink" title="用法二：所有子线程准备，等待主线程发令执行"></a>用法二：所有子线程准备，等待主线程发令执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//准备完毕……运动员都阻塞在这，等待号令</span></span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">parter</span> <span class="operator">=</span> <span class="string">&quot;【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】&quot;</span>;</span><br><span class="line">                    System.out.println(parter + <span class="string">&quot;开始执行……&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            System.out.println(<span class="string">&quot;创建线程时间：&quot;</span>+LocalDateTime.now());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;裁判准备发令&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        countDownLatch.countDown();<span class="comment">// 发令枪：执行发令</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建线程时间：2022-03-06T19:12:55.077911700</span><br><span class="line">创建线程时间：2022-03-06T19:12:55.077911700</span><br><span class="line">创建线程时间：2022-03-06T19:12:55.077911700</span><br><span class="line">创建线程时间：2022-03-06T19:12:55.077911700</span><br><span class="line">创建线程时间：2022-03-06T19:12:55.077911700</span><br><span class="line">裁判准备发令</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">【Thread-0】开始执行……</span><br><span class="line">【Thread-2】开始执行……</span><br><span class="line">【Thread-4】开始执行……</span><br><span class="line">【Thread-1】开始执行……</span><br><span class="line">【Thread-3】开始执行……</span><br></pre></td></tr></table></figure><p>ps:</p><blockquote><p>CountDownLatch的作用就是允许一个或多个线程等待其他线程完成操作，看起来有点类似join()方法，但其提供了比join()更加灵活的API。</p><p>CountDownLatch可以手动控制在n个线程里调用n次countDown()方法使计数器进行减一操作，也可以在一个线程里调用n次执行减一操作。</p><p>Thread.join() 当我们调用某个线程的这个方法时，这个方法会挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2022/03/08/3.Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/03/08/3.Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><p><span id="jump1" ></span><br><a href="#jump1">页内跳转</a></p><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>&#x3D;&#x3D;标记文本&#x3D;&#x3D;</p><p><del>删除文本</del></p><p>~ <del>xxx</del> ~</p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p><a href="#jump1">页内跳转</a><br>链接: <a href="https://www.csdn.net/">link</a>.</p><p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="Alt"></p><p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> &#x3D;30x30)</p><p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> &#x3D;30x30)</p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input disabled="" type="checkbox"> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：</p><table><thead><tr><th>项目</th><th>Value</th></tr></thead><tbody><tr><td>电脑</td><td>$1600</td></tr><tr><td>手机</td><td>$12</td></tr><tr><td>导管</td><td>$1</td></tr></tbody></table><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右</p><table><thead><tr><th align="center">第一列</th><th align="right">第二列</th><th align="left">第三列</th></tr></thead><tbody><tr><td align="center">第一列文本居中</td><td align="right">第二列文本居右</td><td align="left">第三列文本居左</td></tr></tbody></table><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：</p><table><thead><tr><th>TYPE</th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>– is en-dash, — is em-dash</td></tr></tbody></table><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^2</a></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) &#x3D; (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/">Mermaid</a>. 例如下面产生的一个序列图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>]]></content>
      
      
      <categories>
          
          <category> 4.各种备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】Thread &amp;&amp; ThreadPool</title>
      <link href="/2022/03/08/2.Thread&amp;ThreadPool/"/>
      <url>/2022/03/08/2.Thread&amp;ThreadPool/</url>
      
        <content type="html"><![CDATA[<blockquote><p>java要使用多线程，一种是直接创建线程，另一种是用线程池<br>1.直接创建：new Thread()<br>2.线程池创建：一种手动创建（推荐），另一种使用Executors创建</p></blockquote><h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><h3 id="1-1-线程的生命周期"><a href="#1-1-线程的生命周期" class="headerlink" title="1.1 线程的生命周期"></a>1.1 线程的生命周期</h3><p><strong>生命周期：</strong><br><img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/05/1.4n2sdqdru200.webp" alt="图解Thread生命周期"></p><p><strong>线程方法：</strong><br><img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/05/thread.2yqh49jz3wq0.webp" alt="线程方法"></p><h3 id="1-2-线程的6种状态"><a href="#1-2-线程的6种状态" class="headerlink" title="1.2 线程的6种状态"></a>1.2 线程的6种状态</h3><p><strong>JVM线程运行状态 (JVM Thread Status)：</strong><br><img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/05/2.71salbu9rsk0.webp" alt="线程方法"></p><h3 id="1-3-创建线程"><a href="#1-3-创建线程" class="headerlink" title="1.3 创建线程"></a>1.3 创建线程</h3><blockquote><p>在 JDK1.5 之前，创建线程就只有两种方式，即继承java.lang.Thread类和实现java.lang.Runnable接口；</p><p>而在 JDK1.5 以后，增加了两个创建线程的方式，即实现java.util.concurrent.Callable接口和线程池。</p></blockquote><h4 id="1-3-1-继承java-lang-Thread类"><a href="#1-3-1-继承java-lang-Thread类" class="headerlink" title="1.3.1 继承java.lang.Thread类"></a>1.3.1 继承java.lang.Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread类来创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程名字</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;main thread&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.setName(<span class="string">&quot;子线程:&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-实现java-lang-Runnable接口"><a href="#1-3-2-实现java-lang-Runnable接口" class="headerlink" title="1.3.2 实现java.lang.Runnable接口"></a>1.3.2 实现java.lang.Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程名字</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;main thread:&quot;</span>);</span><br><span class="line">        <span class="comment">//可用匿名内部类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.setName(<span class="string">&quot;子线程:&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-实现java-util-concurrent-Callable接口"><a href="#1-3-3-实现java-util-concurrent-Callable接口" class="headerlink" title="1.3.3 实现java.util.concurrent.Callable接口"></a>1.3.3 实现java.util.concurrent.Callable接口</h4><blockquote><p>直接继承Thread或者实现Runnable接口都可以创建线程，但是这两种方法都有一个问题就是：没有返回值，也就是不能获取执行完的结果。</p><p>因此java1.5就提供了Callable接口来实现这一场景，而Future和FutureTask就可以和Callable接口配合起来使用。</p><p>Callable必须要借助FutureTask封装才能启动线程，在线程池中并没有使用到FutureTask，而是直通过submit提交上去的。是因为submit里面也是使用了FutureTask，只是他帮我们写好了</p></blockquote><h5 id="（1）Callable接口"><a href="#（1）Callable接口" class="headerlink" title="（1）Callable接口"></a>（1）Callable接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//执行Callable 方式，需要FutureTask 实现实现，用于接收运算结果</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="comment">//接收线程运算后的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//call方法的返回值是泛型，也就是说call方法的返回值类型就是传进来的值的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;sum += i;&#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）future与futuretask"><a href="#（2）future与futuretask" class="headerlink" title="（2）future与futuretask"></a>（2）future与futuretask</h5><p><strong>先看下Future、FutureTask相关类的关系：</strong><br><img src="https://cdn.jsdelivr.net/gh/unravelyt/image-hosting@master/2022/05/3.2q7gqbau0q20.webp" alt="关系"></p><p>Future只是一个接口，FutureTask是实现了RunnableFuture；</p><p><strong>Future接口可以实现的功能</strong>：</p><blockquote><p>Future呈现的是异步计算的结果。Future中的方法提供了检查计算是否已经完成，并且等待计算的结果，还能够重新获取计算记得结果。</p><p>当计算已经完成的时候只能使用get()方法获取结果，如果有需要的话，可以一直阻塞等待结果，直到结果已经准备好了。</p><p>通过cancel()方法可以取消执行。还提供了了其他方法来确定任务是否正常完成或者被取消。一旦一个计算已经完成的话，那么计算是不能够被取消的。</p><p>如果是为了实现可以去掉任务但是不需要返回结果的话，那么就可以使用future，将返回结果设置成null就可以了。</p></blockquote><p><strong>Future的常见的使用方法：</strong> <span id="jump2"></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;String&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;say helloWorld!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> System.out.println(future.get());<span class="comment">// 通过get返回结果</span></span><br></pre></td></tr></table></figure><p>使用get()，主程序将停止往下执行，一直等待结果，直到有返回值，下面的程序才能得到继续的执行。如果不希望因为get一直等待下去的话，可以使用get(long timeout, TimeUnit unit)方法，通过这个方法可以设置等待时间，如果在定时时间内没有得到返回结果的话，将会抛出超时的异常，这种用法用来做远程调用设置超时的场景中。</p><p><strong>FutureTask实现了Future，常见用法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;futureTask say HelloWorld!!!&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line">service.execute(futureTask); <span class="comment">//execute没有返回值的</span></span><br><span class="line">System.out.println(futureTask.get());</span><br></pre></td></tr></table></figure><p>ExecutorService的execute是没有返回值的，使用这种用法需要注意的是FutureTask的get方法会一直等待结果的返回，如果get的调用顺序在execute之前的话，那么程序将会停止在get这里。</p><h4 id="1-3-4-创建线程池"><a href="#1-3-4-创建线程池" class="headerlink" title="1.3.4 创建线程池"></a>1.3.4 创建线程池</h4><p>见： <a href="#jump1">创建线程池</a></p><h3 id="1-4-Java中守护线程和本地线程区别"><a href="#1-4-Java中守护线程和本地线程区别" class="headerlink" title="1.4 Java中守护线程和本地线程区别"></a>1.4 Java中守护线程和本地线程区别</h3><blockquote><p>java 中的线程分为两种：守护线程( Daemon)和用户线程( User)。<br>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(boolon)；true则把该线程设置为守护线程，false则设置为用户线程。Thread.setDaemon() 必须在Thread.start()之前调用，否则运行时会抛出异常。</p><p>守护线程和本地线程两者的区别：<br>唯一的区别是判断虚拟机(JVM)何时离开，守护线程Daemon是为其他线程提供服务，如果全部的用户现场Thread 已经撤离， Daemon 没有可服务的线程，JVM 撤离。</p><p>也可以理解为守护线程是JVM 自动创建的线程( 但不一定)，用户线程是程序创建的线程；比如JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java 虚拟机上仅剩的线 程时，Java 虚拟机会自动离开。</p></blockquote><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池 "></a>2. 线程池 <span id="jump1" desc="线程池跳转"></span></h2><h3 id="2-1-手动创建"><a href="#2-1-手动创建" class="headerlink" title="2.1 手动创建"></a>2.1 手动创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *7.ThreadPoolExecutor：最原始的创建线程池的方式，4个创建方法，它包含了7个参数可供设置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数解释:</span></span><br><span class="line"><span class="comment"> * 1.corePoolSize：核心线程数，会一直存活，即使没有任务，线程池也会维护线程的最少数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.maximumPoolSize： 线程池维护线程的最大数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3.keepAliveTime： 线程池维护线程所允许的空闲时间，当线程空闲时间达到keepAliveTime，该线程会退出，</span></span><br><span class="line"><span class="comment"> *   直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4.unit：线程池维护线程所允许的空闲时间的单位、可选参数值为：TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、     MILLISECONDS、SECONDS。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5.workQueue： 线程池所使用的缓冲队列，常用的是：java.util.concurrent.ArrayBlockingQueue(有界阻塞队列)、</span></span><br><span class="line"><span class="comment"> *                                       LinkedBlockingQueue(双向阻塞队列)、SynchronousQueue(直接提交队列)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 6.threadFactory –执行程序创建新线程时要使用的工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 7.handler：线程池中的数量大于maximumPoolSize，对拒绝任务的处理策略，默认值ThreadPoolExecutor.AbortPolicy()。</span></span><br><span class="line"><span class="comment"> *            AbortPolicy：拒绝并抛出异常。</span></span><br><span class="line"><span class="comment"> *            CallerRunsPolicy：使用当前调用的线程来执行此任务。</span></span><br><span class="line"><span class="comment"> *            DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。</span></span><br><span class="line"><span class="comment"> *            DiscardPolicy：忽略并抛弃当前任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">build</span> <span class="operator">=</span> ThreadFactoryBuilder.create().setNamePrefix(<span class="string">&quot;demo-thread-%d&quot;</span>).build();</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">3</span>, <span class="comment">//corePoolSize</span></span><br><span class="line">        <span class="number">5</span>, <span class="comment">//maximumPoolSize</span></span><br><span class="line">        <span class="number">30</span>, <span class="comment">//keepAliveTime</span></span><br><span class="line">        TimeUnit.SECONDS, <span class="comment">//unit</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(), <span class="comment">//workQueue</span></span><br><span class="line">        threadFactory, <span class="comment">//threadFactory</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">//handler</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//execute没有返回值</span></span><br><span class="line">threadPool.execute(() -&gt;&#123;&#125;);</span><br><span class="line"><span class="comment">//submit有返回值</span></span><br><span class="line">Future&lt;?&gt; submit = threadPool.submit(() -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>见：<a href="#jump2">Future的用法</a></p><h4 id="2-1-1-ThreadFactory的4种创建方式"><a href="#2-1-1-ThreadFactory的4种创建方式" class="headerlink" title="2.1.1 ThreadFactory的4种创建方式"></a>2.1.1 ThreadFactory的4种创建方式</h4><p><strong>（1）Spring 框架提供的 <code>CustomizableThreadFactory</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">springThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomizableThreadFactory</span>(<span class="string">&quot;springThread-pool-&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>（2）Google guava 工具类 提供的 <code>ThreadFactoryBuilder</code> ,使用链式方法创建。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">guavaThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;retryClient-pool-&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>（3）Apache commons-lang3 提供的 <code>BasicThreadFactory</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">basicThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicThreadFactory</span>.Builder()</span><br><span class="line">.namingPattern(<span class="string">&quot;basicThreadFactory-&quot;</span>).build();</span><br></pre></td></tr></table></figure><p><strong>（4）hutool工具类提供的<code>ThreadFactoryBuilder</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">hutoolThreadFactory</span> <span class="operator">=</span> ThreadFactoryBuilder.create().setNamePrefix(<span class="string">&quot;demo-thread-%d&quot;</span>).build();</span><br></pre></td></tr></table></figure><h3 id="2-2-newSingleThreadExecutor"><a href="#2-2-newSingleThreadExecutor" class="headerlink" title="2.2 newSingleThreadExecutor"></a>2.2 newSingleThreadExecutor</h3><p><strong>创建一个单线程的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缺点：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</span><br></pre></td></tr></table></figure><p>从参数可以看出来，SingleThreadExecutor 相当于特殊的 FixedThreadPool，它的执行流程如下：</p><ol><li>线程池中没有线程时，新建一个线程执行任务</li><li>有一个线程以后，将任务加入阻塞队列，不停的加</li><li>唯一的这一个线程不停地去队列里取任务执行</li></ol><p><strong>SingleThreadExecutor 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行</strong>。</p><h3 id="2-3-newFixedThreadPool"><a href="#2-3-newFixedThreadPool" class="headerlink" title="2.3 newFixedThreadPool"></a>2.3 newFixedThreadPool</h3><p><strong>创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">//固定3个线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缺点：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</span><br></pre></td></tr></table></figure><p>可以看到，FixedThreadPool 的核心线程数和最大线程数都是指定值，也就是说当线程池中的线程数超过核心线程数后，任务都会被放到阻塞队列中。</p><p>此外 keepAliveTime 为 0，也就是多余的空余线程会被立即终止（由于这里没有多余线程，这个参数也没什么意义了）。</p><p>而这里选用的阻塞队列是 LinkedBlockingQueue，使用的是默认容量 Integer.MAX_VALUE，相当于没有上限。</p><p>因此这个线程池执行任务的流程如下：</p><ol><li>线程数少于核心线程数，也就是设置的线程数时，新建线程执行任务</li><li>线程数等于核心线程数后，将任务加入阻塞队列</li><li>由于队列容量非常大，可以一直加</li><li>执行完任务的线程反复去队列中取任务执行</li></ol><p><strong>FixedThreadPool 用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量</strong>。</p><h3 id="2-4-newCachedThreadPool"><a href="#2-4-newCachedThreadPool" class="headerlink" title="2.4 newCachedThreadPool"></a>2.4 newCachedThreadPool</h3><p><strong>创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM</span><br></pre></td></tr></table></figure><p>可以看到，CachedThreadPool 没有核心线程，非核心线程数无上限，也就是全部使用外包，但是每个外包空闲的时间只有 60 秒，超过后就会被回收。</p><p>CachedThreadPool 使用的队列是 SynchronousQueue，这个队列的作用就是传递任务，并不会保存。</p><p>因此当提交任务的速度大于处理任务的速度时，每次提交一个任务，就会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。</p><p>它的执行流程如下：</p><ol><li>没有核心线程，直接向 SynchronousQueue 中提交任务</li><li>如果有空闲线程，就去取出任务执行；如果没有空闲线程，就新建一个</li><li>执行完任务的线程有 60 秒生存时间，如果在这个时间内可以接到新任务，就可以继续活下去，否则就拜拜</li><li>由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</li></ol><p><strong>CachedThreadPool 用于并发执行大量短期的小任务，或者是负载较轻的服务器</strong>。</p><h3 id="2-5-newScheduledThreadPool"><a href="#2-5-newScheduledThreadPool" class="headerlink" title="2.5 newScheduledThreadPool"></a>2.5 newScheduledThreadPool</h3><h4 id="2-5-1-创建一个可以执行延迟任务的线程池"><a href="#2-5-1-创建一个可以执行延迟任务的线程池" class="headerlink" title="2.5.1 创建一个可以执行延迟任务的线程池"></a>2.5.1 创建一个可以执行延迟任务的线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单线程延迟任务的线程池</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">singleThreadScheduledPool</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"><span class="comment">//自定义线程数的延迟任务线程池</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 的执行流程如下：</p><ol><li>添加一个任务</li><li>线程池中的线程从 DelayQueue 中取任务</li><li>然后执行任务</li></ol><p>具体执行任务的步骤也比较复杂：</p><ol><li>线程从 DelayQueue 中获取 time 大于等于当前时间的 ScheduledFutureTask</li><li>执行完后修改这个 task 的 time 为下次被执行的时间</li><li>然后再把这个 task 放回队列中</li></ol><p><strong>ScheduledThreadPoolExecutor 用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景</strong>。</p><h4 id="2-5-2-延迟线程池使用方式"><a href="#2-5-2-延迟线程池使用方式" class="headerlink" title="2.5.2 延迟线程池使用方式"></a>2.5.2 延迟线程池使用方式</h4><p><strong>（1）延迟3秒执行，只执行一次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scheduledThreadPool.schedule(() -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span>+ LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">&#125;,<span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><strong>（2）表示延迟1秒后每3秒执行一次，有可能延迟超过3秒后才执行下一次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;延迟1秒后每三秒执行一次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>分为两种情况：</p><ol><li><p>当前任务执行时间小于间隔时间，每次到点即执行；</p><p><code>程序启动时间是14:36:00，以后每间隔10s执行一次(即14:36:10、14:36:20、14:36:30等)。</code></p></li><li><p>当前任务执行时间大于等于间隔时间，任务执行后立即执行下一次任务。相当于连续执行了;</p><p><code>程序启动时间是14:30:13，按理说应该每间隔10s执行一次（即14:30:23、14:30:33等），但由于任务执行时间长于10s，下一次的任务要开始的时候发现上次的任务还没有完成，因此阻塞等待，一旦发现上次的任务完成，就马上启动。表现出来就是任务延时启动，最终的效果就是连续执行。</code></p></li></ol><p><strong>（3）表示延迟1秒后每3秒执行一次，上一次执行完成时间到下一次开始时间是固定的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以每个End后，等待了10秒，才启动下一次Start。</span></span><br><span class="line">scheduledThreadPool.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;延迟1秒后每三秒执行一次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="2-6-newWorkStealingPool"><a href="#2-6-newWorkStealingPool" class="headerlink" title="2.6 newWorkStealingPool"></a>2.6 newWorkStealingPool</h3><p><a href="https://blog.csdn.net/f641385712/article/details/83749798">https://blog.csdn.net/f641385712/article/details/83749798</a></p>]]></content>
      
      
      <categories>
          
          <category> 2.代码相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建个人博客</title>
      <link href="/2021/11/11/1.Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/11/11/1.Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h2><p>（1）下载并安装Node.js（最新版本即可） <a href="http://nodejs.cn/download/"> Node.js 中文网 </a><br>（2）检查版本：<code>node -v</code></p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><p>（1）下载并安装Git（最新版本即可）<a href="https://git-scm.com/downloads"> Git官网 </a><br>（2）检查版本：<code>git version</code></p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h2><p>（1）安装Hexo：<code>npm install -g hexo-cli</code><br>（2）检查版本：<code>hexo -v</code><br>（3）详细指南：<a href="https://hexo.io/zh-cn/">Hexo官网</a></p><h2 id="4-Hexo初始化"><a href="#4-Hexo初始化" class="headerlink" title="4. Hexo初始化"></a>4. Hexo初始化</h2><p>（1）在D盘新建一个文件夹：D:\blog<br>（2）在D:\blog文件夹内初始化Hexo：<code>hexo init</code><br>（3）启动 hexo, 在当前路径内执行：<code>hexo s</code><br>（4）访问：<code>localhost:4000</code></p><h2 id="5-Hexo常用命令"><a href="#5-Hexo常用命令" class="headerlink" title="5. Hexo常用命令"></a>5. Hexo常用命令</h2><p>（1）创建一个博客：<code>hexo new &quot;My New Post&quot;</code><br>（2）启动：<code>hexo server</code> 简写：<code>hexo s</code><br>（3）生成静态文件：<code>hexo generate</code> 简写：<code>hexo g</code><br>（4）部署网站：<code>hexo deploy</code> 简写：<code>hexo d</code><br>（5）<code>hexo clean</code> </p><h2 id="6-部署到Gitee"><a href="#6-部署到Gitee" class="headerlink" title="6.部署到Gitee"></a>6.部署到Gitee</h2><p>（1）新建一个公开的仓库 仓库的名称和路径保存一致<br>例如：仓库名称为<code>myblog</code>， 仓库路径为：<code>https://gitee.com/mygitee/myblog</code><br>（2）修改hexo配置文件</p><p>（3）安装Git 部署的插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>（4）修改配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xxxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>帮助中心：<a href="https://gitee.com/help/articles/4136#article-header0">Gitee 帮助中心</a></p><p>推荐主题：<a href="https://keep-docs.xpoet.cn/">hexo-theme-keep</a></p><h2 id="7-安装Butterfly主题"><a href="#7-安装Butterfly主题" class="headerlink" title="7.安装Butterfly主题"></a>7.安装Butterfly主题</h2><p>（1）到hexo根目录下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>（2）安装主题插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>（3）自行修改主题配置</p><p>（4）引入外部JS换成本地引入</p><ul><li>安装插件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-extjs</span><br></pre></td></tr></table></figure><ul><li>修改主题配置，third_party_provider: local</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CDN:</span><br><span class="line">  # The CDN provider of internal scripts (主題內部 js 的 cdn 配置)</span><br><span class="line">  # option: local/jsdelivr</span><br><span class="line">  # Dev version cannot choose jsdelivr (dev版的主題不能設置為 jsdelivr)</span><br><span class="line">  internal_provider: local</span><br><span class="line">  # The CDN provider of third party scripts (第三方 js 的 cdn 配置)</span><br><span class="line">  # option: local/jsdelivr</span><br><span class="line">  # when set it to local, you need to install hexo-butterfly-extjs</span><br><span class="line">  third_party_provider: local</span><br></pre></td></tr></table></figure><h2 id="8-处理Butterfly警告"><a href="#8-处理Butterfly警告" class="headerlink" title="8.处理Butterfly警告"></a>8.处理Butterfly警告</h2><p>启动后访问会出现如下日志：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">INFO</span>  <span class="title class_">Hexo</span> is running at <span class="attr">http</span>:<span class="comment">//localhost:4000/ . Press Ctrl+C to stop.</span></span><br><span class="line">(<span class="attr">node</span>:<span class="number">19140</span>) <span class="title class_">Warning</span>: <span class="title class_">Accessing</span> non-existent property <span class="string">&#x27;lineno&#x27;</span> <span class="keyword">of</span> <span class="variable language_">module</span> <span class="built_in">exports</span> inside circular dependency</span><br><span class="line">(<span class="title class_">Use</span> <span class="string">`node --trace-warnings ...`</span> to show where the warning was created)</span><br><span class="line">(<span class="attr">node</span>:<span class="number">19140</span>) <span class="title class_">Warning</span>: <span class="title class_">Accessing</span> non-existent property <span class="string">&#x27;column&#x27;</span> <span class="keyword">of</span> <span class="variable language_">module</span> <span class="built_in">exports</span> inside circular dependency</span><br><span class="line">(<span class="attr">node</span>:<span class="number">19140</span>) <span class="title class_">Warning</span>: <span class="title class_">Accessing</span> non-existent property <span class="string">&#x27;filename&#x27;</span> <span class="keyword">of</span> <span class="variable language_">module</span> <span class="built_in">exports</span> inside circular dependency</span><br><span class="line">(<span class="attr">node</span>:<span class="number">19140</span>) <span class="title class_">Warning</span>: <span class="title class_">Accessing</span> non-existent property <span class="string">&#x27;lineno&#x27;</span> <span class="keyword">of</span> <span class="variable language_">module</span> <span class="built_in">exports</span> inside circular dependency</span><br><span class="line">(<span class="attr">node</span>:<span class="number">19140</span>) <span class="title class_">Warning</span>: <span class="title class_">Accessing</span> non-existent property <span class="string">&#x27;column&#x27;</span> <span class="keyword">of</span> <span class="variable language_">module</span> <span class="built_in">exports</span> inside circular dependency</span><br><span class="line">(<span class="attr">node</span>:<span class="number">19140</span>) <span class="title class_">Warning</span>: <span class="title class_">Accessing</span> non-existent property <span class="string">&#x27;filename&#x27;</span> <span class="keyword">of</span> <span class="variable language_">module</span> <span class="built_in">exports</span> inside circular dependenc</span><br></pre></td></tr></table></figure><p>解决：</p><ul><li><p>进去对应目录找到index.js <code>D:\hexo\node_modules\nib\node_modules\stylus\lib\nodes</code></p></li><li><p>添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">lineno</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">column</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">filename</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>hexo clean  &amp; hexo s 问题解决</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3.环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
